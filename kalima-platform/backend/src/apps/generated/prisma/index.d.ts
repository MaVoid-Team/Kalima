
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model auth_identities
 * 
 */
export type auth_identities = $Result.DefaultSelection<Prisma.$auth_identitiesPayload>
/**
 * Model user_analytics
 * 
 */
export type user_analytics = $Result.DefaultSelection<Prisma.$user_analyticsPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model refresh_tokens
 * 
 */
export type refresh_tokens = $Result.DefaultSelection<Prisma.$refresh_tokensPayload>
/**
 * Model assistants
 * 
 */
export type assistants = $Result.DefaultSelection<Prisma.$assistantsPayload>
/**
 * Model government
 * 
 */
export type government = $Result.DefaultSelection<Prisma.$governmentPayload>
/**
 * Model lecturers
 * 
 */
export type lecturers = $Result.DefaultSelection<Prisma.$lecturersPayload>
/**
 * Model levels
 * 
 */
export type levels = $Result.DefaultSelection<Prisma.$levelsPayload>
/**
 * Model parent_children
 * 
 */
export type parent_children = $Result.DefaultSelection<Prisma.$parent_childrenPayload>
/**
 * Model parents
 * 
 */
export type parents = $Result.DefaultSelection<Prisma.$parentsPayload>
/**
 * Model sites
 * 
 */
export type sites = $Result.DefaultSelection<Prisma.$sitesPayload>
/**
 * Model social_media
 * 
 */
export type social_media = $Result.DefaultSelection<Prisma.$social_mediaPayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>
/**
 * Model subjects
 * 
 */
export type subjects = $Result.DefaultSelection<Prisma.$subjectsPayload>
/**
 * Model teachers
 * 
 */
export type teachers = $Result.DefaultSelection<Prisma.$teachersPayload>
/**
 * Model teaches_at
 * 
 */
export type teaches_at = $Result.DefaultSelection<Prisma.$teaches_atPayload>
/**
 * Model zones
 * 
 */
export type zones = $Result.DefaultSelection<Prisma.$zonesPayload>
/**
 * Model email_verification_tokens
 * 
 */
export type email_verification_tokens = $Result.DefaultSelection<Prisma.$email_verification_tokensPayload>
/**
 * Model password_reset_tokens
 * 
 */
export type password_reset_tokens = $Result.DefaultSelection<Prisma.$password_reset_tokensPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const auth_provider_enum: {
  local: 'local',
  firebase: 'firebase',
  google: 'google',
  facebook: 'facebook'
};

export type auth_provider_enum = (typeof auth_provider_enum)[keyof typeof auth_provider_enum]


export const gender_enum: {
  male: 'male',
  female: 'female'
};

export type gender_enum = (typeof gender_enum)[keyof typeof gender_enum]


export const portal_enum: {
  store: 'store',
  academy: 'academy'
};

export type portal_enum = (typeof portal_enum)[keyof typeof portal_enum]


export const role_enum: {
  Admin: 'Admin',
  SubAdmin: 'SubAdmin',
  Teacher: 'Teacher',
  Student: 'Student',
  Parent: 'Parent',
  Lecturer: 'Lecturer',
  Moderator: 'Moderator',
  Assistant: 'Assistant'
};

export type role_enum = (typeof role_enum)[keyof typeof role_enum]


export const location_type_enum: {
  School: 'School',
  Center: 'Center'
};

export type location_type_enum = (typeof location_type_enum)[keyof typeof location_type_enum]

}

export type auth_provider_enum = $Enums.auth_provider_enum

export const auth_provider_enum: typeof $Enums.auth_provider_enum

export type gender_enum = $Enums.gender_enum

export const gender_enum: typeof $Enums.gender_enum

export type portal_enum = $Enums.portal_enum

export const portal_enum: typeof $Enums.portal_enum

export type role_enum = $Enums.role_enum

export const role_enum: typeof $Enums.role_enum

export type location_type_enum = $Enums.location_type_enum

export const location_type_enum: typeof $Enums.location_type_enum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auth_identities
 * const auth_identities = await prisma.auth_identities.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auth_identities
   * const auth_identities = await prisma.auth_identities.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.auth_identities`: Exposes CRUD operations for the **auth_identities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_identities
    * const auth_identities = await prisma.auth_identities.findMany()
    * ```
    */
  get auth_identities(): Prisma.auth_identitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_analytics`: Exposes CRUD operations for the **user_analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_analytics
    * const user_analytics = await prisma.user_analytics.findMany()
    * ```
    */
  get user_analytics(): Prisma.user_analyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refresh_tokens`: Exposes CRUD operations for the **refresh_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refresh_tokens
    * const refresh_tokens = await prisma.refresh_tokens.findMany()
    * ```
    */
  get refresh_tokens(): Prisma.refresh_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assistants`: Exposes CRUD operations for the **assistants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assistants
    * const assistants = await prisma.assistants.findMany()
    * ```
    */
  get assistants(): Prisma.assistantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.government`: Exposes CRUD operations for the **government** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Governments
    * const governments = await prisma.government.findMany()
    * ```
    */
  get government(): Prisma.governmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecturers`: Exposes CRUD operations for the **lecturers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturers
    * const lecturers = await prisma.lecturers.findMany()
    * ```
    */
  get lecturers(): Prisma.lecturersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.levels`: Exposes CRUD operations for the **levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.levels.findMany()
    * ```
    */
  get levels(): Prisma.levelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent_children`: Exposes CRUD operations for the **parent_children** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parent_children
    * const parent_children = await prisma.parent_children.findMany()
    * ```
    */
  get parent_children(): Prisma.parent_childrenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.parentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sites`: Exposes CRUD operations for the **sites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.sites.findMany()
    * ```
    */
  get sites(): Prisma.sitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.social_media`: Exposes CRUD operations for the **social_media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Social_medias
    * const social_medias = await prisma.social_media.findMany()
    * ```
    */
  get social_media(): Prisma.social_mediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.subjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.teachersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teaches_at`: Exposes CRUD operations for the **teaches_at** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teaches_ats
    * const teaches_ats = await prisma.teaches_at.findMany()
    * ```
    */
  get teaches_at(): Prisma.teaches_atDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zones`: Exposes CRUD operations for the **zones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zones.findMany()
    * ```
    */
  get zones(): Prisma.zonesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_verification_tokens`: Exposes CRUD operations for the **email_verification_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_verification_tokens
    * const email_verification_tokens = await prisma.email_verification_tokens.findMany()
    * ```
    */
  get email_verification_tokens(): Prisma.email_verification_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_tokens`: Exposes CRUD operations for the **password_reset_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
    * ```
    */
  get password_reset_tokens(): Prisma.password_reset_tokensDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    auth_identities: 'auth_identities',
    user_analytics: 'user_analytics',
    user_roles: 'user_roles',
    users: 'users',
    refresh_tokens: 'refresh_tokens',
    assistants: 'assistants',
    government: 'government',
    lecturers: 'lecturers',
    levels: 'levels',
    parent_children: 'parent_children',
    parents: 'parents',
    sites: 'sites',
    social_media: 'social_media',
    students: 'students',
    subjects: 'subjects',
    teachers: 'teachers',
    teaches_at: 'teaches_at',
    zones: 'zones',
    email_verification_tokens: 'email_verification_tokens',
    password_reset_tokens: 'password_reset_tokens'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "auth_identities" | "user_analytics" | "user_roles" | "users" | "refresh_tokens" | "assistants" | "government" | "lecturers" | "levels" | "parent_children" | "parents" | "sites" | "social_media" | "students" | "subjects" | "teachers" | "teaches_at" | "zones" | "email_verification_tokens" | "password_reset_tokens"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      auth_identities: {
        payload: Prisma.$auth_identitiesPayload<ExtArgs>
        fields: Prisma.auth_identitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_identitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_identitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          findFirst: {
            args: Prisma.auth_identitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_identitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          findMany: {
            args: Prisma.auth_identitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>[]
          }
          create: {
            args: Prisma.auth_identitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          createMany: {
            args: Prisma.auth_identitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_identitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>[]
          }
          delete: {
            args: Prisma.auth_identitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          update: {
            args: Prisma.auth_identitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          deleteMany: {
            args: Prisma.auth_identitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_identitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_identitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>[]
          }
          upsert: {
            args: Prisma.auth_identitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_identitiesPayload>
          }
          aggregate: {
            args: Prisma.Auth_identitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_identities>
          }
          groupBy: {
            args: Prisma.auth_identitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_identitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_identitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_identitiesCountAggregateOutputType> | number
          }
        }
      }
      user_analytics: {
        payload: Prisma.$user_analyticsPayload<ExtArgs>
        fields: Prisma.user_analyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_analyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_analyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findFirst: {
            args: Prisma.user_analyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_analyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findMany: {
            args: Prisma.user_analyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          create: {
            args: Prisma.user_analyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          createMany: {
            args: Prisma.user_analyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_analyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          delete: {
            args: Prisma.user_analyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          update: {
            args: Prisma.user_analyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          deleteMany: {
            args: Prisma.user_analyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_analyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_analyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          upsert: {
            args: Prisma.user_analyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          aggregate: {
            args: Prisma.User_analyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_analytics>
          }
          groupBy: {
            args: Prisma.user_analyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_analyticsCountArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      refresh_tokens: {
        payload: Prisma.$refresh_tokensPayload<ExtArgs>
        fields: Prisma.refresh_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refresh_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refresh_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findFirst: {
            args: Prisma.refresh_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refresh_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findMany: {
            args: Prisma.refresh_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          create: {
            args: Prisma.refresh_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          createMany: {
            args: Prisma.refresh_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.refresh_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          delete: {
            args: Prisma.refresh_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          update: {
            args: Prisma.refresh_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          deleteMany: {
            args: Prisma.refresh_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refresh_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.refresh_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          upsert: {
            args: Prisma.refresh_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          aggregate: {
            args: Prisma.Refresh_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefresh_tokens>
          }
          groupBy: {
            args: Prisma.refresh_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.refresh_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensCountAggregateOutputType> | number
          }
        }
      }
      assistants: {
        payload: Prisma.$assistantsPayload<ExtArgs>
        fields: Prisma.assistantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assistantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assistantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          findFirst: {
            args: Prisma.assistantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assistantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          findMany: {
            args: Prisma.assistantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>[]
          }
          create: {
            args: Prisma.assistantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          createMany: {
            args: Prisma.assistantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assistantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>[]
          }
          delete: {
            args: Prisma.assistantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          update: {
            args: Prisma.assistantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          deleteMany: {
            args: Prisma.assistantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assistantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assistantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>[]
          }
          upsert: {
            args: Prisma.assistantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assistantsPayload>
          }
          aggregate: {
            args: Prisma.AssistantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssistants>
          }
          groupBy: {
            args: Prisma.assistantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssistantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.assistantsCountArgs<ExtArgs>
            result: $Utils.Optional<AssistantsCountAggregateOutputType> | number
          }
        }
      }
      government: {
        payload: Prisma.$governmentPayload<ExtArgs>
        fields: Prisma.governmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.governmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.governmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          findFirst: {
            args: Prisma.governmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.governmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          findMany: {
            args: Prisma.governmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>[]
          }
          create: {
            args: Prisma.governmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          createMany: {
            args: Prisma.governmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.governmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>[]
          }
          delete: {
            args: Prisma.governmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          update: {
            args: Prisma.governmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          deleteMany: {
            args: Prisma.governmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.governmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.governmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>[]
          }
          upsert: {
            args: Prisma.governmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$governmentPayload>
          }
          aggregate: {
            args: Prisma.GovernmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernment>
          }
          groupBy: {
            args: Prisma.governmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.governmentCountArgs<ExtArgs>
            result: $Utils.Optional<GovernmentCountAggregateOutputType> | number
          }
        }
      }
      lecturers: {
        payload: Prisma.$lecturersPayload<ExtArgs>
        fields: Prisma.lecturersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lecturersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lecturersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          findFirst: {
            args: Prisma.lecturersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lecturersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          findMany: {
            args: Prisma.lecturersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          create: {
            args: Prisma.lecturersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          createMany: {
            args: Prisma.lecturersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lecturersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          delete: {
            args: Prisma.lecturersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          update: {
            args: Prisma.lecturersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          deleteMany: {
            args: Prisma.lecturersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lecturersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lecturersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>[]
          }
          upsert: {
            args: Prisma.lecturersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lecturersPayload>
          }
          aggregate: {
            args: Prisma.LecturersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLecturers>
          }
          groupBy: {
            args: Prisma.lecturersGroupByArgs<ExtArgs>
            result: $Utils.Optional<LecturersGroupByOutputType>[]
          }
          count: {
            args: Prisma.lecturersCountArgs<ExtArgs>
            result: $Utils.Optional<LecturersCountAggregateOutputType> | number
          }
        }
      }
      levels: {
        payload: Prisma.$levelsPayload<ExtArgs>
        fields: Prisma.levelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.levelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.levelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          findFirst: {
            args: Prisma.levelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.levelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          findMany: {
            args: Prisma.levelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>[]
          }
          create: {
            args: Prisma.levelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          createMany: {
            args: Prisma.levelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.levelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>[]
          }
          delete: {
            args: Prisma.levelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          update: {
            args: Prisma.levelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          deleteMany: {
            args: Prisma.levelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.levelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.levelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>[]
          }
          upsert: {
            args: Prisma.levelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          aggregate: {
            args: Prisma.LevelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevels>
          }
          groupBy: {
            args: Prisma.levelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.levelsCountArgs<ExtArgs>
            result: $Utils.Optional<LevelsCountAggregateOutputType> | number
          }
        }
      }
      parent_children: {
        payload: Prisma.$parent_childrenPayload<ExtArgs>
        fields: Prisma.parent_childrenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parent_childrenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parent_childrenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          findFirst: {
            args: Prisma.parent_childrenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parent_childrenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          findMany: {
            args: Prisma.parent_childrenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>[]
          }
          create: {
            args: Prisma.parent_childrenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          createMany: {
            args: Prisma.parent_childrenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parent_childrenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>[]
          }
          delete: {
            args: Prisma.parent_childrenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          update: {
            args: Prisma.parent_childrenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          deleteMany: {
            args: Prisma.parent_childrenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parent_childrenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.parent_childrenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>[]
          }
          upsert: {
            args: Prisma.parent_childrenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_childrenPayload>
          }
          aggregate: {
            args: Prisma.Parent_childrenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent_children>
          }
          groupBy: {
            args: Prisma.parent_childrenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Parent_childrenGroupByOutputType>[]
          }
          count: {
            args: Prisma.parent_childrenCountArgs<ExtArgs>
            result: $Utils.Optional<Parent_childrenCountAggregateOutputType> | number
          }
        }
      }
      parents: {
        payload: Prisma.$parentsPayload<ExtArgs>
        fields: Prisma.parentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findFirst: {
            args: Prisma.parentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findMany: {
            args: Prisma.parentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          create: {
            args: Prisma.parentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          createMany: {
            args: Prisma.parentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          delete: {
            args: Prisma.parentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          update: {
            args: Prisma.parentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          deleteMany: {
            args: Prisma.parentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.parentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          upsert: {
            args: Prisma.parentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.parentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      sites: {
        payload: Prisma.$sitesPayload<ExtArgs>
        fields: Prisma.sitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          findFirst: {
            args: Prisma.sitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          findMany: {
            args: Prisma.sitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          create: {
            args: Prisma.sitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          createMany: {
            args: Prisma.sitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          delete: {
            args: Prisma.sitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          update: {
            args: Prisma.sitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          deleteMany: {
            args: Prisma.sitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sitesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>[]
          }
          upsert: {
            args: Prisma.sitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sitesPayload>
          }
          aggregate: {
            args: Prisma.SitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSites>
          }
          groupBy: {
            args: Prisma.sitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.sitesCountArgs<ExtArgs>
            result: $Utils.Optional<SitesCountAggregateOutputType> | number
          }
        }
      }
      social_media: {
        payload: Prisma.$social_mediaPayload<ExtArgs>
        fields: Prisma.social_mediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.social_mediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.social_mediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          findFirst: {
            args: Prisma.social_mediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.social_mediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          findMany: {
            args: Prisma.social_mediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>[]
          }
          create: {
            args: Prisma.social_mediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          createMany: {
            args: Prisma.social_mediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.social_mediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>[]
          }
          delete: {
            args: Prisma.social_mediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          update: {
            args: Prisma.social_mediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          deleteMany: {
            args: Prisma.social_mediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.social_mediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.social_mediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>[]
          }
          upsert: {
            args: Prisma.social_mediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_mediaPayload>
          }
          aggregate: {
            args: Prisma.Social_mediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocial_media>
          }
          groupBy: {
            args: Prisma.social_mediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Social_mediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.social_mediaCountArgs<ExtArgs>
            result: $Utils.Optional<Social_mediaCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      subjects: {
        payload: Prisma.$subjectsPayload<ExtArgs>
        fields: Prisma.subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findFirst: {
            args: Prisma.subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findMany: {
            args: Prisma.subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          create: {
            args: Prisma.subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          createMany: {
            args: Prisma.subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          delete: {
            args: Prisma.subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          update: {
            args: Prisma.subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          deleteMany: {
            args: Prisma.subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.subjectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          upsert: {
            args: Prisma.subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      teachers: {
        payload: Prisma.$teachersPayload<ExtArgs>
        fields: Prisma.teachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findFirst: {
            args: Prisma.teachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findMany: {
            args: Prisma.teachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          create: {
            args: Prisma.teachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          createMany: {
            args: Prisma.teachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          delete: {
            args: Prisma.teachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          update: {
            args: Prisma.teachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          deleteMany: {
            args: Prisma.teachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teachersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          upsert: {
            args: Prisma.teachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.teachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.teachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      teaches_at: {
        payload: Prisma.$teaches_atPayload<ExtArgs>
        fields: Prisma.teaches_atFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teaches_atFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teaches_atFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          findFirst: {
            args: Prisma.teaches_atFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teaches_atFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          findMany: {
            args: Prisma.teaches_atFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>[]
          }
          create: {
            args: Prisma.teaches_atCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          createMany: {
            args: Prisma.teaches_atCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teaches_atCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>[]
          }
          delete: {
            args: Prisma.teaches_atDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          update: {
            args: Prisma.teaches_atUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          deleteMany: {
            args: Prisma.teaches_atDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teaches_atUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teaches_atUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>[]
          }
          upsert: {
            args: Prisma.teaches_atUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teaches_atPayload>
          }
          aggregate: {
            args: Prisma.Teaches_atAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeaches_at>
          }
          groupBy: {
            args: Prisma.teaches_atGroupByArgs<ExtArgs>
            result: $Utils.Optional<Teaches_atGroupByOutputType>[]
          }
          count: {
            args: Prisma.teaches_atCountArgs<ExtArgs>
            result: $Utils.Optional<Teaches_atCountAggregateOutputType> | number
          }
        }
      }
      zones: {
        payload: Prisma.$zonesPayload<ExtArgs>
        fields: Prisma.zonesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zonesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zonesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          findFirst: {
            args: Prisma.zonesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zonesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          findMany: {
            args: Prisma.zonesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          create: {
            args: Prisma.zonesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          createMany: {
            args: Prisma.zonesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zonesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          delete: {
            args: Prisma.zonesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          update: {
            args: Prisma.zonesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          deleteMany: {
            args: Prisma.zonesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zonesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zonesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          upsert: {
            args: Prisma.zonesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          aggregate: {
            args: Prisma.ZonesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZones>
          }
          groupBy: {
            args: Prisma.zonesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZonesGroupByOutputType>[]
          }
          count: {
            args: Prisma.zonesCountArgs<ExtArgs>
            result: $Utils.Optional<ZonesCountAggregateOutputType> | number
          }
        }
      }
      email_verification_tokens: {
        payload: Prisma.$email_verification_tokensPayload<ExtArgs>
        fields: Prisma.email_verification_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_verification_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_verification_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          findFirst: {
            args: Prisma.email_verification_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_verification_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          findMany: {
            args: Prisma.email_verification_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>[]
          }
          create: {
            args: Prisma.email_verification_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          createMany: {
            args: Prisma.email_verification_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_verification_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>[]
          }
          delete: {
            args: Prisma.email_verification_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          update: {
            args: Prisma.email_verification_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          deleteMany: {
            args: Prisma.email_verification_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_verification_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_verification_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>[]
          }
          upsert: {
            args: Prisma.email_verification_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_verification_tokensPayload>
          }
          aggregate: {
            args: Prisma.Email_verification_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_verification_tokens>
          }
          groupBy: {
            args: Prisma.email_verification_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_verification_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_verification_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Email_verification_tokensCountAggregateOutputType> | number
          }
        }
      }
      password_reset_tokens: {
        payload: Prisma.$password_reset_tokensPayload<ExtArgs>
        fields: Prisma.password_reset_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.password_reset_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          delete: {
            args: Prisma.password_reset_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          update: {
            args: Prisma.password_reset_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          upsert: {
            args: Prisma.password_reset_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_tokens>
          }
          groupBy: {
            args: Prisma.password_reset_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    auth_identities?: auth_identitiesOmit
    user_analytics?: user_analyticsOmit
    user_roles?: user_rolesOmit
    users?: usersOmit
    refresh_tokens?: refresh_tokensOmit
    assistants?: assistantsOmit
    government?: governmentOmit
    lecturers?: lecturersOmit
    levels?: levelsOmit
    parent_children?: parent_childrenOmit
    parents?: parentsOmit
    sites?: sitesOmit
    social_media?: social_mediaOmit
    students?: studentsOmit
    subjects?: subjectsOmit
    teachers?: teachersOmit
    teaches_at?: teaches_atOmit
    zones?: zonesOmit
    email_verification_tokens?: email_verification_tokensOmit
    password_reset_tokens?: password_reset_tokensOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    assistants: number
    auth_identities: number
    refresh_tokens: number
    social_media: number
    teaches_at: number
    user_roles: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | UsersCountOutputTypeCountAssistantsArgs
    auth_identities?: boolean | UsersCountOutputTypeCountAuth_identitiesArgs
    refresh_tokens?: boolean | UsersCountOutputTypeCountRefresh_tokensArgs
    social_media?: boolean | UsersCountOutputTypeCountSocial_mediaArgs
    teaches_at?: boolean | UsersCountOutputTypeCountTeaches_atArgs
    user_roles?: boolean | UsersCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assistantsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuth_identitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_identitiesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRefresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokensWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSocial_mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_mediaWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTeaches_atArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teaches_atWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type GovernmentCountOutputType
   */

  export type GovernmentCountOutputType = {
    parents: number
    students: number
    teachers: number
    zones: number
  }

  export type GovernmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | GovernmentCountOutputTypeCountParentsArgs
    students?: boolean | GovernmentCountOutputTypeCountStudentsArgs
    teachers?: boolean | GovernmentCountOutputTypeCountTeachersArgs
    zones?: boolean | GovernmentCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * GovernmentCountOutputType without action
   */
  export type GovernmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentCountOutputType
     */
    select?: GovernmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GovernmentCountOutputType without action
   */
  export type GovernmentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
  }

  /**
   * GovernmentCountOutputType without action
   */
  export type GovernmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }

  /**
   * GovernmentCountOutputType without action
   */
  export type GovernmentCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
  }

  /**
   * GovernmentCountOutputType without action
   */
  export type GovernmentCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zonesWhereInput
  }


  /**
   * Count Type LecturersCountOutputType
   */

  export type LecturersCountOutputType = {
    assistants: number
  }

  export type LecturersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | LecturersCountOutputTypeCountAssistantsArgs
  }

  // Custom InputTypes
  /**
   * LecturersCountOutputType without action
   */
  export type LecturersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LecturersCountOutputType
     */
    select?: LecturersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LecturersCountOutputType without action
   */
  export type LecturersCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assistantsWhereInput
  }


  /**
   * Count Type LevelsCountOutputType
   */

  export type LevelsCountOutputType = {
    students: number
  }

  export type LevelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | LevelsCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * LevelsCountOutputType without action
   */
  export type LevelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelsCountOutputType
     */
    select?: LevelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelsCountOutputType without action
   */
  export type LevelsCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }


  /**
   * Count Type ParentsCountOutputType
   */

  export type ParentsCountOutputType = {
    parent_children: number
  }

  export type ParentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent_children?: boolean | ParentsCountOutputTypeCountParent_childrenArgs
  }

  // Custom InputTypes
  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentsCountOutputType
     */
    select?: ParentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountParent_childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_childrenWhereInput
  }


  /**
   * Count Type SitesCountOutputType
   */

  export type SitesCountOutputType = {
    social_media: number
  }

  export type SitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social_media?: boolean | SitesCountOutputTypeCountSocial_mediaArgs
  }

  // Custom InputTypes
  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitesCountOutputType
     */
    select?: SitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SitesCountOutputType without action
   */
  export type SitesCountOutputTypeCountSocial_mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_mediaWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    parent_children: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent_children?: boolean | StudentsCountOutputTypeCountParent_childrenArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountParent_childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_childrenWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    teachers: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | SubjectsCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
  }


  /**
   * Count Type ZonesCountOutputType
   */

  export type ZonesCountOutputType = {
    parents: number
    students: number
    teachers: number
  }

  export type ZonesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | ZonesCountOutputTypeCountParentsArgs
    students?: boolean | ZonesCountOutputTypeCountStudentsArgs
    teachers?: boolean | ZonesCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZonesCountOutputType
     */
    select?: ZonesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
  }

  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }

  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model auth_identities
   */

  export type AggregateAuth_identities = {
    _count: Auth_identitiesCountAggregateOutputType | null
    _avg: Auth_identitiesAvgAggregateOutputType | null
    _sum: Auth_identitiesSumAggregateOutputType | null
    _min: Auth_identitiesMinAggregateOutputType | null
    _max: Auth_identitiesMaxAggregateOutputType | null
  }

  export type Auth_identitiesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Auth_identitiesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Auth_identitiesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider: $Enums.auth_provider_enum | null
    provider_user_id: string | null
    provider_email: string | null
  }

  export type Auth_identitiesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider: $Enums.auth_provider_enum | null
    provider_user_id: string | null
    provider_email: string | null
  }

  export type Auth_identitiesCountAggregateOutputType = {
    id: number
    user_id: number
    provider: number
    provider_user_id: number
    provider_email: number
    _all: number
  }


  export type Auth_identitiesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Auth_identitiesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Auth_identitiesMinAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_user_id?: true
    provider_email?: true
  }

  export type Auth_identitiesMaxAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_user_id?: true
    provider_email?: true
  }

  export type Auth_identitiesCountAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_user_id?: true
    provider_email?: true
    _all?: true
  }

  export type Auth_identitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_identities to aggregate.
     */
    where?: auth_identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_identities to fetch.
     */
    orderBy?: auth_identitiesOrderByWithRelationInput | auth_identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_identities
    **/
    _count?: true | Auth_identitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_identitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_identitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_identitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_identitiesMaxAggregateInputType
  }

  export type GetAuth_identitiesAggregateType<T extends Auth_identitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_identities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_identities[P]>
      : GetScalarType<T[P], AggregateAuth_identities[P]>
  }




  export type auth_identitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_identitiesWhereInput
    orderBy?: auth_identitiesOrderByWithAggregationInput | auth_identitiesOrderByWithAggregationInput[]
    by: Auth_identitiesScalarFieldEnum[] | Auth_identitiesScalarFieldEnum
    having?: auth_identitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_identitiesCountAggregateInputType | true
    _avg?: Auth_identitiesAvgAggregateInputType
    _sum?: Auth_identitiesSumAggregateInputType
    _min?: Auth_identitiesMinAggregateInputType
    _max?: Auth_identitiesMaxAggregateInputType
  }

  export type Auth_identitiesGroupByOutputType = {
    id: number
    user_id: number
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email: string | null
    _count: Auth_identitiesCountAggregateOutputType | null
    _avg: Auth_identitiesAvgAggregateOutputType | null
    _sum: Auth_identitiesSumAggregateOutputType | null
    _min: Auth_identitiesMinAggregateOutputType | null
    _max: Auth_identitiesMaxAggregateOutputType | null
  }

  type GetAuth_identitiesGroupByPayload<T extends auth_identitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_identitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_identitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_identitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_identitiesGroupByOutputType[P]>
        }
      >
    >


  export type auth_identitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_user_id?: boolean
    provider_email?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_identities"]>

  export type auth_identitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_user_id?: boolean
    provider_email?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_identities"]>

  export type auth_identitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_user_id?: boolean
    provider_email?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_identities"]>

  export type auth_identitiesSelectScalar = {
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_user_id?: boolean
    provider_email?: boolean
  }

  export type auth_identitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "provider" | "provider_user_id" | "provider_email", ExtArgs["result"]["auth_identities"]>
  export type auth_identitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auth_identitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auth_identitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $auth_identitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_identities"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      provider: $Enums.auth_provider_enum
      provider_user_id: string
      provider_email: string | null
    }, ExtArgs["result"]["auth_identities"]>
    composites: {}
  }

  type auth_identitiesGetPayload<S extends boolean | null | undefined | auth_identitiesDefaultArgs> = $Result.GetResult<Prisma.$auth_identitiesPayload, S>

  type auth_identitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_identitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_identitiesCountAggregateInputType | true
    }

  export interface auth_identitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_identities'], meta: { name: 'auth_identities' } }
    /**
     * Find zero or one Auth_identities that matches the filter.
     * @param {auth_identitiesFindUniqueArgs} args - Arguments to find a Auth_identities
     * @example
     * // Get one Auth_identities
     * const auth_identities = await prisma.auth_identities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_identitiesFindUniqueArgs>(args: SelectSubset<T, auth_identitiesFindUniqueArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_identities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_identitiesFindUniqueOrThrowArgs} args - Arguments to find a Auth_identities
     * @example
     * // Get one Auth_identities
     * const auth_identities = await prisma.auth_identities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_identitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_identitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesFindFirstArgs} args - Arguments to find a Auth_identities
     * @example
     * // Get one Auth_identities
     * const auth_identities = await prisma.auth_identities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_identitiesFindFirstArgs>(args?: SelectSubset<T, auth_identitiesFindFirstArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_identities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesFindFirstOrThrowArgs} args - Arguments to find a Auth_identities
     * @example
     * // Get one Auth_identities
     * const auth_identities = await prisma.auth_identities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_identitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_identitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_identities
     * const auth_identities = await prisma.auth_identities.findMany()
     * 
     * // Get first 10 Auth_identities
     * const auth_identities = await prisma.auth_identities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_identitiesWithIdOnly = await prisma.auth_identities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_identitiesFindManyArgs>(args?: SelectSubset<T, auth_identitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_identities.
     * @param {auth_identitiesCreateArgs} args - Arguments to create a Auth_identities.
     * @example
     * // Create one Auth_identities
     * const Auth_identities = await prisma.auth_identities.create({
     *   data: {
     *     // ... data to create a Auth_identities
     *   }
     * })
     * 
     */
    create<T extends auth_identitiesCreateArgs>(args: SelectSubset<T, auth_identitiesCreateArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_identities.
     * @param {auth_identitiesCreateManyArgs} args - Arguments to create many Auth_identities.
     * @example
     * // Create many Auth_identities
     * const auth_identities = await prisma.auth_identities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_identitiesCreateManyArgs>(args?: SelectSubset<T, auth_identitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_identities and returns the data saved in the database.
     * @param {auth_identitiesCreateManyAndReturnArgs} args - Arguments to create many Auth_identities.
     * @example
     * // Create many Auth_identities
     * const auth_identities = await prisma.auth_identities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_identities and only return the `id`
     * const auth_identitiesWithIdOnly = await prisma.auth_identities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_identitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_identitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_identities.
     * @param {auth_identitiesDeleteArgs} args - Arguments to delete one Auth_identities.
     * @example
     * // Delete one Auth_identities
     * const Auth_identities = await prisma.auth_identities.delete({
     *   where: {
     *     // ... filter to delete one Auth_identities
     *   }
     * })
     * 
     */
    delete<T extends auth_identitiesDeleteArgs>(args: SelectSubset<T, auth_identitiesDeleteArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_identities.
     * @param {auth_identitiesUpdateArgs} args - Arguments to update one Auth_identities.
     * @example
     * // Update one Auth_identities
     * const auth_identities = await prisma.auth_identities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_identitiesUpdateArgs>(args: SelectSubset<T, auth_identitiesUpdateArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_identities.
     * @param {auth_identitiesDeleteManyArgs} args - Arguments to filter Auth_identities to delete.
     * @example
     * // Delete a few Auth_identities
     * const { count } = await prisma.auth_identities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_identitiesDeleteManyArgs>(args?: SelectSubset<T, auth_identitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_identities
     * const auth_identities = await prisma.auth_identities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_identitiesUpdateManyArgs>(args: SelectSubset<T, auth_identitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_identities and returns the data updated in the database.
     * @param {auth_identitiesUpdateManyAndReturnArgs} args - Arguments to update many Auth_identities.
     * @example
     * // Update many Auth_identities
     * const auth_identities = await prisma.auth_identities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_identities and only return the `id`
     * const auth_identitiesWithIdOnly = await prisma.auth_identities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_identitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_identitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_identities.
     * @param {auth_identitiesUpsertArgs} args - Arguments to update or create a Auth_identities.
     * @example
     * // Update or create a Auth_identities
     * const auth_identities = await prisma.auth_identities.upsert({
     *   create: {
     *     // ... data to create a Auth_identities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_identities we want to update
     *   }
     * })
     */
    upsert<T extends auth_identitiesUpsertArgs>(args: SelectSubset<T, auth_identitiesUpsertArgs<ExtArgs>>): Prisma__auth_identitiesClient<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesCountArgs} args - Arguments to filter Auth_identities to count.
     * @example
     * // Count the number of Auth_identities
     * const count = await prisma.auth_identities.count({
     *   where: {
     *     // ... the filter for the Auth_identities we want to count
     *   }
     * })
    **/
    count<T extends auth_identitiesCountArgs>(
      args?: Subset<T, auth_identitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_identitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_identitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_identitiesAggregateArgs>(args: Subset<T, Auth_identitiesAggregateArgs>): Prisma.PrismaPromise<GetAuth_identitiesAggregateType<T>>

    /**
     * Group by Auth_identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_identitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_identitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_identitiesGroupByArgs['orderBy'] }
        : { orderBy?: auth_identitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_identitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_identitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_identities model
   */
  readonly fields: auth_identitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_identities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_identitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_identities model
   */
  interface auth_identitiesFieldRefs {
    readonly id: FieldRef<"auth_identities", 'Int'>
    readonly user_id: FieldRef<"auth_identities", 'Int'>
    readonly provider: FieldRef<"auth_identities", 'auth_provider_enum'>
    readonly provider_user_id: FieldRef<"auth_identities", 'String'>
    readonly provider_email: FieldRef<"auth_identities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth_identities findUnique
   */
  export type auth_identitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter, which auth_identities to fetch.
     */
    where: auth_identitiesWhereUniqueInput
  }

  /**
   * auth_identities findUniqueOrThrow
   */
  export type auth_identitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter, which auth_identities to fetch.
     */
    where: auth_identitiesWhereUniqueInput
  }

  /**
   * auth_identities findFirst
   */
  export type auth_identitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter, which auth_identities to fetch.
     */
    where?: auth_identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_identities to fetch.
     */
    orderBy?: auth_identitiesOrderByWithRelationInput | auth_identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_identities.
     */
    cursor?: auth_identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_identities.
     */
    distinct?: Auth_identitiesScalarFieldEnum | Auth_identitiesScalarFieldEnum[]
  }

  /**
   * auth_identities findFirstOrThrow
   */
  export type auth_identitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter, which auth_identities to fetch.
     */
    where?: auth_identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_identities to fetch.
     */
    orderBy?: auth_identitiesOrderByWithRelationInput | auth_identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_identities.
     */
    cursor?: auth_identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_identities.
     */
    distinct?: Auth_identitiesScalarFieldEnum | Auth_identitiesScalarFieldEnum[]
  }

  /**
   * auth_identities findMany
   */
  export type auth_identitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter, which auth_identities to fetch.
     */
    where?: auth_identitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_identities to fetch.
     */
    orderBy?: auth_identitiesOrderByWithRelationInput | auth_identitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_identities.
     */
    cursor?: auth_identitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_identities.
     */
    skip?: number
    distinct?: Auth_identitiesScalarFieldEnum | Auth_identitiesScalarFieldEnum[]
  }

  /**
   * auth_identities create
   */
  export type auth_identitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_identities.
     */
    data: XOR<auth_identitiesCreateInput, auth_identitiesUncheckedCreateInput>
  }

  /**
   * auth_identities createMany
   */
  export type auth_identitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_identities.
     */
    data: auth_identitiesCreateManyInput | auth_identitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_identities createManyAndReturn
   */
  export type auth_identitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * The data used to create many auth_identities.
     */
    data: auth_identitiesCreateManyInput | auth_identitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_identities update
   */
  export type auth_identitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_identities.
     */
    data: XOR<auth_identitiesUpdateInput, auth_identitiesUncheckedUpdateInput>
    /**
     * Choose, which auth_identities to update.
     */
    where: auth_identitiesWhereUniqueInput
  }

  /**
   * auth_identities updateMany
   */
  export type auth_identitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_identities.
     */
    data: XOR<auth_identitiesUpdateManyMutationInput, auth_identitiesUncheckedUpdateManyInput>
    /**
     * Filter which auth_identities to update
     */
    where?: auth_identitiesWhereInput
    /**
     * Limit how many auth_identities to update.
     */
    limit?: number
  }

  /**
   * auth_identities updateManyAndReturn
   */
  export type auth_identitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * The data used to update auth_identities.
     */
    data: XOR<auth_identitiesUpdateManyMutationInput, auth_identitiesUncheckedUpdateManyInput>
    /**
     * Filter which auth_identities to update
     */
    where?: auth_identitiesWhereInput
    /**
     * Limit how many auth_identities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_identities upsert
   */
  export type auth_identitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_identities to update in case it exists.
     */
    where: auth_identitiesWhereUniqueInput
    /**
     * In case the auth_identities found by the `where` argument doesn't exist, create a new auth_identities with this data.
     */
    create: XOR<auth_identitiesCreateInput, auth_identitiesUncheckedCreateInput>
    /**
     * In case the auth_identities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_identitiesUpdateInput, auth_identitiesUncheckedUpdateInput>
  }

  /**
   * auth_identities delete
   */
  export type auth_identitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    /**
     * Filter which auth_identities to delete.
     */
    where: auth_identitiesWhereUniqueInput
  }

  /**
   * auth_identities deleteMany
   */
  export type auth_identitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_identities to delete
     */
    where?: auth_identitiesWhereInput
    /**
     * Limit how many auth_identities to delete.
     */
    limit?: number
  }

  /**
   * auth_identities without action
   */
  export type auth_identitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
  }


  /**
   * Model user_analytics
   */

  export type AggregateUser_analytics = {
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  export type User_analyticsAvgAggregateOutputType = {
    user_id: number | null
    views: number | null
    total_spent: Decimal | null
    number_of_purchases: number | null
    successful_invites: number | null
    monthly_confirmed_count: number | null
  }

  export type User_analyticsSumAggregateOutputType = {
    user_id: number | null
    views: number | null
    total_spent: Decimal | null
    number_of_purchases: number | null
    successful_invites: number | null
    monthly_confirmed_count: number | null
  }

  export type User_analyticsMinAggregateOutputType = {
    user_id: number | null
    views: number | null
    total_spent: Decimal | null
    number_of_purchases: number | null
    successful_invites: number | null
    monthly_confirmed_count: number | null
    last_confirmed_count_update: Date | null
  }

  export type User_analyticsMaxAggregateOutputType = {
    user_id: number | null
    views: number | null
    total_spent: Decimal | null
    number_of_purchases: number | null
    successful_invites: number | null
    monthly_confirmed_count: number | null
    last_confirmed_count_update: Date | null
  }

  export type User_analyticsCountAggregateOutputType = {
    user_id: number
    views: number
    total_spent: number
    number_of_purchases: number
    successful_invites: number
    monthly_confirmed_count: number
    last_confirmed_count_update: number
    _all: number
  }


  export type User_analyticsAvgAggregateInputType = {
    user_id?: true
    views?: true
    total_spent?: true
    number_of_purchases?: true
    successful_invites?: true
    monthly_confirmed_count?: true
  }

  export type User_analyticsSumAggregateInputType = {
    user_id?: true
    views?: true
    total_spent?: true
    number_of_purchases?: true
    successful_invites?: true
    monthly_confirmed_count?: true
  }

  export type User_analyticsMinAggregateInputType = {
    user_id?: true
    views?: true
    total_spent?: true
    number_of_purchases?: true
    successful_invites?: true
    monthly_confirmed_count?: true
    last_confirmed_count_update?: true
  }

  export type User_analyticsMaxAggregateInputType = {
    user_id?: true
    views?: true
    total_spent?: true
    number_of_purchases?: true
    successful_invites?: true
    monthly_confirmed_count?: true
    last_confirmed_count_update?: true
  }

  export type User_analyticsCountAggregateInputType = {
    user_id?: true
    views?: true
    total_spent?: true
    number_of_purchases?: true
    successful_invites?: true
    monthly_confirmed_count?: true
    last_confirmed_count_update?: true
    _all?: true
  }

  export type User_analyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to aggregate.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_analytics
    **/
    _count?: true | User_analyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_analyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_analyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_analyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_analyticsMaxAggregateInputType
  }

  export type GetUser_analyticsAggregateType<T extends User_analyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_analytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_analytics[P]>
      : GetScalarType<T[P], AggregateUser_analytics[P]>
  }




  export type user_analyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_analyticsWhereInput
    orderBy?: user_analyticsOrderByWithAggregationInput | user_analyticsOrderByWithAggregationInput[]
    by: User_analyticsScalarFieldEnum[] | User_analyticsScalarFieldEnum
    having?: user_analyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_analyticsCountAggregateInputType | true
    _avg?: User_analyticsAvgAggregateInputType
    _sum?: User_analyticsSumAggregateInputType
    _min?: User_analyticsMinAggregateInputType
    _max?: User_analyticsMaxAggregateInputType
  }

  export type User_analyticsGroupByOutputType = {
    user_id: number
    views: number | null
    total_spent: Decimal | null
    number_of_purchases: number | null
    successful_invites: number | null
    monthly_confirmed_count: number | null
    last_confirmed_count_update: Date | null
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  type GetUser_analyticsGroupByPayload<T extends user_analyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_analyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_analyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
            : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
        }
      >
    >


  export type user_analyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    views?: boolean
    total_spent?: boolean
    number_of_purchases?: boolean
    successful_invites?: boolean
    monthly_confirmed_count?: boolean
    last_confirmed_count_update?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    views?: boolean
    total_spent?: boolean
    number_of_purchases?: boolean
    successful_invites?: boolean
    monthly_confirmed_count?: boolean
    last_confirmed_count_update?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    views?: boolean
    total_spent?: boolean
    number_of_purchases?: boolean
    successful_invites?: boolean
    monthly_confirmed_count?: boolean
    last_confirmed_count_update?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectScalar = {
    user_id?: boolean
    views?: boolean
    total_spent?: boolean
    number_of_purchases?: boolean
    successful_invites?: boolean
    monthly_confirmed_count?: boolean
    last_confirmed_count_update?: boolean
  }

  export type user_analyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "views" | "total_spent" | "number_of_purchases" | "successful_invites" | "monthly_confirmed_count" | "last_confirmed_count_update", ExtArgs["result"]["user_analytics"]>
  export type user_analyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_analyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_analyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_analyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_analytics"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      views: number | null
      total_spent: Prisma.Decimal | null
      number_of_purchases: number | null
      successful_invites: number | null
      monthly_confirmed_count: number | null
      last_confirmed_count_update: Date | null
    }, ExtArgs["result"]["user_analytics"]>
    composites: {}
  }

  type user_analyticsGetPayload<S extends boolean | null | undefined | user_analyticsDefaultArgs> = $Result.GetResult<Prisma.$user_analyticsPayload, S>

  type user_analyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_analyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_analyticsCountAggregateInputType | true
    }

  export interface user_analyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_analytics'], meta: { name: 'user_analytics' } }
    /**
     * Find zero or one User_analytics that matches the filter.
     * @param {user_analyticsFindUniqueArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_analyticsFindUniqueArgs>(args: SelectSubset<T, user_analyticsFindUniqueArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_analyticsFindUniqueOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_analyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_analyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_analyticsFindFirstArgs>(args?: SelectSubset<T, user_analyticsFindFirstArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_analyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_analyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_analytics
     * const user_analytics = await prisma.user_analytics.findMany()
     * 
     * // Get first 10 User_analytics
     * const user_analytics = await prisma.user_analytics.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_analyticsWithUser_idOnly = await prisma.user_analytics.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_analyticsFindManyArgs>(args?: SelectSubset<T, user_analyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_analytics.
     * @param {user_analyticsCreateArgs} args - Arguments to create a User_analytics.
     * @example
     * // Create one User_analytics
     * const User_analytics = await prisma.user_analytics.create({
     *   data: {
     *     // ... data to create a User_analytics
     *   }
     * })
     * 
     */
    create<T extends user_analyticsCreateArgs>(args: SelectSubset<T, user_analyticsCreateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_analytics.
     * @param {user_analyticsCreateManyArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_analyticsCreateManyArgs>(args?: SelectSubset<T, user_analyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_analytics and returns the data saved in the database.
     * @param {user_analyticsCreateManyAndReturnArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_analytics and only return the `user_id`
     * const user_analyticsWithUser_idOnly = await prisma.user_analytics.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_analyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_analyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_analytics.
     * @param {user_analyticsDeleteArgs} args - Arguments to delete one User_analytics.
     * @example
     * // Delete one User_analytics
     * const User_analytics = await prisma.user_analytics.delete({
     *   where: {
     *     // ... filter to delete one User_analytics
     *   }
     * })
     * 
     */
    delete<T extends user_analyticsDeleteArgs>(args: SelectSubset<T, user_analyticsDeleteArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_analytics.
     * @param {user_analyticsUpdateArgs} args - Arguments to update one User_analytics.
     * @example
     * // Update one User_analytics
     * const user_analytics = await prisma.user_analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_analyticsUpdateArgs>(args: SelectSubset<T, user_analyticsUpdateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_analytics.
     * @param {user_analyticsDeleteManyArgs} args - Arguments to filter User_analytics to delete.
     * @example
     * // Delete a few User_analytics
     * const { count } = await prisma.user_analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_analyticsDeleteManyArgs>(args?: SelectSubset<T, user_analyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_analytics
     * const user_analytics = await prisma.user_analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_analyticsUpdateManyArgs>(args: SelectSubset<T, user_analyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_analytics and returns the data updated in the database.
     * @param {user_analyticsUpdateManyAndReturnArgs} args - Arguments to update many User_analytics.
     * @example
     * // Update many User_analytics
     * const user_analytics = await prisma.user_analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_analytics and only return the `user_id`
     * const user_analyticsWithUser_idOnly = await prisma.user_analytics.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_analyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_analyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_analytics.
     * @param {user_analyticsUpsertArgs} args - Arguments to update or create a User_analytics.
     * @example
     * // Update or create a User_analytics
     * const user_analytics = await prisma.user_analytics.upsert({
     *   create: {
     *     // ... data to create a User_analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_analytics we want to update
     *   }
     * })
     */
    upsert<T extends user_analyticsUpsertArgs>(args: SelectSubset<T, user_analyticsUpsertArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsCountArgs} args - Arguments to filter User_analytics to count.
     * @example
     * // Count the number of User_analytics
     * const count = await prisma.user_analytics.count({
     *   where: {
     *     // ... the filter for the User_analytics we want to count
     *   }
     * })
    **/
    count<T extends user_analyticsCountArgs>(
      args?: Subset<T, user_analyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_analyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_analyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_analyticsAggregateArgs>(args: Subset<T, User_analyticsAggregateArgs>): Prisma.PrismaPromise<GetUser_analyticsAggregateType<T>>

    /**
     * Group by User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_analyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_analyticsGroupByArgs['orderBy'] }
        : { orderBy?: user_analyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_analyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_analyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_analytics model
   */
  readonly fields: user_analyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_analyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_analytics model
   */
  interface user_analyticsFieldRefs {
    readonly user_id: FieldRef<"user_analytics", 'Int'>
    readonly views: FieldRef<"user_analytics", 'Int'>
    readonly total_spent: FieldRef<"user_analytics", 'Decimal'>
    readonly number_of_purchases: FieldRef<"user_analytics", 'Int'>
    readonly successful_invites: FieldRef<"user_analytics", 'Int'>
    readonly monthly_confirmed_count: FieldRef<"user_analytics", 'Int'>
    readonly last_confirmed_count_update: FieldRef<"user_analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_analytics findUnique
   */
  export type user_analyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findUniqueOrThrow
   */
  export type user_analyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findFirst
   */
  export type user_analyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findFirstOrThrow
   */
  export type user_analyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findMany
   */
  export type user_analyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics create
   */
  export type user_analyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_analytics.
     */
    data: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
  }

  /**
   * user_analytics createMany
   */
  export type user_analyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_analytics createManyAndReturn
   */
  export type user_analyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_analytics update
   */
  export type user_analyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_analytics.
     */
    data: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
    /**
     * Choose, which user_analytics to update.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics updateMany
   */
  export type user_analyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_analytics.
     */
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyInput>
    /**
     * Filter which user_analytics to update
     */
    where?: user_analyticsWhereInput
    /**
     * Limit how many user_analytics to update.
     */
    limit?: number
  }

  /**
   * user_analytics updateManyAndReturn
   */
  export type user_analyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * The data used to update user_analytics.
     */
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyInput>
    /**
     * Filter which user_analytics to update
     */
    where?: user_analyticsWhereInput
    /**
     * Limit how many user_analytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_analytics upsert
   */
  export type user_analyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_analytics to update in case it exists.
     */
    where: user_analyticsWhereUniqueInput
    /**
     * In case the user_analytics found by the `where` argument doesn't exist, create a new user_analytics with this data.
     */
    create: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
    /**
     * In case the user_analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
  }

  /**
   * user_analytics delete
   */
  export type user_analyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter which user_analytics to delete.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics deleteMany
   */
  export type user_analyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to delete
     */
    where?: user_analyticsWhereInput
    /**
     * Limit how many user_analytics to delete.
     */
    limit?: number
  }

  /**
   * user_analytics without action
   */
  export type user_analyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_rolesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_rolesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    portal: $Enums.portal_enum | null
    role: $Enums.role_enum | null
  }

  export type User_rolesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    portal: $Enums.portal_enum | null
    role: $Enums.role_enum | null
  }

  export type User_rolesCountAggregateOutputType = {
    id: number
    user_id: number
    portal: number
    role: number
    _all: number
  }


  export type User_rolesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_rolesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_rolesMinAggregateInputType = {
    id?: true
    user_id?: true
    portal?: true
    role?: true
  }

  export type User_rolesMaxAggregateInputType = {
    id?: true
    user_id?: true
    portal?: true
    role?: true
  }

  export type User_rolesCountAggregateInputType = {
    id?: true
    user_id?: true
    portal?: true
    role?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _avg?: User_rolesAvgAggregateInputType
    _sum?: User_rolesSumAggregateInputType
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    id: number
    user_id: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    portal?: boolean
    role?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    portal?: boolean
    role?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    portal?: boolean
    role?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectScalar = {
    id?: boolean
    user_id?: boolean
    portal?: boolean
    role?: boolean
  }

  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "portal" | "role", ExtArgs["result"]["user_roles"]>
  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      portal: $Enums.portal_enum
      role: $Enums.role_enum
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles and returns the data updated in the database.
     * @param {user_rolesUpdateManyAndReturnArgs} args - Arguments to update many User_roles.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */
  interface user_rolesFieldRefs {
    readonly id: FieldRef<"user_roles", 'Int'>
    readonly user_id: FieldRef<"user_roles", 'Int'>
    readonly portal: FieldRef<"user_roles", 'portal_enum'>
    readonly role: FieldRef<"user_roles", 'role_enum'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles createManyAndReturn
   */
  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_roles updateManyAndReturn
   */
  export type user_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    mongo_id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    gender: $Enums.gender_enum | null
    is_email_verified: boolean | null
    email_verified_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    secondary_phone: string | null
    role: $Enums.role_enum | null
    profile_pic_url: string | null
    password_changed_at: Date | null
    confirmed: boolean | null
    hasPromoCode: boolean | null
    hasUsedPromoCode: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    mongo_id: string | null
    name: string | null
    email: string | null
    password: string | null
    phone: string | null
    gender: $Enums.gender_enum | null
    is_email_verified: boolean | null
    email_verified_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    secondary_phone: string | null
    role: $Enums.role_enum | null
    profile_pic_url: string | null
    password_changed_at: Date | null
    confirmed: boolean | null
    hasPromoCode: boolean | null
    hasUsedPromoCode: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    mongo_id: number
    name: number
    email: number
    password: number
    phone: number
    gender: number
    is_email_verified: number
    email_verified_at: number
    created_at: number
    updated_at: number
    secondary_phone: number
    role: number
    profile_pic_url: number
    password_changed_at: number
    confirmed: number
    hasPromoCode: number
    hasUsedPromoCode: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    mongo_id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    gender?: true
    is_email_verified?: true
    email_verified_at?: true
    created_at?: true
    updated_at?: true
    secondary_phone?: true
    role?: true
    profile_pic_url?: true
    password_changed_at?: true
    confirmed?: true
    hasPromoCode?: true
    hasUsedPromoCode?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    mongo_id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    gender?: true
    is_email_verified?: true
    email_verified_at?: true
    created_at?: true
    updated_at?: true
    secondary_phone?: true
    role?: true
    profile_pic_url?: true
    password_changed_at?: true
    confirmed?: true
    hasPromoCode?: true
    hasUsedPromoCode?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    mongo_id?: true
    name?: true
    email?: true
    password?: true
    phone?: true
    gender?: true
    is_email_verified?: true
    email_verified_at?: true
    created_at?: true
    updated_at?: true
    secondary_phone?: true
    role?: true
    profile_pic_url?: true
    password_changed_at?: true
    confirmed?: true
    hasPromoCode?: true
    hasUsedPromoCode?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    mongo_id: string | null
    name: string
    email: string | null
    password: string | null
    phone: string | null
    gender: $Enums.gender_enum | null
    is_email_verified: boolean | null
    email_verified_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    secondary_phone: string | null
    role: $Enums.role_enum | null
    profile_pic_url: string | null
    password_changed_at: Date | null
    confirmed: boolean | null
    hasPromoCode: boolean | null
    hasUsedPromoCode: boolean | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mongo_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    gender?: boolean
    is_email_verified?: boolean
    email_verified_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    secondary_phone?: boolean
    role?: boolean
    profile_pic_url?: boolean
    password_changed_at?: boolean
    confirmed?: boolean
    hasPromoCode?: boolean
    hasUsedPromoCode?: boolean
    assistants?: boolean | users$assistantsArgs<ExtArgs>
    auth_identities?: boolean | users$auth_identitiesArgs<ExtArgs>
    email_verification_tokens?: boolean | users$email_verification_tokensArgs<ExtArgs>
    lecturers?: boolean | users$lecturersArgs<ExtArgs>
    parents?: boolean | users$parentsArgs<ExtArgs>
    password_reset_tokens?: boolean | users$password_reset_tokensArgs<ExtArgs>
    refresh_tokens?: boolean | users$refresh_tokensArgs<ExtArgs>
    social_media?: boolean | users$social_mediaArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    teachers?: boolean | users$teachersArgs<ExtArgs>
    teaches_at?: boolean | users$teaches_atArgs<ExtArgs>
    user_analytics?: boolean | users$user_analyticsArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mongo_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    gender?: boolean
    is_email_verified?: boolean
    email_verified_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    secondary_phone?: boolean
    role?: boolean
    profile_pic_url?: boolean
    password_changed_at?: boolean
    confirmed?: boolean
    hasPromoCode?: boolean
    hasUsedPromoCode?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mongo_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    gender?: boolean
    is_email_verified?: boolean
    email_verified_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    secondary_phone?: boolean
    role?: boolean
    profile_pic_url?: boolean
    password_changed_at?: boolean
    confirmed?: boolean
    hasPromoCode?: boolean
    hasUsedPromoCode?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    mongo_id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    gender?: boolean
    is_email_verified?: boolean
    email_verified_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    secondary_phone?: boolean
    role?: boolean
    profile_pic_url?: boolean
    password_changed_at?: boolean
    confirmed?: boolean
    hasPromoCode?: boolean
    hasUsedPromoCode?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mongo_id" | "name" | "email" | "password" | "phone" | "gender" | "is_email_verified" | "email_verified_at" | "created_at" | "updated_at" | "secondary_phone" | "role" | "profile_pic_url" | "password_changed_at" | "confirmed" | "hasPromoCode" | "hasUsedPromoCode", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | users$assistantsArgs<ExtArgs>
    auth_identities?: boolean | users$auth_identitiesArgs<ExtArgs>
    email_verification_tokens?: boolean | users$email_verification_tokensArgs<ExtArgs>
    lecturers?: boolean | users$lecturersArgs<ExtArgs>
    parents?: boolean | users$parentsArgs<ExtArgs>
    password_reset_tokens?: boolean | users$password_reset_tokensArgs<ExtArgs>
    refresh_tokens?: boolean | users$refresh_tokensArgs<ExtArgs>
    social_media?: boolean | users$social_mediaArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    teachers?: boolean | users$teachersArgs<ExtArgs>
    teaches_at?: boolean | users$teaches_atArgs<ExtArgs>
    user_analytics?: boolean | users$user_analyticsArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      assistants: Prisma.$assistantsPayload<ExtArgs>[]
      auth_identities: Prisma.$auth_identitiesPayload<ExtArgs>[]
      email_verification_tokens: Prisma.$email_verification_tokensPayload<ExtArgs> | null
      lecturers: Prisma.$lecturersPayload<ExtArgs> | null
      parents: Prisma.$parentsPayload<ExtArgs> | null
      password_reset_tokens: Prisma.$password_reset_tokensPayload<ExtArgs> | null
      refresh_tokens: Prisma.$refresh_tokensPayload<ExtArgs>[]
      social_media: Prisma.$social_mediaPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs> | null
      teachers: Prisma.$teachersPayload<ExtArgs> | null
      teaches_at: Prisma.$teaches_atPayload<ExtArgs>[]
      user_analytics: Prisma.$user_analyticsPayload<ExtArgs> | null
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mongo_id: string | null
      name: string
      email: string | null
      password: string | null
      phone: string | null
      gender: $Enums.gender_enum | null
      is_email_verified: boolean | null
      email_verified_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      secondary_phone: string | null
      role: $Enums.role_enum | null
      profile_pic_url: string | null
      password_changed_at: Date | null
      confirmed: boolean | null
      hasPromoCode: boolean | null
      hasUsedPromoCode: boolean | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assistants<T extends users$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, users$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_identities<T extends users$auth_identitiesArgs<ExtArgs> = {}>(args?: Subset<T, users$auth_identitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_identitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    email_verification_tokens<T extends users$email_verification_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$email_verification_tokensArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lecturers<T extends users$lecturersArgs<ExtArgs> = {}>(args?: Subset<T, users$lecturersArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parents<T extends users$parentsArgs<ExtArgs> = {}>(args?: Subset<T, users$parentsArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    password_reset_tokens<T extends users$password_reset_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$password_reset_tokensArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refresh_tokens<T extends users$refresh_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$refresh_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    social_media<T extends users$social_mediaArgs<ExtArgs> = {}>(args?: Subset<T, users$social_mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends users$studentsArgs<ExtArgs> = {}>(args?: Subset<T, users$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teachers<T extends users$teachersArgs<ExtArgs> = {}>(args?: Subset<T, users$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teaches_at<T extends users$teaches_atArgs<ExtArgs> = {}>(args?: Subset<T, users$teaches_atArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_analytics<T extends users$user_analyticsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_analyticsArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_roles<T extends users$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly mongo_id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly gender: FieldRef<"users", 'gender_enum'>
    readonly is_email_verified: FieldRef<"users", 'Boolean'>
    readonly email_verified_at: FieldRef<"users", 'DateTime'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly secondary_phone: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'role_enum'>
    readonly profile_pic_url: FieldRef<"users", 'String'>
    readonly password_changed_at: FieldRef<"users", 'DateTime'>
    readonly confirmed: FieldRef<"users", 'Boolean'>
    readonly hasPromoCode: FieldRef<"users", 'Boolean'>
    readonly hasUsedPromoCode: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.assistants
   */
  export type users$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    where?: assistantsWhereInput
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    cursor?: assistantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssistantsScalarFieldEnum | AssistantsScalarFieldEnum[]
  }

  /**
   * users.auth_identities
   */
  export type users$auth_identitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_identities
     */
    select?: auth_identitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_identities
     */
    omit?: auth_identitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_identitiesInclude<ExtArgs> | null
    where?: auth_identitiesWhereInput
    orderBy?: auth_identitiesOrderByWithRelationInput | auth_identitiesOrderByWithRelationInput[]
    cursor?: auth_identitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_identitiesScalarFieldEnum | Auth_identitiesScalarFieldEnum[]
  }

  /**
   * users.email_verification_tokens
   */
  export type users$email_verification_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    where?: email_verification_tokensWhereInput
  }

  /**
   * users.lecturers
   */
  export type users$lecturersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    where?: lecturersWhereInput
  }

  /**
   * users.parents
   */
  export type users$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    where?: parentsWhereInput
  }

  /**
   * users.password_reset_tokens
   */
  export type users$password_reset_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    where?: password_reset_tokensWhereInput
  }

  /**
   * users.refresh_tokens
   */
  export type users$refresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    where?: refresh_tokensWhereInput
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    cursor?: refresh_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * users.social_media
   */
  export type users$social_mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    where?: social_mediaWhereInput
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    cursor?: social_mediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Social_mediaScalarFieldEnum | Social_mediaScalarFieldEnum[]
  }

  /**
   * users.students
   */
  export type users$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * users.teachers
   */
  export type users$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * users.teaches_at
   */
  export type users$teaches_atArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    where?: teaches_atWhereInput
    orderBy?: teaches_atOrderByWithRelationInput | teaches_atOrderByWithRelationInput[]
    cursor?: teaches_atWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teaches_atScalarFieldEnum | Teaches_atScalarFieldEnum[]
  }

  /**
   * users.user_analytics
   */
  export type users$user_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_analytics
     */
    omit?: user_analyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    where?: user_analyticsWhereInput
  }

  /**
   * users.user_roles
   */
  export type users$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model refresh_tokens
   */

  export type AggregateRefresh_tokens = {
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  export type Refresh_tokensAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Refresh_tokensSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Refresh_tokensMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    revoked: boolean | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Refresh_tokensMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    revoked: boolean | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Refresh_tokensCountAggregateOutputType = {
    id: number
    user_id: number
    token_hash: number
    revoked: number
    created_at: number
    expires_at: number
    _all: number
  }


  export type Refresh_tokensAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Refresh_tokensSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Refresh_tokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    revoked?: true
    created_at?: true
    expires_at?: true
  }

  export type Refresh_tokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    revoked?: true
    created_at?: true
    expires_at?: true
  }

  export type Refresh_tokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    revoked?: true
    created_at?: true
    expires_at?: true
    _all?: true
  }

  export type Refresh_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to aggregate.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refresh_tokens
    **/
    _count?: true | Refresh_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Refresh_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Refresh_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Refresh_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type GetRefresh_tokensAggregateType<T extends Refresh_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateRefresh_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefresh_tokens[P]>
      : GetScalarType<T[P], AggregateRefresh_tokens[P]>
  }




  export type refresh_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokensWhereInput
    orderBy?: refresh_tokensOrderByWithAggregationInput | refresh_tokensOrderByWithAggregationInput[]
    by: Refresh_tokensScalarFieldEnum[] | Refresh_tokensScalarFieldEnum
    having?: refresh_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Refresh_tokensCountAggregateInputType | true
    _avg?: Refresh_tokensAvgAggregateInputType
    _sum?: Refresh_tokensSumAggregateInputType
    _min?: Refresh_tokensMinAggregateInputType
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type Refresh_tokensGroupByOutputType = {
    id: number
    user_id: number
    token_hash: string
    revoked: boolean | null
    created_at: Date | null
    expires_at: Date
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  type GetRefresh_tokensGroupByPayload<T extends refresh_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Refresh_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Refresh_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
        }
      >
    >


  export type refresh_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    revoked?: boolean
    created_at?: boolean
    expires_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    revoked?: boolean
    created_at?: boolean
    expires_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    revoked?: boolean
    created_at?: boolean
    expires_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    revoked?: boolean
    created_at?: boolean
    expires_at?: boolean
  }

  export type refresh_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token_hash" | "revoked" | "created_at" | "expires_at", ExtArgs["result"]["refresh_tokens"]>
  export type refresh_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type refresh_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type refresh_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $refresh_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refresh_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token_hash: string
      revoked: boolean | null
      created_at: Date | null
      expires_at: Date
    }, ExtArgs["result"]["refresh_tokens"]>
    composites: {}
  }

  type refresh_tokensGetPayload<S extends boolean | null | undefined | refresh_tokensDefaultArgs> = $Result.GetResult<Prisma.$refresh_tokensPayload, S>

  type refresh_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<refresh_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Refresh_tokensCountAggregateInputType | true
    }

  export interface refresh_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refresh_tokens'], meta: { name: 'refresh_tokens' } }
    /**
     * Find zero or one Refresh_tokens that matches the filter.
     * @param {refresh_tokensFindUniqueArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refresh_tokensFindUniqueArgs>(args: SelectSubset<T, refresh_tokensFindUniqueArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refresh_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {refresh_tokensFindUniqueOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refresh_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, refresh_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refresh_tokensFindFirstArgs>(args?: SelectSubset<T, refresh_tokensFindFirstArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refresh_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refresh_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, refresh_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany()
     * 
     * // Get first 10 Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refresh_tokensWithIdOnly = await prisma.refresh_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refresh_tokensFindManyArgs>(args?: SelectSubset<T, refresh_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refresh_tokens.
     * @param {refresh_tokensCreateArgs} args - Arguments to create a Refresh_tokens.
     * @example
     * // Create one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.create({
     *   data: {
     *     // ... data to create a Refresh_tokens
     *   }
     * })
     * 
     */
    create<T extends refresh_tokensCreateArgs>(args: SelectSubset<T, refresh_tokensCreateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refresh_tokens.
     * @param {refresh_tokensCreateManyArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refresh_tokensCreateManyArgs>(args?: SelectSubset<T, refresh_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refresh_tokens and returns the data saved in the database.
     * @param {refresh_tokensCreateManyAndReturnArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refresh_tokens and only return the `id`
     * const refresh_tokensWithIdOnly = await prisma.refresh_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends refresh_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, refresh_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refresh_tokens.
     * @param {refresh_tokensDeleteArgs} args - Arguments to delete one Refresh_tokens.
     * @example
     * // Delete one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.delete({
     *   where: {
     *     // ... filter to delete one Refresh_tokens
     *   }
     * })
     * 
     */
    delete<T extends refresh_tokensDeleteArgs>(args: SelectSubset<T, refresh_tokensDeleteArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refresh_tokens.
     * @param {refresh_tokensUpdateArgs} args - Arguments to update one Refresh_tokens.
     * @example
     * // Update one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refresh_tokensUpdateArgs>(args: SelectSubset<T, refresh_tokensUpdateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refresh_tokens.
     * @param {refresh_tokensDeleteManyArgs} args - Arguments to filter Refresh_tokens to delete.
     * @example
     * // Delete a few Refresh_tokens
     * const { count } = await prisma.refresh_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refresh_tokensDeleteManyArgs>(args?: SelectSubset<T, refresh_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refresh_tokensUpdateManyArgs>(args: SelectSubset<T, refresh_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens and returns the data updated in the database.
     * @param {refresh_tokensUpdateManyAndReturnArgs} args - Arguments to update many Refresh_tokens.
     * @example
     * // Update many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refresh_tokens and only return the `id`
     * const refresh_tokensWithIdOnly = await prisma.refresh_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends refresh_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, refresh_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refresh_tokens.
     * @param {refresh_tokensUpsertArgs} args - Arguments to update or create a Refresh_tokens.
     * @example
     * // Update or create a Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.upsert({
     *   create: {
     *     // ... data to create a Refresh_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to update
     *   }
     * })
     */
    upsert<T extends refresh_tokensUpsertArgs>(args: SelectSubset<T, refresh_tokensUpsertArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensCountArgs} args - Arguments to filter Refresh_tokens to count.
     * @example
     * // Count the number of Refresh_tokens
     * const count = await prisma.refresh_tokens.count({
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to count
     *   }
     * })
    **/
    count<T extends refresh_tokensCountArgs>(
      args?: Subset<T, refresh_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Refresh_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Refresh_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Refresh_tokensAggregateArgs>(args: Subset<T, Refresh_tokensAggregateArgs>): Prisma.PrismaPromise<GetRefresh_tokensAggregateType<T>>

    /**
     * Group by Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refresh_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refresh_tokensGroupByArgs['orderBy'] }
        : { orderBy?: refresh_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refresh_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefresh_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refresh_tokens model
   */
  readonly fields: refresh_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refresh_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refresh_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refresh_tokens model
   */
  interface refresh_tokensFieldRefs {
    readonly id: FieldRef<"refresh_tokens", 'Int'>
    readonly user_id: FieldRef<"refresh_tokens", 'Int'>
    readonly token_hash: FieldRef<"refresh_tokens", 'String'>
    readonly revoked: FieldRef<"refresh_tokens", 'Boolean'>
    readonly created_at: FieldRef<"refresh_tokens", 'DateTime'>
    readonly expires_at: FieldRef<"refresh_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refresh_tokens findUnique
   */
  export type refresh_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findUniqueOrThrow
   */
  export type refresh_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findFirst
   */
  export type refresh_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findFirstOrThrow
   */
  export type refresh_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findMany
   */
  export type refresh_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens create
   */
  export type refresh_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a refresh_tokens.
     */
    data: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
  }

  /**
   * refresh_tokens createMany
   */
  export type refresh_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refresh_tokens createManyAndReturn
   */
  export type refresh_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * refresh_tokens update
   */
  export type refresh_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
    /**
     * Choose, which refresh_tokens to update.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens updateMany
   */
  export type refresh_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to update.
     */
    limit?: number
  }

  /**
   * refresh_tokens updateManyAndReturn
   */
  export type refresh_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * refresh_tokens upsert
   */
  export type refresh_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the refresh_tokens to update in case it exists.
     */
    where: refresh_tokensWhereUniqueInput
    /**
     * In case the refresh_tokens found by the `where` argument doesn't exist, create a new refresh_tokens with this data.
     */
    create: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
    /**
     * In case the refresh_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
  }

  /**
   * refresh_tokens delete
   */
  export type refresh_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter which refresh_tokens to delete.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens deleteMany
   */
  export type refresh_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to delete
     */
    where?: refresh_tokensWhereInput
    /**
     * Limit how many refresh_tokens to delete.
     */
    limit?: number
  }

  /**
   * refresh_tokens without action
   */
  export type refresh_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refresh_tokens
     */
    omit?: refresh_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
  }


  /**
   * Model assistants
   */

  export type AggregateAssistants = {
    _count: AssistantsCountAggregateOutputType | null
    _avg: AssistantsAvgAggregateOutputType | null
    _sum: AssistantsSumAggregateOutputType | null
    _min: AssistantsMinAggregateOutputType | null
    _max: AssistantsMaxAggregateOutputType | null
  }

  export type AssistantsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    lecturer_user_id: number | null
  }

  export type AssistantsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    lecturer_user_id: number | null
  }

  export type AssistantsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    lecturer_user_id: number | null
  }

  export type AssistantsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    lecturer_user_id: number | null
  }

  export type AssistantsCountAggregateOutputType = {
    id: number
    user_id: number
    lecturer_user_id: number
    _all: number
  }


  export type AssistantsAvgAggregateInputType = {
    id?: true
    user_id?: true
    lecturer_user_id?: true
  }

  export type AssistantsSumAggregateInputType = {
    id?: true
    user_id?: true
    lecturer_user_id?: true
  }

  export type AssistantsMinAggregateInputType = {
    id?: true
    user_id?: true
    lecturer_user_id?: true
  }

  export type AssistantsMaxAggregateInputType = {
    id?: true
    user_id?: true
    lecturer_user_id?: true
  }

  export type AssistantsCountAggregateInputType = {
    id?: true
    user_id?: true
    lecturer_user_id?: true
    _all?: true
  }

  export type AssistantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assistants to aggregate.
     */
    where?: assistantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assistants to fetch.
     */
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assistantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assistants
    **/
    _count?: true | AssistantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssistantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssistantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssistantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssistantsMaxAggregateInputType
  }

  export type GetAssistantsAggregateType<T extends AssistantsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssistants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssistants[P]>
      : GetScalarType<T[P], AggregateAssistants[P]>
  }




  export type assistantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assistantsWhereInput
    orderBy?: assistantsOrderByWithAggregationInput | assistantsOrderByWithAggregationInput[]
    by: AssistantsScalarFieldEnum[] | AssistantsScalarFieldEnum
    having?: assistantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssistantsCountAggregateInputType | true
    _avg?: AssistantsAvgAggregateInputType
    _sum?: AssistantsSumAggregateInputType
    _min?: AssistantsMinAggregateInputType
    _max?: AssistantsMaxAggregateInputType
  }

  export type AssistantsGroupByOutputType = {
    id: number
    user_id: number
    lecturer_user_id: number
    _count: AssistantsCountAggregateOutputType | null
    _avg: AssistantsAvgAggregateOutputType | null
    _sum: AssistantsSumAggregateOutputType | null
    _min: AssistantsMinAggregateOutputType | null
    _max: AssistantsMaxAggregateOutputType | null
  }

  type GetAssistantsGroupByPayload<T extends assistantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssistantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssistantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssistantsGroupByOutputType[P]>
            : GetScalarType<T[P], AssistantsGroupByOutputType[P]>
        }
      >
    >


  export type assistantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lecturer_user_id?: boolean
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistants"]>

  export type assistantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lecturer_user_id?: boolean
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistants"]>

  export type assistantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lecturer_user_id?: boolean
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assistants"]>

  export type assistantsSelectScalar = {
    id?: boolean
    user_id?: boolean
    lecturer_user_id?: boolean
  }

  export type assistantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "lecturer_user_id", ExtArgs["result"]["assistants"]>
  export type assistantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type assistantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type assistantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecturers?: boolean | lecturersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $assistantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assistants"
    objects: {
      lecturers: Prisma.$lecturersPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      lecturer_user_id: number
    }, ExtArgs["result"]["assistants"]>
    composites: {}
  }

  type assistantsGetPayload<S extends boolean | null | undefined | assistantsDefaultArgs> = $Result.GetResult<Prisma.$assistantsPayload, S>

  type assistantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assistantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssistantsCountAggregateInputType | true
    }

  export interface assistantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assistants'], meta: { name: 'assistants' } }
    /**
     * Find zero or one Assistants that matches the filter.
     * @param {assistantsFindUniqueArgs} args - Arguments to find a Assistants
     * @example
     * // Get one Assistants
     * const assistants = await prisma.assistants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assistantsFindUniqueArgs>(args: SelectSubset<T, assistantsFindUniqueArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assistants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assistantsFindUniqueOrThrowArgs} args - Arguments to find a Assistants
     * @example
     * // Get one Assistants
     * const assistants = await prisma.assistants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assistantsFindUniqueOrThrowArgs>(args: SelectSubset<T, assistantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsFindFirstArgs} args - Arguments to find a Assistants
     * @example
     * // Get one Assistants
     * const assistants = await prisma.assistants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assistantsFindFirstArgs>(args?: SelectSubset<T, assistantsFindFirstArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assistants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsFindFirstOrThrowArgs} args - Arguments to find a Assistants
     * @example
     * // Get one Assistants
     * const assistants = await prisma.assistants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assistantsFindFirstOrThrowArgs>(args?: SelectSubset<T, assistantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assistants
     * const assistants = await prisma.assistants.findMany()
     * 
     * // Get first 10 Assistants
     * const assistants = await prisma.assistants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assistantsWithIdOnly = await prisma.assistants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assistantsFindManyArgs>(args?: SelectSubset<T, assistantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assistants.
     * @param {assistantsCreateArgs} args - Arguments to create a Assistants.
     * @example
     * // Create one Assistants
     * const Assistants = await prisma.assistants.create({
     *   data: {
     *     // ... data to create a Assistants
     *   }
     * })
     * 
     */
    create<T extends assistantsCreateArgs>(args: SelectSubset<T, assistantsCreateArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assistants.
     * @param {assistantsCreateManyArgs} args - Arguments to create many Assistants.
     * @example
     * // Create many Assistants
     * const assistants = await prisma.assistants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assistantsCreateManyArgs>(args?: SelectSubset<T, assistantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assistants and returns the data saved in the database.
     * @param {assistantsCreateManyAndReturnArgs} args - Arguments to create many Assistants.
     * @example
     * // Create many Assistants
     * const assistants = await prisma.assistants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assistants and only return the `id`
     * const assistantsWithIdOnly = await prisma.assistants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assistantsCreateManyAndReturnArgs>(args?: SelectSubset<T, assistantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assistants.
     * @param {assistantsDeleteArgs} args - Arguments to delete one Assistants.
     * @example
     * // Delete one Assistants
     * const Assistants = await prisma.assistants.delete({
     *   where: {
     *     // ... filter to delete one Assistants
     *   }
     * })
     * 
     */
    delete<T extends assistantsDeleteArgs>(args: SelectSubset<T, assistantsDeleteArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assistants.
     * @param {assistantsUpdateArgs} args - Arguments to update one Assistants.
     * @example
     * // Update one Assistants
     * const assistants = await prisma.assistants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assistantsUpdateArgs>(args: SelectSubset<T, assistantsUpdateArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assistants.
     * @param {assistantsDeleteManyArgs} args - Arguments to filter Assistants to delete.
     * @example
     * // Delete a few Assistants
     * const { count } = await prisma.assistants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assistantsDeleteManyArgs>(args?: SelectSubset<T, assistantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assistants
     * const assistants = await prisma.assistants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assistantsUpdateManyArgs>(args: SelectSubset<T, assistantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assistants and returns the data updated in the database.
     * @param {assistantsUpdateManyAndReturnArgs} args - Arguments to update many Assistants.
     * @example
     * // Update many Assistants
     * const assistants = await prisma.assistants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assistants and only return the `id`
     * const assistantsWithIdOnly = await prisma.assistants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assistantsUpdateManyAndReturnArgs>(args: SelectSubset<T, assistantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assistants.
     * @param {assistantsUpsertArgs} args - Arguments to update or create a Assistants.
     * @example
     * // Update or create a Assistants
     * const assistants = await prisma.assistants.upsert({
     *   create: {
     *     // ... data to create a Assistants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assistants we want to update
     *   }
     * })
     */
    upsert<T extends assistantsUpsertArgs>(args: SelectSubset<T, assistantsUpsertArgs<ExtArgs>>): Prisma__assistantsClient<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsCountArgs} args - Arguments to filter Assistants to count.
     * @example
     * // Count the number of Assistants
     * const count = await prisma.assistants.count({
     *   where: {
     *     // ... the filter for the Assistants we want to count
     *   }
     * })
    **/
    count<T extends assistantsCountArgs>(
      args?: Subset<T, assistantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssistantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssistantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssistantsAggregateArgs>(args: Subset<T, AssistantsAggregateArgs>): Prisma.PrismaPromise<GetAssistantsAggregateType<T>>

    /**
     * Group by Assistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assistantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assistantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assistantsGroupByArgs['orderBy'] }
        : { orderBy?: assistantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assistantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssistantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assistants model
   */
  readonly fields: assistantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assistants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assistantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecturers<T extends lecturersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lecturersDefaultArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assistants model
   */
  interface assistantsFieldRefs {
    readonly id: FieldRef<"assistants", 'Int'>
    readonly user_id: FieldRef<"assistants", 'Int'>
    readonly lecturer_user_id: FieldRef<"assistants", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * assistants findUnique
   */
  export type assistantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter, which assistants to fetch.
     */
    where: assistantsWhereUniqueInput
  }

  /**
   * assistants findUniqueOrThrow
   */
  export type assistantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter, which assistants to fetch.
     */
    where: assistantsWhereUniqueInput
  }

  /**
   * assistants findFirst
   */
  export type assistantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter, which assistants to fetch.
     */
    where?: assistantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assistants to fetch.
     */
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assistants.
     */
    cursor?: assistantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assistants.
     */
    distinct?: AssistantsScalarFieldEnum | AssistantsScalarFieldEnum[]
  }

  /**
   * assistants findFirstOrThrow
   */
  export type assistantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter, which assistants to fetch.
     */
    where?: assistantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assistants to fetch.
     */
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assistants.
     */
    cursor?: assistantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assistants.
     */
    distinct?: AssistantsScalarFieldEnum | AssistantsScalarFieldEnum[]
  }

  /**
   * assistants findMany
   */
  export type assistantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter, which assistants to fetch.
     */
    where?: assistantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assistants to fetch.
     */
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assistants.
     */
    cursor?: assistantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assistants.
     */
    skip?: number
    distinct?: AssistantsScalarFieldEnum | AssistantsScalarFieldEnum[]
  }

  /**
   * assistants create
   */
  export type assistantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * The data needed to create a assistants.
     */
    data: XOR<assistantsCreateInput, assistantsUncheckedCreateInput>
  }

  /**
   * assistants createMany
   */
  export type assistantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assistants.
     */
    data: assistantsCreateManyInput | assistantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assistants createManyAndReturn
   */
  export type assistantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * The data used to create many assistants.
     */
    data: assistantsCreateManyInput | assistantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assistants update
   */
  export type assistantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * The data needed to update a assistants.
     */
    data: XOR<assistantsUpdateInput, assistantsUncheckedUpdateInput>
    /**
     * Choose, which assistants to update.
     */
    where: assistantsWhereUniqueInput
  }

  /**
   * assistants updateMany
   */
  export type assistantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assistants.
     */
    data: XOR<assistantsUpdateManyMutationInput, assistantsUncheckedUpdateManyInput>
    /**
     * Filter which assistants to update
     */
    where?: assistantsWhereInput
    /**
     * Limit how many assistants to update.
     */
    limit?: number
  }

  /**
   * assistants updateManyAndReturn
   */
  export type assistantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * The data used to update assistants.
     */
    data: XOR<assistantsUpdateManyMutationInput, assistantsUncheckedUpdateManyInput>
    /**
     * Filter which assistants to update
     */
    where?: assistantsWhereInput
    /**
     * Limit how many assistants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assistants upsert
   */
  export type assistantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * The filter to search for the assistants to update in case it exists.
     */
    where: assistantsWhereUniqueInput
    /**
     * In case the assistants found by the `where` argument doesn't exist, create a new assistants with this data.
     */
    create: XOR<assistantsCreateInput, assistantsUncheckedCreateInput>
    /**
     * In case the assistants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assistantsUpdateInput, assistantsUncheckedUpdateInput>
  }

  /**
   * assistants delete
   */
  export type assistantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    /**
     * Filter which assistants to delete.
     */
    where: assistantsWhereUniqueInput
  }

  /**
   * assistants deleteMany
   */
  export type assistantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assistants to delete
     */
    where?: assistantsWhereInput
    /**
     * Limit how many assistants to delete.
     */
    limit?: number
  }

  /**
   * assistants without action
   */
  export type assistantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
  }


  /**
   * Model government
   */

  export type AggregateGovernment = {
    _count: GovernmentCountAggregateOutputType | null
    _avg: GovernmentAvgAggregateOutputType | null
    _sum: GovernmentSumAggregateOutputType | null
    _min: GovernmentMinAggregateOutputType | null
    _max: GovernmentMaxAggregateOutputType | null
  }

  export type GovernmentAvgAggregateOutputType = {
    id: number | null
  }

  export type GovernmentSumAggregateOutputType = {
    id: number | null
  }

  export type GovernmentMinAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type GovernmentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type GovernmentCountAggregateOutputType = {
    id: number
    title: number
    active: number
    _all: number
  }


  export type GovernmentAvgAggregateInputType = {
    id?: true
  }

  export type GovernmentSumAggregateInputType = {
    id?: true
  }

  export type GovernmentMinAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type GovernmentMaxAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type GovernmentCountAggregateInputType = {
    id?: true
    title?: true
    active?: true
    _all?: true
  }

  export type GovernmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which government to aggregate.
     */
    where?: governmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of governments to fetch.
     */
    orderBy?: governmentOrderByWithRelationInput | governmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: governmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` governments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` governments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned governments
    **/
    _count?: true | GovernmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GovernmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GovernmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernmentMaxAggregateInputType
  }

  export type GetGovernmentAggregateType<T extends GovernmentAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernment[P]>
      : GetScalarType<T[P], AggregateGovernment[P]>
  }




  export type governmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: governmentWhereInput
    orderBy?: governmentOrderByWithAggregationInput | governmentOrderByWithAggregationInput[]
    by: GovernmentScalarFieldEnum[] | GovernmentScalarFieldEnum
    having?: governmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernmentCountAggregateInputType | true
    _avg?: GovernmentAvgAggregateInputType
    _sum?: GovernmentSumAggregateInputType
    _min?: GovernmentMinAggregateInputType
    _max?: GovernmentMaxAggregateInputType
  }

  export type GovernmentGroupByOutputType = {
    id: number
    title: string
    active: boolean | null
    _count: GovernmentCountAggregateOutputType | null
    _avg: GovernmentAvgAggregateOutputType | null
    _sum: GovernmentSumAggregateOutputType | null
    _min: GovernmentMinAggregateOutputType | null
    _max: GovernmentMaxAggregateOutputType | null
  }

  type GetGovernmentGroupByPayload<T extends governmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernmentGroupByOutputType[P]>
            : GetScalarType<T[P], GovernmentGroupByOutputType[P]>
        }
      >
    >


  export type governmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
    parents?: boolean | government$parentsArgs<ExtArgs>
    students?: boolean | government$studentsArgs<ExtArgs>
    teachers?: boolean | government$teachersArgs<ExtArgs>
    zones?: boolean | government$zonesArgs<ExtArgs>
    _count?: boolean | GovernmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["government"]>

  export type governmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["government"]>

  export type governmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["government"]>

  export type governmentSelectScalar = {
    id?: boolean
    title?: boolean
    active?: boolean
  }

  export type governmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "active", ExtArgs["result"]["government"]>
  export type governmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | government$parentsArgs<ExtArgs>
    students?: boolean | government$studentsArgs<ExtArgs>
    teachers?: boolean | government$teachersArgs<ExtArgs>
    zones?: boolean | government$zonesArgs<ExtArgs>
    _count?: boolean | GovernmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type governmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type governmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $governmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "government"
    objects: {
      parents: Prisma.$parentsPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
      teachers: Prisma.$teachersPayload<ExtArgs>[]
      zones: Prisma.$zonesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      active: boolean | null
    }, ExtArgs["result"]["government"]>
    composites: {}
  }

  type governmentGetPayload<S extends boolean | null | undefined | governmentDefaultArgs> = $Result.GetResult<Prisma.$governmentPayload, S>

  type governmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<governmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernmentCountAggregateInputType | true
    }

  export interface governmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['government'], meta: { name: 'government' } }
    /**
     * Find zero or one Government that matches the filter.
     * @param {governmentFindUniqueArgs} args - Arguments to find a Government
     * @example
     * // Get one Government
     * const government = await prisma.government.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends governmentFindUniqueArgs>(args: SelectSubset<T, governmentFindUniqueArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Government that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {governmentFindUniqueOrThrowArgs} args - Arguments to find a Government
     * @example
     * // Get one Government
     * const government = await prisma.government.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends governmentFindUniqueOrThrowArgs>(args: SelectSubset<T, governmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Government that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentFindFirstArgs} args - Arguments to find a Government
     * @example
     * // Get one Government
     * const government = await prisma.government.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends governmentFindFirstArgs>(args?: SelectSubset<T, governmentFindFirstArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Government that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentFindFirstOrThrowArgs} args - Arguments to find a Government
     * @example
     * // Get one Government
     * const government = await prisma.government.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends governmentFindFirstOrThrowArgs>(args?: SelectSubset<T, governmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Governments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Governments
     * const governments = await prisma.government.findMany()
     * 
     * // Get first 10 Governments
     * const governments = await prisma.government.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governmentWithIdOnly = await prisma.government.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends governmentFindManyArgs>(args?: SelectSubset<T, governmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Government.
     * @param {governmentCreateArgs} args - Arguments to create a Government.
     * @example
     * // Create one Government
     * const Government = await prisma.government.create({
     *   data: {
     *     // ... data to create a Government
     *   }
     * })
     * 
     */
    create<T extends governmentCreateArgs>(args: SelectSubset<T, governmentCreateArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Governments.
     * @param {governmentCreateManyArgs} args - Arguments to create many Governments.
     * @example
     * // Create many Governments
     * const government = await prisma.government.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends governmentCreateManyArgs>(args?: SelectSubset<T, governmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Governments and returns the data saved in the database.
     * @param {governmentCreateManyAndReturnArgs} args - Arguments to create many Governments.
     * @example
     * // Create many Governments
     * const government = await prisma.government.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Governments and only return the `id`
     * const governmentWithIdOnly = await prisma.government.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends governmentCreateManyAndReturnArgs>(args?: SelectSubset<T, governmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Government.
     * @param {governmentDeleteArgs} args - Arguments to delete one Government.
     * @example
     * // Delete one Government
     * const Government = await prisma.government.delete({
     *   where: {
     *     // ... filter to delete one Government
     *   }
     * })
     * 
     */
    delete<T extends governmentDeleteArgs>(args: SelectSubset<T, governmentDeleteArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Government.
     * @param {governmentUpdateArgs} args - Arguments to update one Government.
     * @example
     * // Update one Government
     * const government = await prisma.government.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends governmentUpdateArgs>(args: SelectSubset<T, governmentUpdateArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Governments.
     * @param {governmentDeleteManyArgs} args - Arguments to filter Governments to delete.
     * @example
     * // Delete a few Governments
     * const { count } = await prisma.government.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends governmentDeleteManyArgs>(args?: SelectSubset<T, governmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Governments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Governments
     * const government = await prisma.government.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends governmentUpdateManyArgs>(args: SelectSubset<T, governmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Governments and returns the data updated in the database.
     * @param {governmentUpdateManyAndReturnArgs} args - Arguments to update many Governments.
     * @example
     * // Update many Governments
     * const government = await prisma.government.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Governments and only return the `id`
     * const governmentWithIdOnly = await prisma.government.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends governmentUpdateManyAndReturnArgs>(args: SelectSubset<T, governmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Government.
     * @param {governmentUpsertArgs} args - Arguments to update or create a Government.
     * @example
     * // Update or create a Government
     * const government = await prisma.government.upsert({
     *   create: {
     *     // ... data to create a Government
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Government we want to update
     *   }
     * })
     */
    upsert<T extends governmentUpsertArgs>(args: SelectSubset<T, governmentUpsertArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Governments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentCountArgs} args - Arguments to filter Governments to count.
     * @example
     * // Count the number of Governments
     * const count = await prisma.government.count({
     *   where: {
     *     // ... the filter for the Governments we want to count
     *   }
     * })
    **/
    count<T extends governmentCountArgs>(
      args?: Subset<T, governmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Government.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernmentAggregateArgs>(args: Subset<T, GovernmentAggregateArgs>): Prisma.PrismaPromise<GetGovernmentAggregateType<T>>

    /**
     * Group by Government.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {governmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends governmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: governmentGroupByArgs['orderBy'] }
        : { orderBy?: governmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, governmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the government model
   */
  readonly fields: governmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for government.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__governmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends government$parentsArgs<ExtArgs> = {}>(args?: Subset<T, government$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends government$studentsArgs<ExtArgs> = {}>(args?: Subset<T, government$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends government$teachersArgs<ExtArgs> = {}>(args?: Subset<T, government$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends government$zonesArgs<ExtArgs> = {}>(args?: Subset<T, government$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the government model
   */
  interface governmentFieldRefs {
    readonly id: FieldRef<"government", 'Int'>
    readonly title: FieldRef<"government", 'String'>
    readonly active: FieldRef<"government", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * government findUnique
   */
  export type governmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter, which government to fetch.
     */
    where: governmentWhereUniqueInput
  }

  /**
   * government findUniqueOrThrow
   */
  export type governmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter, which government to fetch.
     */
    where: governmentWhereUniqueInput
  }

  /**
   * government findFirst
   */
  export type governmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter, which government to fetch.
     */
    where?: governmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of governments to fetch.
     */
    orderBy?: governmentOrderByWithRelationInput | governmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for governments.
     */
    cursor?: governmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` governments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` governments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of governments.
     */
    distinct?: GovernmentScalarFieldEnum | GovernmentScalarFieldEnum[]
  }

  /**
   * government findFirstOrThrow
   */
  export type governmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter, which government to fetch.
     */
    where?: governmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of governments to fetch.
     */
    orderBy?: governmentOrderByWithRelationInput | governmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for governments.
     */
    cursor?: governmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` governments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` governments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of governments.
     */
    distinct?: GovernmentScalarFieldEnum | GovernmentScalarFieldEnum[]
  }

  /**
   * government findMany
   */
  export type governmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter, which governments to fetch.
     */
    where?: governmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of governments to fetch.
     */
    orderBy?: governmentOrderByWithRelationInput | governmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing governments.
     */
    cursor?: governmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` governments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` governments.
     */
    skip?: number
    distinct?: GovernmentScalarFieldEnum | GovernmentScalarFieldEnum[]
  }

  /**
   * government create
   */
  export type governmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * The data needed to create a government.
     */
    data: XOR<governmentCreateInput, governmentUncheckedCreateInput>
  }

  /**
   * government createMany
   */
  export type governmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many governments.
     */
    data: governmentCreateManyInput | governmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * government createManyAndReturn
   */
  export type governmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * The data used to create many governments.
     */
    data: governmentCreateManyInput | governmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * government update
   */
  export type governmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * The data needed to update a government.
     */
    data: XOR<governmentUpdateInput, governmentUncheckedUpdateInput>
    /**
     * Choose, which government to update.
     */
    where: governmentWhereUniqueInput
  }

  /**
   * government updateMany
   */
  export type governmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update governments.
     */
    data: XOR<governmentUpdateManyMutationInput, governmentUncheckedUpdateManyInput>
    /**
     * Filter which governments to update
     */
    where?: governmentWhereInput
    /**
     * Limit how many governments to update.
     */
    limit?: number
  }

  /**
   * government updateManyAndReturn
   */
  export type governmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * The data used to update governments.
     */
    data: XOR<governmentUpdateManyMutationInput, governmentUncheckedUpdateManyInput>
    /**
     * Filter which governments to update
     */
    where?: governmentWhereInput
    /**
     * Limit how many governments to update.
     */
    limit?: number
  }

  /**
   * government upsert
   */
  export type governmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * The filter to search for the government to update in case it exists.
     */
    where: governmentWhereUniqueInput
    /**
     * In case the government found by the `where` argument doesn't exist, create a new government with this data.
     */
    create: XOR<governmentCreateInput, governmentUncheckedCreateInput>
    /**
     * In case the government was found with the provided `where` argument, update it with this data.
     */
    update: XOR<governmentUpdateInput, governmentUncheckedUpdateInput>
  }

  /**
   * government delete
   */
  export type governmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    /**
     * Filter which government to delete.
     */
    where: governmentWhereUniqueInput
  }

  /**
   * government deleteMany
   */
  export type governmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which governments to delete
     */
    where?: governmentWhereInput
    /**
     * Limit how many governments to delete.
     */
    limit?: number
  }

  /**
   * government.parents
   */
  export type government$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    cursor?: parentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * government.students
   */
  export type government$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * government.teachers
   */
  export type government$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    cursor?: teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * government.zones
   */
  export type government$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    where?: zonesWhereInput
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    cursor?: zonesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * government without action
   */
  export type governmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
  }


  /**
   * Model lecturers
   */

  export type AggregateLecturers = {
    _count: LecturersCountAggregateOutputType | null
    _avg: LecturersAvgAggregateOutputType | null
    _sum: LecturersSumAggregateOutputType | null
    _min: LecturersMinAggregateOutputType | null
    _max: LecturersMaxAggregateOutputType | null
  }

  export type LecturersAvgAggregateOutputType = {
    user_id: number | null
  }

  export type LecturersSumAggregateOutputType = {
    user_id: number | null
  }

  export type LecturersMinAggregateOutputType = {
    user_id: number | null
    bio: string | null
    expertise: string | null
  }

  export type LecturersMaxAggregateOutputType = {
    user_id: number | null
    bio: string | null
    expertise: string | null
  }

  export type LecturersCountAggregateOutputType = {
    user_id: number
    bio: number
    expertise: number
    _all: number
  }


  export type LecturersAvgAggregateInputType = {
    user_id?: true
  }

  export type LecturersSumAggregateInputType = {
    user_id?: true
  }

  export type LecturersMinAggregateInputType = {
    user_id?: true
    bio?: true
    expertise?: true
  }

  export type LecturersMaxAggregateInputType = {
    user_id?: true
    bio?: true
    expertise?: true
  }

  export type LecturersCountAggregateInputType = {
    user_id?: true
    bio?: true
    expertise?: true
    _all?: true
  }

  export type LecturersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lecturers to aggregate.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lecturers
    **/
    _count?: true | LecturersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LecturersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LecturersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturersMaxAggregateInputType
  }

  export type GetLecturersAggregateType<T extends LecturersAggregateArgs> = {
        [P in keyof T & keyof AggregateLecturers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecturers[P]>
      : GetScalarType<T[P], AggregateLecturers[P]>
  }




  export type lecturersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lecturersWhereInput
    orderBy?: lecturersOrderByWithAggregationInput | lecturersOrderByWithAggregationInput[]
    by: LecturersScalarFieldEnum[] | LecturersScalarFieldEnum
    having?: lecturersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturersCountAggregateInputType | true
    _avg?: LecturersAvgAggregateInputType
    _sum?: LecturersSumAggregateInputType
    _min?: LecturersMinAggregateInputType
    _max?: LecturersMaxAggregateInputType
  }

  export type LecturersGroupByOutputType = {
    user_id: number
    bio: string | null
    expertise: string | null
    _count: LecturersCountAggregateOutputType | null
    _avg: LecturersAvgAggregateOutputType | null
    _sum: LecturersSumAggregateOutputType | null
    _min: LecturersMinAggregateOutputType | null
    _max: LecturersMaxAggregateOutputType | null
  }

  type GetLecturersGroupByPayload<T extends lecturersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LecturersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturersGroupByOutputType[P]>
            : GetScalarType<T[P], LecturersGroupByOutputType[P]>
        }
      >
    >


  export type lecturersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bio?: boolean
    expertise?: boolean
    assistants?: boolean | lecturers$assistantsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | LecturersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bio?: boolean
    expertise?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bio?: boolean
    expertise?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecturers"]>

  export type lecturersSelectScalar = {
    user_id?: boolean
    bio?: boolean
    expertise?: boolean
  }

  export type lecturersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "bio" | "expertise", ExtArgs["result"]["lecturers"]>
  export type lecturersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | lecturers$assistantsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | LecturersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type lecturersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type lecturersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $lecturersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lecturers"
    objects: {
      assistants: Prisma.$assistantsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      bio: string | null
      expertise: string | null
    }, ExtArgs["result"]["lecturers"]>
    composites: {}
  }

  type lecturersGetPayload<S extends boolean | null | undefined | lecturersDefaultArgs> = $Result.GetResult<Prisma.$lecturersPayload, S>

  type lecturersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lecturersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LecturersCountAggregateInputType | true
    }

  export interface lecturersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lecturers'], meta: { name: 'lecturers' } }
    /**
     * Find zero or one Lecturers that matches the filter.
     * @param {lecturersFindUniqueArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lecturersFindUniqueArgs>(args: SelectSubset<T, lecturersFindUniqueArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lecturers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lecturersFindUniqueOrThrowArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lecturersFindUniqueOrThrowArgs>(args: SelectSubset<T, lecturersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindFirstArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lecturersFindFirstArgs>(args?: SelectSubset<T, lecturersFindFirstArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecturers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindFirstOrThrowArgs} args - Arguments to find a Lecturers
     * @example
     * // Get one Lecturers
     * const lecturers = await prisma.lecturers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lecturersFindFirstOrThrowArgs>(args?: SelectSubset<T, lecturersFindFirstOrThrowArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturers
     * const lecturers = await prisma.lecturers.findMany()
     * 
     * // Get first 10 Lecturers
     * const lecturers = await prisma.lecturers.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const lecturersWithUser_idOnly = await prisma.lecturers.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends lecturersFindManyArgs>(args?: SelectSubset<T, lecturersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lecturers.
     * @param {lecturersCreateArgs} args - Arguments to create a Lecturers.
     * @example
     * // Create one Lecturers
     * const Lecturers = await prisma.lecturers.create({
     *   data: {
     *     // ... data to create a Lecturers
     *   }
     * })
     * 
     */
    create<T extends lecturersCreateArgs>(args: SelectSubset<T, lecturersCreateArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lecturers.
     * @param {lecturersCreateManyArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturers = await prisma.lecturers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lecturersCreateManyArgs>(args?: SelectSubset<T, lecturersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lecturers and returns the data saved in the database.
     * @param {lecturersCreateManyAndReturnArgs} args - Arguments to create many Lecturers.
     * @example
     * // Create many Lecturers
     * const lecturers = await prisma.lecturers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lecturers and only return the `user_id`
     * const lecturersWithUser_idOnly = await prisma.lecturers.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lecturersCreateManyAndReturnArgs>(args?: SelectSubset<T, lecturersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lecturers.
     * @param {lecturersDeleteArgs} args - Arguments to delete one Lecturers.
     * @example
     * // Delete one Lecturers
     * const Lecturers = await prisma.lecturers.delete({
     *   where: {
     *     // ... filter to delete one Lecturers
     *   }
     * })
     * 
     */
    delete<T extends lecturersDeleteArgs>(args: SelectSubset<T, lecturersDeleteArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lecturers.
     * @param {lecturersUpdateArgs} args - Arguments to update one Lecturers.
     * @example
     * // Update one Lecturers
     * const lecturers = await prisma.lecturers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lecturersUpdateArgs>(args: SelectSubset<T, lecturersUpdateArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lecturers.
     * @param {lecturersDeleteManyArgs} args - Arguments to filter Lecturers to delete.
     * @example
     * // Delete a few Lecturers
     * const { count } = await prisma.lecturers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lecturersDeleteManyArgs>(args?: SelectSubset<T, lecturersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturers
     * const lecturers = await prisma.lecturers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lecturersUpdateManyArgs>(args: SelectSubset<T, lecturersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers and returns the data updated in the database.
     * @param {lecturersUpdateManyAndReturnArgs} args - Arguments to update many Lecturers.
     * @example
     * // Update many Lecturers
     * const lecturers = await prisma.lecturers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lecturers and only return the `user_id`
     * const lecturersWithUser_idOnly = await prisma.lecturers.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lecturersUpdateManyAndReturnArgs>(args: SelectSubset<T, lecturersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lecturers.
     * @param {lecturersUpsertArgs} args - Arguments to update or create a Lecturers.
     * @example
     * // Update or create a Lecturers
     * const lecturers = await prisma.lecturers.upsert({
     *   create: {
     *     // ... data to create a Lecturers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecturers we want to update
     *   }
     * })
     */
    upsert<T extends lecturersUpsertArgs>(args: SelectSubset<T, lecturersUpsertArgs<ExtArgs>>): Prisma__lecturersClient<$Result.GetResult<Prisma.$lecturersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersCountArgs} args - Arguments to filter Lecturers to count.
     * @example
     * // Count the number of Lecturers
     * const count = await prisma.lecturers.count({
     *   where: {
     *     // ... the filter for the Lecturers we want to count
     *   }
     * })
    **/
    count<T extends lecturersCountArgs>(
      args?: Subset<T, lecturersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturersAggregateArgs>(args: Subset<T, LecturersAggregateArgs>): Prisma.PrismaPromise<GetLecturersAggregateType<T>>

    /**
     * Group by Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lecturersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lecturersGroupByArgs['orderBy'] }
        : { orderBy?: lecturersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lecturersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lecturers model
   */
  readonly fields: lecturersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lecturers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lecturersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assistants<T extends lecturers$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, lecturers$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assistantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lecturers model
   */
  interface lecturersFieldRefs {
    readonly user_id: FieldRef<"lecturers", 'Int'>
    readonly bio: FieldRef<"lecturers", 'String'>
    readonly expertise: FieldRef<"lecturers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lecturers findUnique
   */
  export type lecturersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers findUniqueOrThrow
   */
  export type lecturersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers findFirst
   */
  export type lecturersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturers.
     */
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers findFirstOrThrow
   */
  export type lecturersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturers.
     */
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers findMany
   */
  export type lecturersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter, which lecturers to fetch.
     */
    where?: lecturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     */
    orderBy?: lecturersOrderByWithRelationInput | lecturersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lecturers.
     */
    cursor?: lecturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     */
    skip?: number
    distinct?: LecturersScalarFieldEnum | LecturersScalarFieldEnum[]
  }

  /**
   * lecturers create
   */
  export type lecturersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The data needed to create a lecturers.
     */
    data: XOR<lecturersCreateInput, lecturersUncheckedCreateInput>
  }

  /**
   * lecturers createMany
   */
  export type lecturersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lecturers.
     */
    data: lecturersCreateManyInput | lecturersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lecturers createManyAndReturn
   */
  export type lecturersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * The data used to create many lecturers.
     */
    data: lecturersCreateManyInput | lecturersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * lecturers update
   */
  export type lecturersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The data needed to update a lecturers.
     */
    data: XOR<lecturersUpdateInput, lecturersUncheckedUpdateInput>
    /**
     * Choose, which lecturers to update.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers updateMany
   */
  export type lecturersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lecturers.
     */
    data: XOR<lecturersUpdateManyMutationInput, lecturersUncheckedUpdateManyInput>
    /**
     * Filter which lecturers to update
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to update.
     */
    limit?: number
  }

  /**
   * lecturers updateManyAndReturn
   */
  export type lecturersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * The data used to update lecturers.
     */
    data: XOR<lecturersUpdateManyMutationInput, lecturersUncheckedUpdateManyInput>
    /**
     * Filter which lecturers to update
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * lecturers upsert
   */
  export type lecturersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * The filter to search for the lecturers to update in case it exists.
     */
    where: lecturersWhereUniqueInput
    /**
     * In case the lecturers found by the `where` argument doesn't exist, create a new lecturers with this data.
     */
    create: XOR<lecturersCreateInput, lecturersUncheckedCreateInput>
    /**
     * In case the lecturers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lecturersUpdateInput, lecturersUncheckedUpdateInput>
  }

  /**
   * lecturers delete
   */
  export type lecturersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
    /**
     * Filter which lecturers to delete.
     */
    where: lecturersWhereUniqueInput
  }

  /**
   * lecturers deleteMany
   */
  export type lecturersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lecturers to delete
     */
    where?: lecturersWhereInput
    /**
     * Limit how many lecturers to delete.
     */
    limit?: number
  }

  /**
   * lecturers.assistants
   */
  export type lecturers$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assistants
     */
    select?: assistantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assistants
     */
    omit?: assistantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assistantsInclude<ExtArgs> | null
    where?: assistantsWhereInput
    orderBy?: assistantsOrderByWithRelationInput | assistantsOrderByWithRelationInput[]
    cursor?: assistantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssistantsScalarFieldEnum | AssistantsScalarFieldEnum[]
  }

  /**
   * lecturers without action
   */
  export type lecturersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lecturers
     */
    select?: lecturersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lecturers
     */
    omit?: lecturersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lecturersInclude<ExtArgs> | null
  }


  /**
   * Model levels
   */

  export type AggregateLevels = {
    _count: LevelsCountAggregateOutputType | null
    _avg: LevelsAvgAggregateOutputType | null
    _sum: LevelsSumAggregateOutputType | null
    _min: LevelsMinAggregateOutputType | null
    _max: LevelsMaxAggregateOutputType | null
  }

  export type LevelsAvgAggregateOutputType = {
    id: number | null
  }

  export type LevelsSumAggregateOutputType = {
    id: number | null
  }

  export type LevelsMinAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type LevelsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type LevelsCountAggregateOutputType = {
    id: number
    title: number
    active: number
    _all: number
  }


  export type LevelsAvgAggregateInputType = {
    id?: true
  }

  export type LevelsSumAggregateInputType = {
    id?: true
  }

  export type LevelsMinAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type LevelsMaxAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type LevelsCountAggregateInputType = {
    id?: true
    title?: true
    active?: true
    _all?: true
  }

  export type LevelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which levels to aggregate.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned levels
    **/
    _count?: true | LevelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelsMaxAggregateInputType
  }

  export type GetLevelsAggregateType<T extends LevelsAggregateArgs> = {
        [P in keyof T & keyof AggregateLevels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevels[P]>
      : GetScalarType<T[P], AggregateLevels[P]>
  }




  export type levelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: levelsWhereInput
    orderBy?: levelsOrderByWithAggregationInput | levelsOrderByWithAggregationInput[]
    by: LevelsScalarFieldEnum[] | LevelsScalarFieldEnum
    having?: levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelsCountAggregateInputType | true
    _avg?: LevelsAvgAggregateInputType
    _sum?: LevelsSumAggregateInputType
    _min?: LevelsMinAggregateInputType
    _max?: LevelsMaxAggregateInputType
  }

  export type LevelsGroupByOutputType = {
    id: number
    title: string
    active: boolean | null
    _count: LevelsCountAggregateOutputType | null
    _avg: LevelsAvgAggregateOutputType | null
    _sum: LevelsSumAggregateOutputType | null
    _min: LevelsMinAggregateOutputType | null
    _max: LevelsMaxAggregateOutputType | null
  }

  type GetLevelsGroupByPayload<T extends levelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelsGroupByOutputType[P]>
            : GetScalarType<T[P], LevelsGroupByOutputType[P]>
        }
      >
    >


  export type levelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
    students?: boolean | levels$studentsArgs<ExtArgs>
    _count?: boolean | LevelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levels"]>

  export type levelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["levels"]>

  export type levelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["levels"]>

  export type levelsSelectScalar = {
    id?: boolean
    title?: boolean
    active?: boolean
  }

  export type levelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "active", ExtArgs["result"]["levels"]>
  export type levelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | levels$studentsArgs<ExtArgs>
    _count?: boolean | LevelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type levelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type levelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $levelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "levels"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      active: boolean | null
    }, ExtArgs["result"]["levels"]>
    composites: {}
  }

  type levelsGetPayload<S extends boolean | null | undefined | levelsDefaultArgs> = $Result.GetResult<Prisma.$levelsPayload, S>

  type levelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<levelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelsCountAggregateInputType | true
    }

  export interface levelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['levels'], meta: { name: 'levels' } }
    /**
     * Find zero or one Levels that matches the filter.
     * @param {levelsFindUniqueArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends levelsFindUniqueArgs>(args: SelectSubset<T, levelsFindUniqueArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Levels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {levelsFindUniqueOrThrowArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends levelsFindUniqueOrThrowArgs>(args: SelectSubset<T, levelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindFirstArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends levelsFindFirstArgs>(args?: SelectSubset<T, levelsFindFirstArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Levels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindFirstOrThrowArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends levelsFindFirstOrThrowArgs>(args?: SelectSubset<T, levelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.levels.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.levels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelsWithIdOnly = await prisma.levels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends levelsFindManyArgs>(args?: SelectSubset<T, levelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Levels.
     * @param {levelsCreateArgs} args - Arguments to create a Levels.
     * @example
     * // Create one Levels
     * const Levels = await prisma.levels.create({
     *   data: {
     *     // ... data to create a Levels
     *   }
     * })
     * 
     */
    create<T extends levelsCreateArgs>(args: SelectSubset<T, levelsCreateArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {levelsCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const levels = await prisma.levels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends levelsCreateManyArgs>(args?: SelectSubset<T, levelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {levelsCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const levels = await prisma.levels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelsWithIdOnly = await prisma.levels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends levelsCreateManyAndReturnArgs>(args?: SelectSubset<T, levelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Levels.
     * @param {levelsDeleteArgs} args - Arguments to delete one Levels.
     * @example
     * // Delete one Levels
     * const Levels = await prisma.levels.delete({
     *   where: {
     *     // ... filter to delete one Levels
     *   }
     * })
     * 
     */
    delete<T extends levelsDeleteArgs>(args: SelectSubset<T, levelsDeleteArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Levels.
     * @param {levelsUpdateArgs} args - Arguments to update one Levels.
     * @example
     * // Update one Levels
     * const levels = await prisma.levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends levelsUpdateArgs>(args: SelectSubset<T, levelsUpdateArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {levelsDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends levelsDeleteManyArgs>(args?: SelectSubset<T, levelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const levels = await prisma.levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends levelsUpdateManyArgs>(args: SelectSubset<T, levelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {levelsUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const levels = await prisma.levels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelsWithIdOnly = await prisma.levels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends levelsUpdateManyAndReturnArgs>(args: SelectSubset<T, levelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Levels.
     * @param {levelsUpsertArgs} args - Arguments to update or create a Levels.
     * @example
     * // Update or create a Levels
     * const levels = await prisma.levels.upsert({
     *   create: {
     *     // ... data to create a Levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Levels we want to update
     *   }
     * })
     */
    upsert<T extends levelsUpsertArgs>(args: SelectSubset<T, levelsUpsertArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.levels.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends levelsCountArgs>(
      args?: Subset<T, levelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelsAggregateArgs>(args: Subset<T, LevelsAggregateArgs>): Prisma.PrismaPromise<GetLevelsAggregateType<T>>

    /**
     * Group by Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: levelsGroupByArgs['orderBy'] }
        : { orderBy?: levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the levels model
   */
  readonly fields: levelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__levelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends levels$studentsArgs<ExtArgs> = {}>(args?: Subset<T, levels$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the levels model
   */
  interface levelsFieldRefs {
    readonly id: FieldRef<"levels", 'Int'>
    readonly title: FieldRef<"levels", 'String'>
    readonly active: FieldRef<"levels", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * levels findUnique
   */
  export type levelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels findUniqueOrThrow
   */
  export type levelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels findFirst
   */
  export type levelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels findFirstOrThrow
   */
  export type levelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels findMany
   */
  export type levelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels create
   */
  export type levelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The data needed to create a levels.
     */
    data: XOR<levelsCreateInput, levelsUncheckedCreateInput>
  }

  /**
   * levels createMany
   */
  export type levelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many levels.
     */
    data: levelsCreateManyInput | levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * levels createManyAndReturn
   */
  export type levelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * The data used to create many levels.
     */
    data: levelsCreateManyInput | levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * levels update
   */
  export type levelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The data needed to update a levels.
     */
    data: XOR<levelsUpdateInput, levelsUncheckedUpdateInput>
    /**
     * Choose, which levels to update.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels updateMany
   */
  export type levelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update levels.
     */
    data: XOR<levelsUpdateManyMutationInput, levelsUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     */
    where?: levelsWhereInput
    /**
     * Limit how many levels to update.
     */
    limit?: number
  }

  /**
   * levels updateManyAndReturn
   */
  export type levelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * The data used to update levels.
     */
    data: XOR<levelsUpdateManyMutationInput, levelsUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     */
    where?: levelsWhereInput
    /**
     * Limit how many levels to update.
     */
    limit?: number
  }

  /**
   * levels upsert
   */
  export type levelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The filter to search for the levels to update in case it exists.
     */
    where: levelsWhereUniqueInput
    /**
     * In case the levels found by the `where` argument doesn't exist, create a new levels with this data.
     */
    create: XOR<levelsCreateInput, levelsUncheckedCreateInput>
    /**
     * In case the levels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<levelsUpdateInput, levelsUncheckedUpdateInput>
  }

  /**
   * levels delete
   */
  export type levelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter which levels to delete.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels deleteMany
   */
  export type levelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which levels to delete
     */
    where?: levelsWhereInput
    /**
     * Limit how many levels to delete.
     */
    limit?: number
  }

  /**
   * levels.students
   */
  export type levels$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * levels without action
   */
  export type levelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
  }


  /**
   * Model parent_children
   */

  export type AggregateParent_children = {
    _count: Parent_childrenCountAggregateOutputType | null
    _avg: Parent_childrenAvgAggregateOutputType | null
    _sum: Parent_childrenSumAggregateOutputType | null
    _min: Parent_childrenMinAggregateOutputType | null
    _max: Parent_childrenMaxAggregateOutputType | null
  }

  export type Parent_childrenAvgAggregateOutputType = {
    id: number | null
    parent_user_id: number | null
    student_user_id: number | null
  }

  export type Parent_childrenSumAggregateOutputType = {
    id: number | null
    parent_user_id: number | null
    student_user_id: number | null
  }

  export type Parent_childrenMinAggregateOutputType = {
    id: number | null
    parent_user_id: number | null
    student_user_id: number | null
  }

  export type Parent_childrenMaxAggregateOutputType = {
    id: number | null
    parent_user_id: number | null
    student_user_id: number | null
  }

  export type Parent_childrenCountAggregateOutputType = {
    id: number
    parent_user_id: number
    student_user_id: number
    _all: number
  }


  export type Parent_childrenAvgAggregateInputType = {
    id?: true
    parent_user_id?: true
    student_user_id?: true
  }

  export type Parent_childrenSumAggregateInputType = {
    id?: true
    parent_user_id?: true
    student_user_id?: true
  }

  export type Parent_childrenMinAggregateInputType = {
    id?: true
    parent_user_id?: true
    student_user_id?: true
  }

  export type Parent_childrenMaxAggregateInputType = {
    id?: true
    parent_user_id?: true
    student_user_id?: true
  }

  export type Parent_childrenCountAggregateInputType = {
    id?: true
    parent_user_id?: true
    student_user_id?: true
    _all?: true
  }

  export type Parent_childrenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_children to aggregate.
     */
    where?: parent_childrenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_children to fetch.
     */
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parent_childrenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parent_children
    **/
    _count?: true | Parent_childrenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parent_childrenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parent_childrenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parent_childrenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parent_childrenMaxAggregateInputType
  }

  export type GetParent_childrenAggregateType<T extends Parent_childrenAggregateArgs> = {
        [P in keyof T & keyof AggregateParent_children]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent_children[P]>
      : GetScalarType<T[P], AggregateParent_children[P]>
  }




  export type parent_childrenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_childrenWhereInput
    orderBy?: parent_childrenOrderByWithAggregationInput | parent_childrenOrderByWithAggregationInput[]
    by: Parent_childrenScalarFieldEnum[] | Parent_childrenScalarFieldEnum
    having?: parent_childrenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parent_childrenCountAggregateInputType | true
    _avg?: Parent_childrenAvgAggregateInputType
    _sum?: Parent_childrenSumAggregateInputType
    _min?: Parent_childrenMinAggregateInputType
    _max?: Parent_childrenMaxAggregateInputType
  }

  export type Parent_childrenGroupByOutputType = {
    id: number
    parent_user_id: number
    student_user_id: number
    _count: Parent_childrenCountAggregateOutputType | null
    _avg: Parent_childrenAvgAggregateOutputType | null
    _sum: Parent_childrenSumAggregateOutputType | null
    _min: Parent_childrenMinAggregateOutputType | null
    _max: Parent_childrenMaxAggregateOutputType | null
  }

  type GetParent_childrenGroupByPayload<T extends parent_childrenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parent_childrenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parent_childrenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parent_childrenGroupByOutputType[P]>
            : GetScalarType<T[P], Parent_childrenGroupByOutputType[P]>
        }
      >
    >


  export type parent_childrenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_user_id?: boolean
    student_user_id?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent_children"]>

  export type parent_childrenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_user_id?: boolean
    student_user_id?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent_children"]>

  export type parent_childrenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_user_id?: boolean
    student_user_id?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent_children"]>

  export type parent_childrenSelectScalar = {
    id?: boolean
    parent_user_id?: boolean
    student_user_id?: boolean
  }

  export type parent_childrenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parent_user_id" | "student_user_id", ExtArgs["result"]["parent_children"]>
  export type parent_childrenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type parent_childrenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type parent_childrenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $parent_childrenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parent_children"
    objects: {
      parents: Prisma.$parentsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parent_user_id: number
      student_user_id: number
    }, ExtArgs["result"]["parent_children"]>
    composites: {}
  }

  type parent_childrenGetPayload<S extends boolean | null | undefined | parent_childrenDefaultArgs> = $Result.GetResult<Prisma.$parent_childrenPayload, S>

  type parent_childrenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parent_childrenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Parent_childrenCountAggregateInputType | true
    }

  export interface parent_childrenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parent_children'], meta: { name: 'parent_children' } }
    /**
     * Find zero or one Parent_children that matches the filter.
     * @param {parent_childrenFindUniqueArgs} args - Arguments to find a Parent_children
     * @example
     * // Get one Parent_children
     * const parent_children = await prisma.parent_children.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parent_childrenFindUniqueArgs>(args: SelectSubset<T, parent_childrenFindUniqueArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent_children that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parent_childrenFindUniqueOrThrowArgs} args - Arguments to find a Parent_children
     * @example
     * // Get one Parent_children
     * const parent_children = await prisma.parent_children.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parent_childrenFindUniqueOrThrowArgs>(args: SelectSubset<T, parent_childrenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent_children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenFindFirstArgs} args - Arguments to find a Parent_children
     * @example
     * // Get one Parent_children
     * const parent_children = await prisma.parent_children.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parent_childrenFindFirstArgs>(args?: SelectSubset<T, parent_childrenFindFirstArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent_children that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenFindFirstOrThrowArgs} args - Arguments to find a Parent_children
     * @example
     * // Get one Parent_children
     * const parent_children = await prisma.parent_children.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parent_childrenFindFirstOrThrowArgs>(args?: SelectSubset<T, parent_childrenFindFirstOrThrowArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parent_children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parent_children
     * const parent_children = await prisma.parent_children.findMany()
     * 
     * // Get first 10 Parent_children
     * const parent_children = await prisma.parent_children.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parent_childrenWithIdOnly = await prisma.parent_children.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parent_childrenFindManyArgs>(args?: SelectSubset<T, parent_childrenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent_children.
     * @param {parent_childrenCreateArgs} args - Arguments to create a Parent_children.
     * @example
     * // Create one Parent_children
     * const Parent_children = await prisma.parent_children.create({
     *   data: {
     *     // ... data to create a Parent_children
     *   }
     * })
     * 
     */
    create<T extends parent_childrenCreateArgs>(args: SelectSubset<T, parent_childrenCreateArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parent_children.
     * @param {parent_childrenCreateManyArgs} args - Arguments to create many Parent_children.
     * @example
     * // Create many Parent_children
     * const parent_children = await prisma.parent_children.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parent_childrenCreateManyArgs>(args?: SelectSubset<T, parent_childrenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parent_children and returns the data saved in the database.
     * @param {parent_childrenCreateManyAndReturnArgs} args - Arguments to create many Parent_children.
     * @example
     * // Create many Parent_children
     * const parent_children = await prisma.parent_children.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parent_children and only return the `id`
     * const parent_childrenWithIdOnly = await prisma.parent_children.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parent_childrenCreateManyAndReturnArgs>(args?: SelectSubset<T, parent_childrenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parent_children.
     * @param {parent_childrenDeleteArgs} args - Arguments to delete one Parent_children.
     * @example
     * // Delete one Parent_children
     * const Parent_children = await prisma.parent_children.delete({
     *   where: {
     *     // ... filter to delete one Parent_children
     *   }
     * })
     * 
     */
    delete<T extends parent_childrenDeleteArgs>(args: SelectSubset<T, parent_childrenDeleteArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent_children.
     * @param {parent_childrenUpdateArgs} args - Arguments to update one Parent_children.
     * @example
     * // Update one Parent_children
     * const parent_children = await prisma.parent_children.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parent_childrenUpdateArgs>(args: SelectSubset<T, parent_childrenUpdateArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parent_children.
     * @param {parent_childrenDeleteManyArgs} args - Arguments to filter Parent_children to delete.
     * @example
     * // Delete a few Parent_children
     * const { count } = await prisma.parent_children.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parent_childrenDeleteManyArgs>(args?: SelectSubset<T, parent_childrenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parent_children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parent_children
     * const parent_children = await prisma.parent_children.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parent_childrenUpdateManyArgs>(args: SelectSubset<T, parent_childrenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parent_children and returns the data updated in the database.
     * @param {parent_childrenUpdateManyAndReturnArgs} args - Arguments to update many Parent_children.
     * @example
     * // Update many Parent_children
     * const parent_children = await prisma.parent_children.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parent_children and only return the `id`
     * const parent_childrenWithIdOnly = await prisma.parent_children.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends parent_childrenUpdateManyAndReturnArgs>(args: SelectSubset<T, parent_childrenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parent_children.
     * @param {parent_childrenUpsertArgs} args - Arguments to update or create a Parent_children.
     * @example
     * // Update or create a Parent_children
     * const parent_children = await prisma.parent_children.upsert({
     *   create: {
     *     // ... data to create a Parent_children
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent_children we want to update
     *   }
     * })
     */
    upsert<T extends parent_childrenUpsertArgs>(args: SelectSubset<T, parent_childrenUpsertArgs<ExtArgs>>): Prisma__parent_childrenClient<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parent_children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenCountArgs} args - Arguments to filter Parent_children to count.
     * @example
     * // Count the number of Parent_children
     * const count = await prisma.parent_children.count({
     *   where: {
     *     // ... the filter for the Parent_children we want to count
     *   }
     * })
    **/
    count<T extends parent_childrenCountArgs>(
      args?: Subset<T, parent_childrenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parent_childrenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent_children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parent_childrenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parent_childrenAggregateArgs>(args: Subset<T, Parent_childrenAggregateArgs>): Prisma.PrismaPromise<GetParent_childrenAggregateType<T>>

    /**
     * Group by Parent_children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_childrenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parent_childrenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parent_childrenGroupByArgs['orderBy'] }
        : { orderBy?: parent_childrenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parent_childrenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParent_childrenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parent_children model
   */
  readonly fields: parent_childrenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parent_children.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parent_childrenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends parentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentsDefaultArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parent_children model
   */
  interface parent_childrenFieldRefs {
    readonly id: FieldRef<"parent_children", 'Int'>
    readonly parent_user_id: FieldRef<"parent_children", 'Int'>
    readonly student_user_id: FieldRef<"parent_children", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * parent_children findUnique
   */
  export type parent_childrenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter, which parent_children to fetch.
     */
    where: parent_childrenWhereUniqueInput
  }

  /**
   * parent_children findUniqueOrThrow
   */
  export type parent_childrenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter, which parent_children to fetch.
     */
    where: parent_childrenWhereUniqueInput
  }

  /**
   * parent_children findFirst
   */
  export type parent_childrenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter, which parent_children to fetch.
     */
    where?: parent_childrenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_children to fetch.
     */
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_children.
     */
    cursor?: parent_childrenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_children.
     */
    distinct?: Parent_childrenScalarFieldEnum | Parent_childrenScalarFieldEnum[]
  }

  /**
   * parent_children findFirstOrThrow
   */
  export type parent_childrenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter, which parent_children to fetch.
     */
    where?: parent_childrenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_children to fetch.
     */
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_children.
     */
    cursor?: parent_childrenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_children.
     */
    distinct?: Parent_childrenScalarFieldEnum | Parent_childrenScalarFieldEnum[]
  }

  /**
   * parent_children findMany
   */
  export type parent_childrenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter, which parent_children to fetch.
     */
    where?: parent_childrenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_children to fetch.
     */
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parent_children.
     */
    cursor?: parent_childrenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_children.
     */
    skip?: number
    distinct?: Parent_childrenScalarFieldEnum | Parent_childrenScalarFieldEnum[]
  }

  /**
   * parent_children create
   */
  export type parent_childrenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * The data needed to create a parent_children.
     */
    data: XOR<parent_childrenCreateInput, parent_childrenUncheckedCreateInput>
  }

  /**
   * parent_children createMany
   */
  export type parent_childrenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parent_children.
     */
    data: parent_childrenCreateManyInput | parent_childrenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parent_children createManyAndReturn
   */
  export type parent_childrenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * The data used to create many parent_children.
     */
    data: parent_childrenCreateManyInput | parent_childrenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parent_children update
   */
  export type parent_childrenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * The data needed to update a parent_children.
     */
    data: XOR<parent_childrenUpdateInput, parent_childrenUncheckedUpdateInput>
    /**
     * Choose, which parent_children to update.
     */
    where: parent_childrenWhereUniqueInput
  }

  /**
   * parent_children updateMany
   */
  export type parent_childrenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parent_children.
     */
    data: XOR<parent_childrenUpdateManyMutationInput, parent_childrenUncheckedUpdateManyInput>
    /**
     * Filter which parent_children to update
     */
    where?: parent_childrenWhereInput
    /**
     * Limit how many parent_children to update.
     */
    limit?: number
  }

  /**
   * parent_children updateManyAndReturn
   */
  export type parent_childrenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * The data used to update parent_children.
     */
    data: XOR<parent_childrenUpdateManyMutationInput, parent_childrenUncheckedUpdateManyInput>
    /**
     * Filter which parent_children to update
     */
    where?: parent_childrenWhereInput
    /**
     * Limit how many parent_children to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * parent_children upsert
   */
  export type parent_childrenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * The filter to search for the parent_children to update in case it exists.
     */
    where: parent_childrenWhereUniqueInput
    /**
     * In case the parent_children found by the `where` argument doesn't exist, create a new parent_children with this data.
     */
    create: XOR<parent_childrenCreateInput, parent_childrenUncheckedCreateInput>
    /**
     * In case the parent_children was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parent_childrenUpdateInput, parent_childrenUncheckedUpdateInput>
  }

  /**
   * parent_children delete
   */
  export type parent_childrenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    /**
     * Filter which parent_children to delete.
     */
    where: parent_childrenWhereUniqueInput
  }

  /**
   * parent_children deleteMany
   */
  export type parent_childrenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_children to delete
     */
    where?: parent_childrenWhereInput
    /**
     * Limit how many parent_children to delete.
     */
    limit?: number
  }

  /**
   * parent_children without action
   */
  export type parent_childrenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
  }


  /**
   * Model parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsAvgAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
  }

  export type ParentsSumAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
  }

  export type ParentsMinAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
  }

  export type ParentsMaxAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
  }

  export type ParentsCountAggregateOutputType = {
    user_id: number
    government_id: number
    zone_id: number
    _all: number
  }


  export type ParentsAvgAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
  }

  export type ParentsSumAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
  }

  export type ParentsMinAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
  }

  export type ParentsMaxAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
  }

  export type ParentsCountAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to aggregate.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type parentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithAggregationInput | parentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: parentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _avg?: ParentsAvgAggregateInputType
    _sum?: ParentsSumAggregateInputType
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    user_id: number
    government_id: number | null
    zone_id: number | null
    _count: ParentsCountAggregateOutputType | null
    _avg: ParentsAvgAggregateOutputType | null
    _sum: ParentsSumAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends parentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type parentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    parent_children?: boolean | parents$parent_childrenArgs<ExtArgs>
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectScalar = {
    user_id?: boolean
    government_id?: boolean
    zone_id?: boolean
  }

  export type parentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "government_id" | "zone_id", ExtArgs["result"]["parents"]>
  export type parentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent_children?: boolean | parents$parent_childrenArgs<ExtArgs>
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type parentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
  }
  export type parentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | parents$governmentArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | parents$zonesArgs<ExtArgs>
  }

  export type $parentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parents"
    objects: {
      parent_children: Prisma.$parent_childrenPayload<ExtArgs>[]
      government: Prisma.$governmentPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      zones: Prisma.$zonesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      government_id: number | null
      zone_id: number | null
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type parentsGetPayload<S extends boolean | null | undefined | parentsDefaultArgs> = $Result.GetResult<Prisma.$parentsPayload, S>

  type parentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface parentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parents'], meta: { name: 'parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {parentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parentsFindUniqueArgs>(args: SelectSubset<T, parentsFindUniqueArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parentsFindUniqueOrThrowArgs>(args: SelectSubset<T, parentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parentsFindFirstArgs>(args?: SelectSubset<T, parentsFindFirstArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parentsFindFirstOrThrowArgs>(args?: SelectSubset<T, parentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const parentsWithUser_idOnly = await prisma.parents.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends parentsFindManyArgs>(args?: SelectSubset<T, parentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parents.
     * @param {parentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends parentsCreateArgs>(args: SelectSubset<T, parentsCreateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {parentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parentsCreateManyArgs>(args?: SelectSubset<T, parentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {parentsCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `user_id`
     * const parentsWithUser_idOnly = await prisma.parents.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parentsCreateManyAndReturnArgs>(args?: SelectSubset<T, parentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parents.
     * @param {parentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends parentsDeleteArgs>(args: SelectSubset<T, parentsDeleteArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parents.
     * @param {parentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parentsUpdateArgs>(args: SelectSubset<T, parentsUpdateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {parentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parentsDeleteManyArgs>(args?: SelectSubset<T, parentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parentsUpdateManyArgs>(args: SelectSubset<T, parentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {parentsUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `user_id`
     * const parentsWithUser_idOnly = await prisma.parents.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends parentsUpdateManyAndReturnArgs>(args: SelectSubset<T, parentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parents.
     * @param {parentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends parentsUpsertArgs>(args: SelectSubset<T, parentsUpsertArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends parentsCountArgs>(
      args?: Subset<T, parentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parentsGroupByArgs['orderBy'] }
        : { orderBy?: parentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parents model
   */
  readonly fields: parentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent_children<T extends parents$parent_childrenArgs<ExtArgs> = {}>(args?: Subset<T, parents$parent_childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    government<T extends parents$governmentArgs<ExtArgs> = {}>(args?: Subset<T, parents$governmentArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zones<T extends parents$zonesArgs<ExtArgs> = {}>(args?: Subset<T, parents$zonesArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parents model
   */
  interface parentsFieldRefs {
    readonly user_id: FieldRef<"parents", 'Int'>
    readonly government_id: FieldRef<"parents", 'Int'>
    readonly zone_id: FieldRef<"parents", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * parents findUnique
   */
  export type parentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findUniqueOrThrow
   */
  export type parentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findFirst
   */
  export type parentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findFirstOrThrow
   */
  export type parentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findMany
   */
  export type parentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents create
   */
  export type parentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to create a parents.
     */
    data: XOR<parentsCreateInput, parentsUncheckedCreateInput>
  }

  /**
   * parents createMany
   */
  export type parentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parents createManyAndReturn
   */
  export type parentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parents update
   */
  export type parentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to update a parents.
     */
    data: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
    /**
     * Choose, which parents to update.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents updateMany
   */
  export type parentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to update.
     */
    limit?: number
  }

  /**
   * parents updateManyAndReturn
   */
  export type parentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * parents upsert
   */
  export type parentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The filter to search for the parents to update in case it exists.
     */
    where: parentsWhereUniqueInput
    /**
     * In case the parents found by the `where` argument doesn't exist, create a new parents with this data.
     */
    create: XOR<parentsCreateInput, parentsUncheckedCreateInput>
    /**
     * In case the parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
  }

  /**
   * parents delete
   */
  export type parentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter which parents to delete.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents deleteMany
   */
  export type parentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to delete
     */
    where?: parentsWhereInput
    /**
     * Limit how many parents to delete.
     */
    limit?: number
  }

  /**
   * parents.parent_children
   */
  export type parents$parent_childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    where?: parent_childrenWhereInput
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    cursor?: parent_childrenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Parent_childrenScalarFieldEnum | Parent_childrenScalarFieldEnum[]
  }

  /**
   * parents.government
   */
  export type parents$governmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    where?: governmentWhereInput
  }

  /**
   * parents.zones
   */
  export type parents$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    where?: zonesWhereInput
  }

  /**
   * parents without action
   */
  export type parentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
  }


  /**
   * Model sites
   */

  export type AggregateSites = {
    _count: SitesCountAggregateOutputType | null
    _avg: SitesAvgAggregateOutputType | null
    _sum: SitesSumAggregateOutputType | null
    _min: SitesMinAggregateOutputType | null
    _max: SitesMaxAggregateOutputType | null
  }

  export type SitesAvgAggregateOutputType = {
    id: number | null
  }

  export type SitesSumAggregateOutputType = {
    id: number | null
  }

  export type SitesMinAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type SitesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type SitesCountAggregateOutputType = {
    id: number
    title: number
    active: number
    _all: number
  }


  export type SitesAvgAggregateInputType = {
    id?: true
  }

  export type SitesSumAggregateInputType = {
    id?: true
  }

  export type SitesMinAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type SitesMaxAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type SitesCountAggregateInputType = {
    id?: true
    title?: true
    active?: true
    _all?: true
  }

  export type SitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sites to aggregate.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sites
    **/
    _count?: true | SitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitesMaxAggregateInputType
  }

  export type GetSitesAggregateType<T extends SitesAggregateArgs> = {
        [P in keyof T & keyof AggregateSites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSites[P]>
      : GetScalarType<T[P], AggregateSites[P]>
  }




  export type sitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sitesWhereInput
    orderBy?: sitesOrderByWithAggregationInput | sitesOrderByWithAggregationInput[]
    by: SitesScalarFieldEnum[] | SitesScalarFieldEnum
    having?: sitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitesCountAggregateInputType | true
    _avg?: SitesAvgAggregateInputType
    _sum?: SitesSumAggregateInputType
    _min?: SitesMinAggregateInputType
    _max?: SitesMaxAggregateInputType
  }

  export type SitesGroupByOutputType = {
    id: number
    title: string
    active: boolean | null
    _count: SitesCountAggregateOutputType | null
    _avg: SitesAvgAggregateOutputType | null
    _sum: SitesSumAggregateOutputType | null
    _min: SitesMinAggregateOutputType | null
    _max: SitesMaxAggregateOutputType | null
  }

  type GetSitesGroupByPayload<T extends sitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitesGroupByOutputType[P]>
            : GetScalarType<T[P], SitesGroupByOutputType[P]>
        }
      >
    >


  export type sitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
    social_media?: boolean | sites$social_mediaArgs<ExtArgs>
    _count?: boolean | SitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["sites"]>

  export type sitesSelectScalar = {
    id?: boolean
    title?: boolean
    active?: boolean
  }

  export type sitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "active", ExtArgs["result"]["sites"]>
  export type sitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social_media?: boolean | sites$social_mediaArgs<ExtArgs>
    _count?: boolean | SitesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type sitesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $sitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sites"
    objects: {
      social_media: Prisma.$social_mediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      active: boolean | null
    }, ExtArgs["result"]["sites"]>
    composites: {}
  }

  type sitesGetPayload<S extends boolean | null | undefined | sitesDefaultArgs> = $Result.GetResult<Prisma.$sitesPayload, S>

  type sitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SitesCountAggregateInputType | true
    }

  export interface sitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sites'], meta: { name: 'sites' } }
    /**
     * Find zero or one Sites that matches the filter.
     * @param {sitesFindUniqueArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sitesFindUniqueArgs>(args: SelectSubset<T, sitesFindUniqueArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sitesFindUniqueOrThrowArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sitesFindUniqueOrThrowArgs>(args: SelectSubset<T, sitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindFirstArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sitesFindFirstArgs>(args?: SelectSubset<T, sitesFindFirstArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindFirstOrThrowArgs} args - Arguments to find a Sites
     * @example
     * // Get one Sites
     * const sites = await prisma.sites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sitesFindFirstOrThrowArgs>(args?: SelectSubset<T, sitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.sites.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.sites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitesWithIdOnly = await prisma.sites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sitesFindManyArgs>(args?: SelectSubset<T, sitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sites.
     * @param {sitesCreateArgs} args - Arguments to create a Sites.
     * @example
     * // Create one Sites
     * const Sites = await prisma.sites.create({
     *   data: {
     *     // ... data to create a Sites
     *   }
     * })
     * 
     */
    create<T extends sitesCreateArgs>(args: SelectSubset<T, sitesCreateArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sites.
     * @param {sitesCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const sites = await prisma.sites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sitesCreateManyArgs>(args?: SelectSubset<T, sitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {sitesCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const sites = await prisma.sites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const sitesWithIdOnly = await prisma.sites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sitesCreateManyAndReturnArgs>(args?: SelectSubset<T, sitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sites.
     * @param {sitesDeleteArgs} args - Arguments to delete one Sites.
     * @example
     * // Delete one Sites
     * const Sites = await prisma.sites.delete({
     *   where: {
     *     // ... filter to delete one Sites
     *   }
     * })
     * 
     */
    delete<T extends sitesDeleteArgs>(args: SelectSubset<T, sitesDeleteArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sites.
     * @param {sitesUpdateArgs} args - Arguments to update one Sites.
     * @example
     * // Update one Sites
     * const sites = await prisma.sites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sitesUpdateArgs>(args: SelectSubset<T, sitesUpdateArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sites.
     * @param {sitesDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.sites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sitesDeleteManyArgs>(args?: SelectSubset<T, sitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const sites = await prisma.sites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sitesUpdateManyArgs>(args: SelectSubset<T, sitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites and returns the data updated in the database.
     * @param {sitesUpdateManyAndReturnArgs} args - Arguments to update many Sites.
     * @example
     * // Update many Sites
     * const sites = await prisma.sites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sites and only return the `id`
     * const sitesWithIdOnly = await prisma.sites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sitesUpdateManyAndReturnArgs>(args: SelectSubset<T, sitesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sites.
     * @param {sitesUpsertArgs} args - Arguments to update or create a Sites.
     * @example
     * // Update or create a Sites
     * const sites = await prisma.sites.upsert({
     *   create: {
     *     // ... data to create a Sites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sites we want to update
     *   }
     * })
     */
    upsert<T extends sitesUpsertArgs>(args: SelectSubset<T, sitesUpsertArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.sites.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends sitesCountArgs>(
      args?: Subset<T, sitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitesAggregateArgs>(args: Subset<T, SitesAggregateArgs>): Prisma.PrismaPromise<GetSitesAggregateType<T>>

    /**
     * Group by Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sitesGroupByArgs['orderBy'] }
        : { orderBy?: sitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sites model
   */
  readonly fields: sitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    social_media<T extends sites$social_mediaArgs<ExtArgs> = {}>(args?: Subset<T, sites$social_mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sites model
   */
  interface sitesFieldRefs {
    readonly id: FieldRef<"sites", 'Int'>
    readonly title: FieldRef<"sites", 'String'>
    readonly active: FieldRef<"sites", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * sites findUnique
   */
  export type sitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites findUniqueOrThrow
   */
  export type sitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites findFirst
   */
  export type sitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sites.
     */
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites findFirstOrThrow
   */
  export type sitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sites.
     */
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites findMany
   */
  export type sitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter, which sites to fetch.
     */
    where?: sitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sites to fetch.
     */
    orderBy?: sitesOrderByWithRelationInput | sitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sites.
     */
    cursor?: sitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sites.
     */
    skip?: number
    distinct?: SitesScalarFieldEnum | SitesScalarFieldEnum[]
  }

  /**
   * sites create
   */
  export type sitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The data needed to create a sites.
     */
    data: XOR<sitesCreateInput, sitesUncheckedCreateInput>
  }

  /**
   * sites createMany
   */
  export type sitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sites.
     */
    data: sitesCreateManyInput | sitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sites createManyAndReturn
   */
  export type sitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * The data used to create many sites.
     */
    data: sitesCreateManyInput | sitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sites update
   */
  export type sitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The data needed to update a sites.
     */
    data: XOR<sitesUpdateInput, sitesUncheckedUpdateInput>
    /**
     * Choose, which sites to update.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites updateMany
   */
  export type sitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sites.
     */
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyInput>
    /**
     * Filter which sites to update
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to update.
     */
    limit?: number
  }

  /**
   * sites updateManyAndReturn
   */
  export type sitesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * The data used to update sites.
     */
    data: XOR<sitesUpdateManyMutationInput, sitesUncheckedUpdateManyInput>
    /**
     * Filter which sites to update
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to update.
     */
    limit?: number
  }

  /**
   * sites upsert
   */
  export type sitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * The filter to search for the sites to update in case it exists.
     */
    where: sitesWhereUniqueInput
    /**
     * In case the sites found by the `where` argument doesn't exist, create a new sites with this data.
     */
    create: XOR<sitesCreateInput, sitesUncheckedCreateInput>
    /**
     * In case the sites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sitesUpdateInput, sitesUncheckedUpdateInput>
  }

  /**
   * sites delete
   */
  export type sitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    /**
     * Filter which sites to delete.
     */
    where: sitesWhereUniqueInput
  }

  /**
   * sites deleteMany
   */
  export type sitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sites to delete
     */
    where?: sitesWhereInput
    /**
     * Limit how many sites to delete.
     */
    limit?: number
  }

  /**
   * sites.social_media
   */
  export type sites$social_mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    where?: social_mediaWhereInput
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    cursor?: social_mediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Social_mediaScalarFieldEnum | Social_mediaScalarFieldEnum[]
  }

  /**
   * sites without action
   */
  export type sitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
  }


  /**
   * Model social_media
   */

  export type AggregateSocial_media = {
    _count: Social_mediaCountAggregateOutputType | null
    _avg: Social_mediaAvgAggregateOutputType | null
    _sum: Social_mediaSumAggregateOutputType | null
    _min: Social_mediaMinAggregateOutputType | null
    _max: Social_mediaMaxAggregateOutputType | null
  }

  export type Social_mediaAvgAggregateOutputType = {
    id: number | null
    teacher_user_id: number | null
    site_id: number | null
  }

  export type Social_mediaSumAggregateOutputType = {
    id: number | null
    teacher_user_id: number | null
    site_id: number | null
  }

  export type Social_mediaMinAggregateOutputType = {
    id: number | null
    teacher_user_id: number | null
    site_id: number | null
    url: string | null
    active: boolean | null
  }

  export type Social_mediaMaxAggregateOutputType = {
    id: number | null
    teacher_user_id: number | null
    site_id: number | null
    url: string | null
    active: boolean | null
  }

  export type Social_mediaCountAggregateOutputType = {
    id: number
    teacher_user_id: number
    site_id: number
    url: number
    active: number
    _all: number
  }


  export type Social_mediaAvgAggregateInputType = {
    id?: true
    teacher_user_id?: true
    site_id?: true
  }

  export type Social_mediaSumAggregateInputType = {
    id?: true
    teacher_user_id?: true
    site_id?: true
  }

  export type Social_mediaMinAggregateInputType = {
    id?: true
    teacher_user_id?: true
    site_id?: true
    url?: true
    active?: true
  }

  export type Social_mediaMaxAggregateInputType = {
    id?: true
    teacher_user_id?: true
    site_id?: true
    url?: true
    active?: true
  }

  export type Social_mediaCountAggregateInputType = {
    id?: true
    teacher_user_id?: true
    site_id?: true
    url?: true
    active?: true
    _all?: true
  }

  export type Social_mediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_media to aggregate.
     */
    where?: social_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_medias to fetch.
     */
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: social_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned social_medias
    **/
    _count?: true | Social_mediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Social_mediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Social_mediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Social_mediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Social_mediaMaxAggregateInputType
  }

  export type GetSocial_mediaAggregateType<T extends Social_mediaAggregateArgs> = {
        [P in keyof T & keyof AggregateSocial_media]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocial_media[P]>
      : GetScalarType<T[P], AggregateSocial_media[P]>
  }




  export type social_mediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_mediaWhereInput
    orderBy?: social_mediaOrderByWithAggregationInput | social_mediaOrderByWithAggregationInput[]
    by: Social_mediaScalarFieldEnum[] | Social_mediaScalarFieldEnum
    having?: social_mediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Social_mediaCountAggregateInputType | true
    _avg?: Social_mediaAvgAggregateInputType
    _sum?: Social_mediaSumAggregateInputType
    _min?: Social_mediaMinAggregateInputType
    _max?: Social_mediaMaxAggregateInputType
  }

  export type Social_mediaGroupByOutputType = {
    id: number
    teacher_user_id: number
    site_id: number | null
    url: string
    active: boolean | null
    _count: Social_mediaCountAggregateOutputType | null
    _avg: Social_mediaAvgAggregateOutputType | null
    _sum: Social_mediaSumAggregateOutputType | null
    _min: Social_mediaMinAggregateOutputType | null
    _max: Social_mediaMaxAggregateOutputType | null
  }

  type GetSocial_mediaGroupByPayload<T extends social_mediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Social_mediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Social_mediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Social_mediaGroupByOutputType[P]>
            : GetScalarType<T[P], Social_mediaGroupByOutputType[P]>
        }
      >
    >


  export type social_mediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_user_id?: boolean
    site_id?: boolean
    url?: boolean
    active?: boolean
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_media"]>

  export type social_mediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_user_id?: boolean
    site_id?: boolean
    url?: boolean
    active?: boolean
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_media"]>

  export type social_mediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_user_id?: boolean
    site_id?: boolean
    url?: boolean
    active?: boolean
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_media"]>

  export type social_mediaSelectScalar = {
    id?: boolean
    teacher_user_id?: boolean
    site_id?: boolean
    url?: boolean
    active?: boolean
  }

  export type social_mediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_user_id" | "site_id" | "url" | "active", ExtArgs["result"]["social_media"]>
  export type social_mediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type social_mediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type social_mediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sites?: boolean | social_media$sitesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $social_mediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "social_media"
    objects: {
      sites: Prisma.$sitesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_user_id: number
      site_id: number | null
      url: string
      active: boolean | null
    }, ExtArgs["result"]["social_media"]>
    composites: {}
  }

  type social_mediaGetPayload<S extends boolean | null | undefined | social_mediaDefaultArgs> = $Result.GetResult<Prisma.$social_mediaPayload, S>

  type social_mediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<social_mediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Social_mediaCountAggregateInputType | true
    }

  export interface social_mediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['social_media'], meta: { name: 'social_media' } }
    /**
     * Find zero or one Social_media that matches the filter.
     * @param {social_mediaFindUniqueArgs} args - Arguments to find a Social_media
     * @example
     * // Get one Social_media
     * const social_media = await prisma.social_media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends social_mediaFindUniqueArgs>(args: SelectSubset<T, social_mediaFindUniqueArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Social_media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {social_mediaFindUniqueOrThrowArgs} args - Arguments to find a Social_media
     * @example
     * // Get one Social_media
     * const social_media = await prisma.social_media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends social_mediaFindUniqueOrThrowArgs>(args: SelectSubset<T, social_mediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaFindFirstArgs} args - Arguments to find a Social_media
     * @example
     * // Get one Social_media
     * const social_media = await prisma.social_media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends social_mediaFindFirstArgs>(args?: SelectSubset<T, social_mediaFindFirstArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social_media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaFindFirstOrThrowArgs} args - Arguments to find a Social_media
     * @example
     * // Get one Social_media
     * const social_media = await prisma.social_media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends social_mediaFindFirstOrThrowArgs>(args?: SelectSubset<T, social_mediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Social_medias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Social_medias
     * const social_medias = await prisma.social_media.findMany()
     * 
     * // Get first 10 Social_medias
     * const social_medias = await prisma.social_media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const social_mediaWithIdOnly = await prisma.social_media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends social_mediaFindManyArgs>(args?: SelectSubset<T, social_mediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Social_media.
     * @param {social_mediaCreateArgs} args - Arguments to create a Social_media.
     * @example
     * // Create one Social_media
     * const Social_media = await prisma.social_media.create({
     *   data: {
     *     // ... data to create a Social_media
     *   }
     * })
     * 
     */
    create<T extends social_mediaCreateArgs>(args: SelectSubset<T, social_mediaCreateArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Social_medias.
     * @param {social_mediaCreateManyArgs} args - Arguments to create many Social_medias.
     * @example
     * // Create many Social_medias
     * const social_media = await prisma.social_media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends social_mediaCreateManyArgs>(args?: SelectSubset<T, social_mediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Social_medias and returns the data saved in the database.
     * @param {social_mediaCreateManyAndReturnArgs} args - Arguments to create many Social_medias.
     * @example
     * // Create many Social_medias
     * const social_media = await prisma.social_media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Social_medias and only return the `id`
     * const social_mediaWithIdOnly = await prisma.social_media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends social_mediaCreateManyAndReturnArgs>(args?: SelectSubset<T, social_mediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Social_media.
     * @param {social_mediaDeleteArgs} args - Arguments to delete one Social_media.
     * @example
     * // Delete one Social_media
     * const Social_media = await prisma.social_media.delete({
     *   where: {
     *     // ... filter to delete one Social_media
     *   }
     * })
     * 
     */
    delete<T extends social_mediaDeleteArgs>(args: SelectSubset<T, social_mediaDeleteArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Social_media.
     * @param {social_mediaUpdateArgs} args - Arguments to update one Social_media.
     * @example
     * // Update one Social_media
     * const social_media = await prisma.social_media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends social_mediaUpdateArgs>(args: SelectSubset<T, social_mediaUpdateArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Social_medias.
     * @param {social_mediaDeleteManyArgs} args - Arguments to filter Social_medias to delete.
     * @example
     * // Delete a few Social_medias
     * const { count } = await prisma.social_media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends social_mediaDeleteManyArgs>(args?: SelectSubset<T, social_mediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Social_medias
     * const social_media = await prisma.social_media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends social_mediaUpdateManyArgs>(args: SelectSubset<T, social_mediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_medias and returns the data updated in the database.
     * @param {social_mediaUpdateManyAndReturnArgs} args - Arguments to update many Social_medias.
     * @example
     * // Update many Social_medias
     * const social_media = await prisma.social_media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Social_medias and only return the `id`
     * const social_mediaWithIdOnly = await prisma.social_media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends social_mediaUpdateManyAndReturnArgs>(args: SelectSubset<T, social_mediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Social_media.
     * @param {social_mediaUpsertArgs} args - Arguments to update or create a Social_media.
     * @example
     * // Update or create a Social_media
     * const social_media = await prisma.social_media.upsert({
     *   create: {
     *     // ... data to create a Social_media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Social_media we want to update
     *   }
     * })
     */
    upsert<T extends social_mediaUpsertArgs>(args: SelectSubset<T, social_mediaUpsertArgs<ExtArgs>>): Prisma__social_mediaClient<$Result.GetResult<Prisma.$social_mediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Social_medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaCountArgs} args - Arguments to filter Social_medias to count.
     * @example
     * // Count the number of Social_medias
     * const count = await prisma.social_media.count({
     *   where: {
     *     // ... the filter for the Social_medias we want to count
     *   }
     * })
    **/
    count<T extends social_mediaCountArgs>(
      args?: Subset<T, social_mediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Social_mediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Social_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Social_mediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Social_mediaAggregateArgs>(args: Subset<T, Social_mediaAggregateArgs>): Prisma.PrismaPromise<GetSocial_mediaAggregateType<T>>

    /**
     * Group by Social_media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_mediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends social_mediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: social_mediaGroupByArgs['orderBy'] }
        : { orderBy?: social_mediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, social_mediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocial_mediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the social_media model
   */
  readonly fields: social_mediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for social_media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__social_mediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sites<T extends social_media$sitesArgs<ExtArgs> = {}>(args?: Subset<T, social_media$sitesArgs<ExtArgs>>): Prisma__sitesClient<$Result.GetResult<Prisma.$sitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the social_media model
   */
  interface social_mediaFieldRefs {
    readonly id: FieldRef<"social_media", 'Int'>
    readonly teacher_user_id: FieldRef<"social_media", 'Int'>
    readonly site_id: FieldRef<"social_media", 'Int'>
    readonly url: FieldRef<"social_media", 'String'>
    readonly active: FieldRef<"social_media", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * social_media findUnique
   */
  export type social_mediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter, which social_media to fetch.
     */
    where: social_mediaWhereUniqueInput
  }

  /**
   * social_media findUniqueOrThrow
   */
  export type social_mediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter, which social_media to fetch.
     */
    where: social_mediaWhereUniqueInput
  }

  /**
   * social_media findFirst
   */
  export type social_mediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter, which social_media to fetch.
     */
    where?: social_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_medias to fetch.
     */
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_medias.
     */
    cursor?: social_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_medias.
     */
    distinct?: Social_mediaScalarFieldEnum | Social_mediaScalarFieldEnum[]
  }

  /**
   * social_media findFirstOrThrow
   */
  export type social_mediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter, which social_media to fetch.
     */
    where?: social_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_medias to fetch.
     */
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_medias.
     */
    cursor?: social_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_medias.
     */
    distinct?: Social_mediaScalarFieldEnum | Social_mediaScalarFieldEnum[]
  }

  /**
   * social_media findMany
   */
  export type social_mediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter, which social_medias to fetch.
     */
    where?: social_mediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_medias to fetch.
     */
    orderBy?: social_mediaOrderByWithRelationInput | social_mediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing social_medias.
     */
    cursor?: social_mediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_medias.
     */
    skip?: number
    distinct?: Social_mediaScalarFieldEnum | Social_mediaScalarFieldEnum[]
  }

  /**
   * social_media create
   */
  export type social_mediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * The data needed to create a social_media.
     */
    data: XOR<social_mediaCreateInput, social_mediaUncheckedCreateInput>
  }

  /**
   * social_media createMany
   */
  export type social_mediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many social_medias.
     */
    data: social_mediaCreateManyInput | social_mediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * social_media createManyAndReturn
   */
  export type social_mediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * The data used to create many social_medias.
     */
    data: social_mediaCreateManyInput | social_mediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_media update
   */
  export type social_mediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * The data needed to update a social_media.
     */
    data: XOR<social_mediaUpdateInput, social_mediaUncheckedUpdateInput>
    /**
     * Choose, which social_media to update.
     */
    where: social_mediaWhereUniqueInput
  }

  /**
   * social_media updateMany
   */
  export type social_mediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update social_medias.
     */
    data: XOR<social_mediaUpdateManyMutationInput, social_mediaUncheckedUpdateManyInput>
    /**
     * Filter which social_medias to update
     */
    where?: social_mediaWhereInput
    /**
     * Limit how many social_medias to update.
     */
    limit?: number
  }

  /**
   * social_media updateManyAndReturn
   */
  export type social_mediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * The data used to update social_medias.
     */
    data: XOR<social_mediaUpdateManyMutationInput, social_mediaUncheckedUpdateManyInput>
    /**
     * Filter which social_medias to update
     */
    where?: social_mediaWhereInput
    /**
     * Limit how many social_medias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_media upsert
   */
  export type social_mediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * The filter to search for the social_media to update in case it exists.
     */
    where: social_mediaWhereUniqueInput
    /**
     * In case the social_media found by the `where` argument doesn't exist, create a new social_media with this data.
     */
    create: XOR<social_mediaCreateInput, social_mediaUncheckedCreateInput>
    /**
     * In case the social_media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<social_mediaUpdateInput, social_mediaUncheckedUpdateInput>
  }

  /**
   * social_media delete
   */
  export type social_mediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
    /**
     * Filter which social_media to delete.
     */
    where: social_mediaWhereUniqueInput
  }

  /**
   * social_media deleteMany
   */
  export type social_mediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_medias to delete
     */
    where?: social_mediaWhereInput
    /**
     * Limit how many social_medias to delete.
     */
    limit?: number
  }

  /**
   * social_media.sites
   */
  export type social_media$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sites
     */
    select?: sitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sites
     */
    omit?: sitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sitesInclude<ExtArgs> | null
    where?: sitesWhereInput
  }

  /**
   * social_media without action
   */
  export type social_mediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_media
     */
    select?: social_mediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the social_media
     */
    omit?: social_mediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_mediaInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    user_id: number | null
    level_id: number | null
    government_id: number | null
    zone_id: number | null
    sequenced_id: number | null
  }

  export type StudentsSumAggregateOutputType = {
    user_id: number | null
    level_id: number | null
    government_id: number | null
    zone_id: number | null
    sequenced_id: number | null
  }

  export type StudentsMinAggregateOutputType = {
    user_id: number | null
    level_id: number | null
    government_id: number | null
    zone_id: number | null
    parent_phone_number: string | null
    sequenced_id: number | null
    faction: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    user_id: number | null
    level_id: number | null
    government_id: number | null
    zone_id: number | null
    parent_phone_number: string | null
    sequenced_id: number | null
    faction: string | null
  }

  export type StudentsCountAggregateOutputType = {
    user_id: number
    level_id: number
    government_id: number
    zone_id: number
    parent_phone_number: number
    sequenced_id: number
    faction: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    user_id?: true
    level_id?: true
    government_id?: true
    zone_id?: true
    sequenced_id?: true
  }

  export type StudentsSumAggregateInputType = {
    user_id?: true
    level_id?: true
    government_id?: true
    zone_id?: true
    sequenced_id?: true
  }

  export type StudentsMinAggregateInputType = {
    user_id?: true
    level_id?: true
    government_id?: true
    zone_id?: true
    parent_phone_number?: true
    sequenced_id?: true
    faction?: true
  }

  export type StudentsMaxAggregateInputType = {
    user_id?: true
    level_id?: true
    government_id?: true
    zone_id?: true
    parent_phone_number?: true
    sequenced_id?: true
    faction?: true
  }

  export type StudentsCountAggregateInputType = {
    user_id?: true
    level_id?: true
    government_id?: true
    zone_id?: true
    parent_phone_number?: true
    sequenced_id?: true
    faction?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    user_id: number
    level_id: number | null
    government_id: number | null
    zone_id: number | null
    parent_phone_number: string | null
    sequenced_id: number | null
    faction: string | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    level_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    parent_phone_number?: boolean
    sequenced_id?: boolean
    faction?: boolean
    parent_children?: boolean | students$parent_childrenArgs<ExtArgs>
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    level_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    parent_phone_number?: boolean
    sequenced_id?: boolean
    faction?: boolean
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    level_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    parent_phone_number?: boolean
    sequenced_id?: boolean
    faction?: boolean
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectScalar = {
    user_id?: boolean
    level_id?: boolean
    government_id?: boolean
    zone_id?: boolean
    parent_phone_number?: boolean
    sequenced_id?: boolean
    faction?: boolean
  }

  export type studentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "level_id" | "government_id" | "zone_id" | "parent_phone_number" | "sequenced_id" | "faction", ExtArgs["result"]["students"]>
  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent_children?: boolean | students$parent_childrenArgs<ExtArgs>
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
  }
  export type studentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | students$governmentArgs<ExtArgs>
    levels?: boolean | students$levelsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | students$zonesArgs<ExtArgs>
  }

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      parent_children: Prisma.$parent_childrenPayload<ExtArgs>[]
      government: Prisma.$governmentPayload<ExtArgs> | null
      levels: Prisma.$levelsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      zones: Prisma.$zonesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      level_id: number | null
      government_id: number | null
      zone_id: number | null
      parent_phone_number: string | null
      sequenced_id: number | null
      faction: string | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const studentsWithUser_idOnly = await prisma.students.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `user_id`
     * const studentsWithUser_idOnly = await prisma.students.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentsCreateManyAndReturnArgs>(args?: SelectSubset<T, studentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `user_id`
     * const studentsWithUser_idOnly = await prisma.students.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentsUpdateManyAndReturnArgs>(args: SelectSubset<T, studentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent_children<T extends students$parent_childrenArgs<ExtArgs> = {}>(args?: Subset<T, students$parent_childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_childrenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    government<T extends students$governmentArgs<ExtArgs> = {}>(args?: Subset<T, students$governmentArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    levels<T extends students$levelsArgs<ExtArgs> = {}>(args?: Subset<T, students$levelsArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zones<T extends students$zonesArgs<ExtArgs> = {}>(args?: Subset<T, students$zonesArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */
  interface studentsFieldRefs {
    readonly user_id: FieldRef<"students", 'Int'>
    readonly level_id: FieldRef<"students", 'Int'>
    readonly government_id: FieldRef<"students", 'Int'>
    readonly zone_id: FieldRef<"students", 'Int'>
    readonly parent_phone_number: FieldRef<"students", 'String'>
    readonly sequenced_id: FieldRef<"students", 'Int'>
    readonly faction: FieldRef<"students", 'String'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students createManyAndReturn
   */
  export type studentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * students updateManyAndReturn
   */
  export type studentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * students.parent_children
   */
  export type students$parent_childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_children
     */
    select?: parent_childrenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_children
     */
    omit?: parent_childrenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_childrenInclude<ExtArgs> | null
    where?: parent_childrenWhereInput
    orderBy?: parent_childrenOrderByWithRelationInput | parent_childrenOrderByWithRelationInput[]
    cursor?: parent_childrenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Parent_childrenScalarFieldEnum | Parent_childrenScalarFieldEnum[]
  }

  /**
   * students.government
   */
  export type students$governmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    where?: governmentWhereInput
  }

  /**
   * students.levels
   */
  export type students$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the levels
     */
    omit?: levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    where?: levelsWhereInput
  }

  /**
   * students.zones
   */
  export type students$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    where?: zonesWhereInput
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Model subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsAvgAggregateOutputType = {
    id: number | null
  }

  export type SubjectsSumAggregateOutputType = {
    id: number | null
  }

  export type SubjectsMinAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type SubjectsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    active: boolean | null
  }

  export type SubjectsCountAggregateOutputType = {
    id: number
    title: number
    active: number
    _all: number
  }


  export type SubjectsAvgAggregateInputType = {
    id?: true
  }

  export type SubjectsSumAggregateInputType = {
    id?: true
  }

  export type SubjectsMinAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type SubjectsMaxAggregateInputType = {
    id?: true
    title?: true
    active?: true
  }

  export type SubjectsCountAggregateInputType = {
    id?: true
    title?: true
    active?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to aggregate.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithAggregationInput | subjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _avg?: SubjectsAvgAggregateInputType
    _sum?: SubjectsSumAggregateInputType
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    id: number
    title: string
    active: boolean | null
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
    teachers?: boolean | subjects$teachersArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>

  export type subjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["subjects"]>

  export type subjectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    active?: boolean
  }, ExtArgs["result"]["subjects"]>

  export type subjectsSelectScalar = {
    id?: boolean
    title?: boolean
    active?: boolean
  }

  export type subjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "active", ExtArgs["result"]["subjects"]>
  export type subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | subjects$teachersArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type subjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type subjectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subjects"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      active: boolean | null
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type subjectsGetPayload<S extends boolean | null | undefined | subjectsDefaultArgs> = $Result.GetResult<Prisma.$subjectsPayload, S>

  type subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subjects'], meta: { name: 'subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {subjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectsFindUniqueArgs>(args: SelectSubset<T, subjectsFindUniqueArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectsFindFirstArgs>(args?: SelectSubset<T, subjectsFindFirstArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectsWithIdOnly = await prisma.subjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subjectsFindManyArgs>(args?: SelectSubset<T, subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subjects.
     * @param {subjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends subjectsCreateArgs>(args: SelectSubset<T, subjectsCreateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {subjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectsCreateManyArgs>(args?: SelectSubset<T, subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {subjectsCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, subjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subjects.
     * @param {subjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends subjectsDeleteArgs>(args: SelectSubset<T, subjectsDeleteArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subjects.
     * @param {subjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectsUpdateArgs>(args: SelectSubset<T, subjectsUpdateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {subjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectsDeleteManyArgs>(args?: SelectSubset<T, subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectsUpdateManyArgs>(args: SelectSubset<T, subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {subjectsUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectsWithIdOnly = await prisma.subjects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends subjectsUpdateManyAndReturnArgs>(args: SelectSubset<T, subjectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subjects.
     * @param {subjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends subjectsUpsertArgs>(args: SelectSubset<T, subjectsUpsertArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectsCountArgs>(
      args?: Subset<T, subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectsGroupByArgs['orderBy'] }
        : { orderBy?: subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subjects model
   */
  readonly fields: subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends subjects$teachersArgs<ExtArgs> = {}>(args?: Subset<T, subjects$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subjects model
   */
  interface subjectsFieldRefs {
    readonly id: FieldRef<"subjects", 'Int'>
    readonly title: FieldRef<"subjects", 'String'>
    readonly active: FieldRef<"subjects", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * subjects findUnique
   */
  export type subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findUniqueOrThrow
   */
  export type subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findFirst
   */
  export type subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findFirstOrThrow
   */
  export type subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findMany
   */
  export type subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects create
   */
  export type subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a subjects.
     */
    data: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
  }

  /**
   * subjects createMany
   */
  export type subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects createManyAndReturn
   */
  export type subjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects update
   */
  export type subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a subjects.
     */
    data: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
    /**
     * Choose, which subjects to update.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects updateMany
   */
  export type subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subjects updateManyAndReturn
   */
  export type subjectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subjects upsert
   */
  export type subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the subjects to update in case it exists.
     */
    where: subjectsWhereUniqueInput
    /**
     * In case the subjects found by the `where` argument doesn't exist, create a new subjects with this data.
     */
    create: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
    /**
     * In case the subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
  }

  /**
   * subjects delete
   */
  export type subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter which subjects to delete.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects deleteMany
   */
  export type subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to delete.
     */
    limit?: number
  }

  /**
   * subjects.teachers
   */
  export type subjects$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    cursor?: teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * subjects without action
   */
  export type subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
  }


  /**
   * Model teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersAvgAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
    subject_id: number | null
  }

  export type TeachersSumAggregateOutputType = {
    user_id: number | null
    government_id: number | null
    zone_id: number | null
    subject_id: number | null
  }

  export type TeachersMinAggregateOutputType = {
    user_id: number | null
    serial: string | null
    is_primary: boolean | null
    is_preparatory: boolean | null
    is_secondary: boolean | null
    government_id: number | null
    zone_id: number | null
    subject_id: number | null
  }

  export type TeachersMaxAggregateOutputType = {
    user_id: number | null
    serial: string | null
    is_primary: boolean | null
    is_preparatory: boolean | null
    is_secondary: boolean | null
    government_id: number | null
    zone_id: number | null
    subject_id: number | null
  }

  export type TeachersCountAggregateOutputType = {
    user_id: number
    serial: number
    is_primary: number
    is_preparatory: number
    is_secondary: number
    government_id: number
    zone_id: number
    subject_id: number
    _all: number
  }


  export type TeachersAvgAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
    subject_id?: true
  }

  export type TeachersSumAggregateInputType = {
    user_id?: true
    government_id?: true
    zone_id?: true
    subject_id?: true
  }

  export type TeachersMinAggregateInputType = {
    user_id?: true
    serial?: true
    is_primary?: true
    is_preparatory?: true
    is_secondary?: true
    government_id?: true
    zone_id?: true
    subject_id?: true
  }

  export type TeachersMaxAggregateInputType = {
    user_id?: true
    serial?: true
    is_primary?: true
    is_preparatory?: true
    is_secondary?: true
    government_id?: true
    zone_id?: true
    subject_id?: true
  }

  export type TeachersCountAggregateInputType = {
    user_id?: true
    serial?: true
    is_primary?: true
    is_preparatory?: true
    is_secondary?: true
    government_id?: true
    zone_id?: true
    subject_id?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to aggregate.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type teachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithAggregationInput | teachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: teachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _avg?: TeachersAvgAggregateInputType
    _sum?: TeachersSumAggregateInputType
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    user_id: number
    serial: string | null
    is_primary: boolean | null
    is_preparatory: boolean | null
    is_secondary: boolean | null
    government_id: number | null
    zone_id: number | null
    subject_id: number | null
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends teachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type teachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    serial?: boolean
    is_primary?: boolean
    is_preparatory?: boolean
    is_secondary?: boolean
    government_id?: boolean
    zone_id?: boolean
    subject_id?: boolean
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    serial?: boolean
    is_primary?: boolean
    is_preparatory?: boolean
    is_secondary?: boolean
    government_id?: boolean
    zone_id?: boolean
    subject_id?: boolean
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    serial?: boolean
    is_primary?: boolean
    is_preparatory?: boolean
    is_secondary?: boolean
    government_id?: boolean
    zone_id?: boolean
    subject_id?: boolean
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectScalar = {
    user_id?: boolean
    serial?: boolean
    is_primary?: boolean
    is_preparatory?: boolean
    is_secondary?: boolean
    government_id?: boolean
    zone_id?: boolean
    subject_id?: boolean
  }

  export type teachersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "serial" | "is_primary" | "is_preparatory" | "is_secondary" | "government_id" | "zone_id" | "subject_id", ExtArgs["result"]["teachers"]>
  export type teachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }
  export type teachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }
  export type teachersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | teachers$governmentArgs<ExtArgs>
    subjects?: boolean | teachers$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    zones?: boolean | teachers$zonesArgs<ExtArgs>
  }

  export type $teachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teachers"
    objects: {
      government: Prisma.$governmentPayload<ExtArgs> | null
      subjects: Prisma.$subjectsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      zones: Prisma.$zonesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      serial: string | null
      is_primary: boolean | null
      is_preparatory: boolean | null
      is_secondary: boolean | null
      government_id: number | null
      zone_id: number | null
      subject_id: number | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type teachersGetPayload<S extends boolean | null | undefined | teachersDefaultArgs> = $Result.GetResult<Prisma.$teachersPayload, S>

  type teachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teachersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface teachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teachers'], meta: { name: 'teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {teachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teachersFindUniqueArgs>(args: SelectSubset<T, teachersFindUniqueArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teachersFindUniqueOrThrowArgs>(args: SelectSubset<T, teachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teachersFindFirstArgs>(args?: SelectSubset<T, teachersFindFirstArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teachersFindFirstOrThrowArgs>(args?: SelectSubset<T, teachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const teachersWithUser_idOnly = await prisma.teachers.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends teachersFindManyArgs>(args?: SelectSubset<T, teachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teachers.
     * @param {teachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends teachersCreateArgs>(args: SelectSubset<T, teachersCreateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {teachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teachersCreateManyArgs>(args?: SelectSubset<T, teachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {teachersCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `user_id`
     * const teachersWithUser_idOnly = await prisma.teachers.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teachersCreateManyAndReturnArgs>(args?: SelectSubset<T, teachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teachers.
     * @param {teachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends teachersDeleteArgs>(args: SelectSubset<T, teachersDeleteArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teachers.
     * @param {teachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teachersUpdateArgs>(args: SelectSubset<T, teachersUpdateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {teachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teachersDeleteManyArgs>(args?: SelectSubset<T, teachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teachersUpdateManyArgs>(args: SelectSubset<T, teachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {teachersUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `user_id`
     * const teachersWithUser_idOnly = await prisma.teachers.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teachersUpdateManyAndReturnArgs>(args: SelectSubset<T, teachersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teachers.
     * @param {teachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends teachersUpsertArgs>(args: SelectSubset<T, teachersUpsertArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teachersCountArgs>(
      args?: Subset<T, teachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teachersGroupByArgs['orderBy'] }
        : { orderBy?: teachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teachers model
   */
  readonly fields: teachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    government<T extends teachers$governmentArgs<ExtArgs> = {}>(args?: Subset<T, teachers$governmentArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends teachers$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$subjectsArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zones<T extends teachers$zonesArgs<ExtArgs> = {}>(args?: Subset<T, teachers$zonesArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teachers model
   */
  interface teachersFieldRefs {
    readonly user_id: FieldRef<"teachers", 'Int'>
    readonly serial: FieldRef<"teachers", 'String'>
    readonly is_primary: FieldRef<"teachers", 'Boolean'>
    readonly is_preparatory: FieldRef<"teachers", 'Boolean'>
    readonly is_secondary: FieldRef<"teachers", 'Boolean'>
    readonly government_id: FieldRef<"teachers", 'Int'>
    readonly zone_id: FieldRef<"teachers", 'Int'>
    readonly subject_id: FieldRef<"teachers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * teachers findUnique
   */
  export type teachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findUniqueOrThrow
   */
  export type teachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findFirst
   */
  export type teachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findFirstOrThrow
   */
  export type teachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findMany
   */
  export type teachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers create
   */
  export type teachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to create a teachers.
     */
    data: XOR<teachersCreateInput, teachersUncheckedCreateInput>
  }

  /**
   * teachers createMany
   */
  export type teachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teachers createManyAndReturn
   */
  export type teachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teachers update
   */
  export type teachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to update a teachers.
     */
    data: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
    /**
     * Choose, which teachers to update.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers updateMany
   */
  export type teachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
  }

  /**
   * teachers updateManyAndReturn
   */
  export type teachersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teachers upsert
   */
  export type teachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The filter to search for the teachers to update in case it exists.
     */
    where: teachersWhereUniqueInput
    /**
     * In case the teachers found by the `where` argument doesn't exist, create a new teachers with this data.
     */
    create: XOR<teachersCreateInput, teachersUncheckedCreateInput>
    /**
     * In case the teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
  }

  /**
   * teachers delete
   */
  export type teachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter which teachers to delete.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers deleteMany
   */
  export type teachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to delete.
     */
    limit?: number
  }

  /**
   * teachers.government
   */
  export type teachers$governmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the government
     */
    select?: governmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the government
     */
    omit?: governmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: governmentInclude<ExtArgs> | null
    where?: governmentWhereInput
  }

  /**
   * teachers.subjects
   */
  export type teachers$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    where?: subjectsWhereInput
  }

  /**
   * teachers.zones
   */
  export type teachers$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    where?: zonesWhereInput
  }

  /**
   * teachers without action
   */
  export type teachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
  }


  /**
   * Model teaches_at
   */

  export type AggregateTeaches_at = {
    _count: Teaches_atCountAggregateOutputType | null
    _avg: Teaches_atAvgAggregateOutputType | null
    _sum: Teaches_atSumAggregateOutputType | null
    _min: Teaches_atMinAggregateOutputType | null
    _max: Teaches_atMaxAggregateOutputType | null
  }

  export type Teaches_atAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Teaches_atSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Teaches_atMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    location_name: string | null
    location_type: $Enums.location_type_enum | null
    active: boolean | null
  }

  export type Teaches_atMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    location_name: string | null
    location_type: $Enums.location_type_enum | null
    active: boolean | null
  }

  export type Teaches_atCountAggregateOutputType = {
    id: number
    user_id: number
    location_name: number
    location_type: number
    active: number
    _all: number
  }


  export type Teaches_atAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Teaches_atSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Teaches_atMinAggregateInputType = {
    id?: true
    user_id?: true
    location_name?: true
    location_type?: true
    active?: true
  }

  export type Teaches_atMaxAggregateInputType = {
    id?: true
    user_id?: true
    location_name?: true
    location_type?: true
    active?: true
  }

  export type Teaches_atCountAggregateInputType = {
    id?: true
    user_id?: true
    location_name?: true
    location_type?: true
    active?: true
    _all?: true
  }

  export type Teaches_atAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teaches_at to aggregate.
     */
    where?: teaches_atWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teaches_ats to fetch.
     */
    orderBy?: teaches_atOrderByWithRelationInput | teaches_atOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teaches_atWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teaches_ats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teaches_ats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teaches_ats
    **/
    _count?: true | Teaches_atCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Teaches_atAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Teaches_atSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Teaches_atMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Teaches_atMaxAggregateInputType
  }

  export type GetTeaches_atAggregateType<T extends Teaches_atAggregateArgs> = {
        [P in keyof T & keyof AggregateTeaches_at]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeaches_at[P]>
      : GetScalarType<T[P], AggregateTeaches_at[P]>
  }




  export type teaches_atGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teaches_atWhereInput
    orderBy?: teaches_atOrderByWithAggregationInput | teaches_atOrderByWithAggregationInput[]
    by: Teaches_atScalarFieldEnum[] | Teaches_atScalarFieldEnum
    having?: teaches_atScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Teaches_atCountAggregateInputType | true
    _avg?: Teaches_atAvgAggregateInputType
    _sum?: Teaches_atSumAggregateInputType
    _min?: Teaches_atMinAggregateInputType
    _max?: Teaches_atMaxAggregateInputType
  }

  export type Teaches_atGroupByOutputType = {
    id: number
    user_id: number
    location_name: string | null
    location_type: $Enums.location_type_enum | null
    active: boolean | null
    _count: Teaches_atCountAggregateOutputType | null
    _avg: Teaches_atAvgAggregateOutputType | null
    _sum: Teaches_atSumAggregateOutputType | null
    _min: Teaches_atMinAggregateOutputType | null
    _max: Teaches_atMaxAggregateOutputType | null
  }

  type GetTeaches_atGroupByPayload<T extends teaches_atGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Teaches_atGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Teaches_atGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Teaches_atGroupByOutputType[P]>
            : GetScalarType<T[P], Teaches_atGroupByOutputType[P]>
        }
      >
    >


  export type teaches_atSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    location_name?: boolean
    location_type?: boolean
    active?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teaches_at"]>

  export type teaches_atSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    location_name?: boolean
    location_type?: boolean
    active?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teaches_at"]>

  export type teaches_atSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    location_name?: boolean
    location_type?: boolean
    active?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teaches_at"]>

  export type teaches_atSelectScalar = {
    id?: boolean
    user_id?: boolean
    location_name?: boolean
    location_type?: boolean
    active?: boolean
  }

  export type teaches_atOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "location_name" | "location_type" | "active", ExtArgs["result"]["teaches_at"]>
  export type teaches_atInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type teaches_atIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type teaches_atIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $teaches_atPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teaches_at"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      location_name: string | null
      location_type: $Enums.location_type_enum | null
      active: boolean | null
    }, ExtArgs["result"]["teaches_at"]>
    composites: {}
  }

  type teaches_atGetPayload<S extends boolean | null | undefined | teaches_atDefaultArgs> = $Result.GetResult<Prisma.$teaches_atPayload, S>

  type teaches_atCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teaches_atFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Teaches_atCountAggregateInputType | true
    }

  export interface teaches_atDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teaches_at'], meta: { name: 'teaches_at' } }
    /**
     * Find zero or one Teaches_at that matches the filter.
     * @param {teaches_atFindUniqueArgs} args - Arguments to find a Teaches_at
     * @example
     * // Get one Teaches_at
     * const teaches_at = await prisma.teaches_at.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teaches_atFindUniqueArgs>(args: SelectSubset<T, teaches_atFindUniqueArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teaches_at that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teaches_atFindUniqueOrThrowArgs} args - Arguments to find a Teaches_at
     * @example
     * // Get one Teaches_at
     * const teaches_at = await prisma.teaches_at.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teaches_atFindUniqueOrThrowArgs>(args: SelectSubset<T, teaches_atFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teaches_at that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atFindFirstArgs} args - Arguments to find a Teaches_at
     * @example
     * // Get one Teaches_at
     * const teaches_at = await prisma.teaches_at.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teaches_atFindFirstArgs>(args?: SelectSubset<T, teaches_atFindFirstArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teaches_at that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atFindFirstOrThrowArgs} args - Arguments to find a Teaches_at
     * @example
     * // Get one Teaches_at
     * const teaches_at = await prisma.teaches_at.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teaches_atFindFirstOrThrowArgs>(args?: SelectSubset<T, teaches_atFindFirstOrThrowArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teaches_ats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teaches_ats
     * const teaches_ats = await prisma.teaches_at.findMany()
     * 
     * // Get first 10 Teaches_ats
     * const teaches_ats = await prisma.teaches_at.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teaches_atWithIdOnly = await prisma.teaches_at.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teaches_atFindManyArgs>(args?: SelectSubset<T, teaches_atFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teaches_at.
     * @param {teaches_atCreateArgs} args - Arguments to create a Teaches_at.
     * @example
     * // Create one Teaches_at
     * const Teaches_at = await prisma.teaches_at.create({
     *   data: {
     *     // ... data to create a Teaches_at
     *   }
     * })
     * 
     */
    create<T extends teaches_atCreateArgs>(args: SelectSubset<T, teaches_atCreateArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teaches_ats.
     * @param {teaches_atCreateManyArgs} args - Arguments to create many Teaches_ats.
     * @example
     * // Create many Teaches_ats
     * const teaches_at = await prisma.teaches_at.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teaches_atCreateManyArgs>(args?: SelectSubset<T, teaches_atCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teaches_ats and returns the data saved in the database.
     * @param {teaches_atCreateManyAndReturnArgs} args - Arguments to create many Teaches_ats.
     * @example
     * // Create many Teaches_ats
     * const teaches_at = await prisma.teaches_at.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teaches_ats and only return the `id`
     * const teaches_atWithIdOnly = await prisma.teaches_at.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teaches_atCreateManyAndReturnArgs>(args?: SelectSubset<T, teaches_atCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teaches_at.
     * @param {teaches_atDeleteArgs} args - Arguments to delete one Teaches_at.
     * @example
     * // Delete one Teaches_at
     * const Teaches_at = await prisma.teaches_at.delete({
     *   where: {
     *     // ... filter to delete one Teaches_at
     *   }
     * })
     * 
     */
    delete<T extends teaches_atDeleteArgs>(args: SelectSubset<T, teaches_atDeleteArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teaches_at.
     * @param {teaches_atUpdateArgs} args - Arguments to update one Teaches_at.
     * @example
     * // Update one Teaches_at
     * const teaches_at = await prisma.teaches_at.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teaches_atUpdateArgs>(args: SelectSubset<T, teaches_atUpdateArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teaches_ats.
     * @param {teaches_atDeleteManyArgs} args - Arguments to filter Teaches_ats to delete.
     * @example
     * // Delete a few Teaches_ats
     * const { count } = await prisma.teaches_at.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teaches_atDeleteManyArgs>(args?: SelectSubset<T, teaches_atDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teaches_ats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teaches_ats
     * const teaches_at = await prisma.teaches_at.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teaches_atUpdateManyArgs>(args: SelectSubset<T, teaches_atUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teaches_ats and returns the data updated in the database.
     * @param {teaches_atUpdateManyAndReturnArgs} args - Arguments to update many Teaches_ats.
     * @example
     * // Update many Teaches_ats
     * const teaches_at = await prisma.teaches_at.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teaches_ats and only return the `id`
     * const teaches_atWithIdOnly = await prisma.teaches_at.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teaches_atUpdateManyAndReturnArgs>(args: SelectSubset<T, teaches_atUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teaches_at.
     * @param {teaches_atUpsertArgs} args - Arguments to update or create a Teaches_at.
     * @example
     * // Update or create a Teaches_at
     * const teaches_at = await prisma.teaches_at.upsert({
     *   create: {
     *     // ... data to create a Teaches_at
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teaches_at we want to update
     *   }
     * })
     */
    upsert<T extends teaches_atUpsertArgs>(args: SelectSubset<T, teaches_atUpsertArgs<ExtArgs>>): Prisma__teaches_atClient<$Result.GetResult<Prisma.$teaches_atPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teaches_ats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atCountArgs} args - Arguments to filter Teaches_ats to count.
     * @example
     * // Count the number of Teaches_ats
     * const count = await prisma.teaches_at.count({
     *   where: {
     *     // ... the filter for the Teaches_ats we want to count
     *   }
     * })
    **/
    count<T extends teaches_atCountArgs>(
      args?: Subset<T, teaches_atCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Teaches_atCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teaches_at.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Teaches_atAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Teaches_atAggregateArgs>(args: Subset<T, Teaches_atAggregateArgs>): Prisma.PrismaPromise<GetTeaches_atAggregateType<T>>

    /**
     * Group by Teaches_at.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teaches_atGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teaches_atGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teaches_atGroupByArgs['orderBy'] }
        : { orderBy?: teaches_atGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teaches_atGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeaches_atGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teaches_at model
   */
  readonly fields: teaches_atFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teaches_at.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teaches_atClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teaches_at model
   */
  interface teaches_atFieldRefs {
    readonly id: FieldRef<"teaches_at", 'Int'>
    readonly user_id: FieldRef<"teaches_at", 'Int'>
    readonly location_name: FieldRef<"teaches_at", 'String'>
    readonly location_type: FieldRef<"teaches_at", 'location_type_enum'>
    readonly active: FieldRef<"teaches_at", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * teaches_at findUnique
   */
  export type teaches_atFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter, which teaches_at to fetch.
     */
    where: teaches_atWhereUniqueInput
  }

  /**
   * teaches_at findUniqueOrThrow
   */
  export type teaches_atFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter, which teaches_at to fetch.
     */
    where: teaches_atWhereUniqueInput
  }

  /**
   * teaches_at findFirst
   */
  export type teaches_atFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter, which teaches_at to fetch.
     */
    where?: teaches_atWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teaches_ats to fetch.
     */
    orderBy?: teaches_atOrderByWithRelationInput | teaches_atOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teaches_ats.
     */
    cursor?: teaches_atWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teaches_ats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teaches_ats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teaches_ats.
     */
    distinct?: Teaches_atScalarFieldEnum | Teaches_atScalarFieldEnum[]
  }

  /**
   * teaches_at findFirstOrThrow
   */
  export type teaches_atFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter, which teaches_at to fetch.
     */
    where?: teaches_atWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teaches_ats to fetch.
     */
    orderBy?: teaches_atOrderByWithRelationInput | teaches_atOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teaches_ats.
     */
    cursor?: teaches_atWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teaches_ats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teaches_ats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teaches_ats.
     */
    distinct?: Teaches_atScalarFieldEnum | Teaches_atScalarFieldEnum[]
  }

  /**
   * teaches_at findMany
   */
  export type teaches_atFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter, which teaches_ats to fetch.
     */
    where?: teaches_atWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teaches_ats to fetch.
     */
    orderBy?: teaches_atOrderByWithRelationInput | teaches_atOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teaches_ats.
     */
    cursor?: teaches_atWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teaches_ats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teaches_ats.
     */
    skip?: number
    distinct?: Teaches_atScalarFieldEnum | Teaches_atScalarFieldEnum[]
  }

  /**
   * teaches_at create
   */
  export type teaches_atCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * The data needed to create a teaches_at.
     */
    data: XOR<teaches_atCreateInput, teaches_atUncheckedCreateInput>
  }

  /**
   * teaches_at createMany
   */
  export type teaches_atCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teaches_ats.
     */
    data: teaches_atCreateManyInput | teaches_atCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teaches_at createManyAndReturn
   */
  export type teaches_atCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * The data used to create many teaches_ats.
     */
    data: teaches_atCreateManyInput | teaches_atCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teaches_at update
   */
  export type teaches_atUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * The data needed to update a teaches_at.
     */
    data: XOR<teaches_atUpdateInput, teaches_atUncheckedUpdateInput>
    /**
     * Choose, which teaches_at to update.
     */
    where: teaches_atWhereUniqueInput
  }

  /**
   * teaches_at updateMany
   */
  export type teaches_atUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teaches_ats.
     */
    data: XOR<teaches_atUpdateManyMutationInput, teaches_atUncheckedUpdateManyInput>
    /**
     * Filter which teaches_ats to update
     */
    where?: teaches_atWhereInput
    /**
     * Limit how many teaches_ats to update.
     */
    limit?: number
  }

  /**
   * teaches_at updateManyAndReturn
   */
  export type teaches_atUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * The data used to update teaches_ats.
     */
    data: XOR<teaches_atUpdateManyMutationInput, teaches_atUncheckedUpdateManyInput>
    /**
     * Filter which teaches_ats to update
     */
    where?: teaches_atWhereInput
    /**
     * Limit how many teaches_ats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teaches_at upsert
   */
  export type teaches_atUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * The filter to search for the teaches_at to update in case it exists.
     */
    where: teaches_atWhereUniqueInput
    /**
     * In case the teaches_at found by the `where` argument doesn't exist, create a new teaches_at with this data.
     */
    create: XOR<teaches_atCreateInput, teaches_atUncheckedCreateInput>
    /**
     * In case the teaches_at was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teaches_atUpdateInput, teaches_atUncheckedUpdateInput>
  }

  /**
   * teaches_at delete
   */
  export type teaches_atDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
    /**
     * Filter which teaches_at to delete.
     */
    where: teaches_atWhereUniqueInput
  }

  /**
   * teaches_at deleteMany
   */
  export type teaches_atDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teaches_ats to delete
     */
    where?: teaches_atWhereInput
    /**
     * Limit how many teaches_ats to delete.
     */
    limit?: number
  }

  /**
   * teaches_at without action
   */
  export type teaches_atDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teaches_at
     */
    select?: teaches_atSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teaches_at
     */
    omit?: teaches_atOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teaches_atInclude<ExtArgs> | null
  }


  /**
   * Model zones
   */

  export type AggregateZones = {
    _count: ZonesCountAggregateOutputType | null
    _avg: ZonesAvgAggregateOutputType | null
    _sum: ZonesSumAggregateOutputType | null
    _min: ZonesMinAggregateOutputType | null
    _max: ZonesMaxAggregateOutputType | null
  }

  export type ZonesAvgAggregateOutputType = {
    id: number | null
    government_id: number | null
  }

  export type ZonesSumAggregateOutputType = {
    id: number | null
    government_id: number | null
  }

  export type ZonesMinAggregateOutputType = {
    id: number | null
    title: string | null
    government_id: number | null
    active: boolean | null
  }

  export type ZonesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    government_id: number | null
    active: boolean | null
  }

  export type ZonesCountAggregateOutputType = {
    id: number
    title: number
    government_id: number
    active: number
    _all: number
  }


  export type ZonesAvgAggregateInputType = {
    id?: true
    government_id?: true
  }

  export type ZonesSumAggregateInputType = {
    id?: true
    government_id?: true
  }

  export type ZonesMinAggregateInputType = {
    id?: true
    title?: true
    government_id?: true
    active?: true
  }

  export type ZonesMaxAggregateInputType = {
    id?: true
    title?: true
    government_id?: true
    active?: true
  }

  export type ZonesCountAggregateInputType = {
    id?: true
    title?: true
    government_id?: true
    active?: true
    _all?: true
  }

  export type ZonesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to aggregate.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zones
    **/
    _count?: true | ZonesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZonesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZonesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZonesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZonesMaxAggregateInputType
  }

  export type GetZonesAggregateType<T extends ZonesAggregateArgs> = {
        [P in keyof T & keyof AggregateZones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZones[P]>
      : GetScalarType<T[P], AggregateZones[P]>
  }




  export type zonesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zonesWhereInput
    orderBy?: zonesOrderByWithAggregationInput | zonesOrderByWithAggregationInput[]
    by: ZonesScalarFieldEnum[] | ZonesScalarFieldEnum
    having?: zonesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZonesCountAggregateInputType | true
    _avg?: ZonesAvgAggregateInputType
    _sum?: ZonesSumAggregateInputType
    _min?: ZonesMinAggregateInputType
    _max?: ZonesMaxAggregateInputType
  }

  export type ZonesGroupByOutputType = {
    id: number
    title: string
    government_id: number
    active: boolean | null
    _count: ZonesCountAggregateOutputType | null
    _avg: ZonesAvgAggregateOutputType | null
    _sum: ZonesSumAggregateOutputType | null
    _min: ZonesMinAggregateOutputType | null
    _max: ZonesMaxAggregateOutputType | null
  }

  type GetZonesGroupByPayload<T extends zonesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZonesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZonesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZonesGroupByOutputType[P]>
            : GetScalarType<T[P], ZonesGroupByOutputType[P]>
        }
      >
    >


  export type zonesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    government_id?: boolean
    active?: boolean
    parents?: boolean | zones$parentsArgs<ExtArgs>
    students?: boolean | zones$studentsArgs<ExtArgs>
    teachers?: boolean | zones$teachersArgs<ExtArgs>
    government?: boolean | governmentDefaultArgs<ExtArgs>
    _count?: boolean | ZonesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    government_id?: boolean
    active?: boolean
    government?: boolean | governmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    government_id?: boolean
    active?: boolean
    government?: boolean | governmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectScalar = {
    id?: boolean
    title?: boolean
    government_id?: boolean
    active?: boolean
  }

  export type zonesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "government_id" | "active", ExtArgs["result"]["zones"]>
  export type zonesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | zones$parentsArgs<ExtArgs>
    students?: boolean | zones$studentsArgs<ExtArgs>
    teachers?: boolean | zones$teachersArgs<ExtArgs>
    government?: boolean | governmentDefaultArgs<ExtArgs>
    _count?: boolean | ZonesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type zonesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | governmentDefaultArgs<ExtArgs>
  }
  export type zonesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    government?: boolean | governmentDefaultArgs<ExtArgs>
  }

  export type $zonesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zones"
    objects: {
      parents: Prisma.$parentsPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
      teachers: Prisma.$teachersPayload<ExtArgs>[]
      government: Prisma.$governmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      government_id: number
      active: boolean | null
    }, ExtArgs["result"]["zones"]>
    composites: {}
  }

  type zonesGetPayload<S extends boolean | null | undefined | zonesDefaultArgs> = $Result.GetResult<Prisma.$zonesPayload, S>

  type zonesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zonesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZonesCountAggregateInputType | true
    }

  export interface zonesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zones'], meta: { name: 'zones' } }
    /**
     * Find zero or one Zones that matches the filter.
     * @param {zonesFindUniqueArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zonesFindUniqueArgs>(args: SelectSubset<T, zonesFindUniqueArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zonesFindUniqueOrThrowArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zonesFindUniqueOrThrowArgs>(args: SelectSubset<T, zonesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindFirstArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zonesFindFirstArgs>(args?: SelectSubset<T, zonesFindFirstArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindFirstOrThrowArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zonesFindFirstOrThrowArgs>(args?: SelectSubset<T, zonesFindFirstOrThrowArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zones.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zonesWithIdOnly = await prisma.zones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zonesFindManyArgs>(args?: SelectSubset<T, zonesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zones.
     * @param {zonesCreateArgs} args - Arguments to create a Zones.
     * @example
     * // Create one Zones
     * const Zones = await prisma.zones.create({
     *   data: {
     *     // ... data to create a Zones
     *   }
     * })
     * 
     */
    create<T extends zonesCreateArgs>(args: SelectSubset<T, zonesCreateArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {zonesCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zones = await prisma.zones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zonesCreateManyArgs>(args?: SelectSubset<T, zonesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {zonesCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zones = await prisma.zones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zonesWithIdOnly = await prisma.zones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zonesCreateManyAndReturnArgs>(args?: SelectSubset<T, zonesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zones.
     * @param {zonesDeleteArgs} args - Arguments to delete one Zones.
     * @example
     * // Delete one Zones
     * const Zones = await prisma.zones.delete({
     *   where: {
     *     // ... filter to delete one Zones
     *   }
     * })
     * 
     */
    delete<T extends zonesDeleteArgs>(args: SelectSubset<T, zonesDeleteArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zones.
     * @param {zonesUpdateArgs} args - Arguments to update one Zones.
     * @example
     * // Update one Zones
     * const zones = await prisma.zones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zonesUpdateArgs>(args: SelectSubset<T, zonesUpdateArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {zonesDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zonesDeleteManyArgs>(args?: SelectSubset<T, zonesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zones = await prisma.zones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zonesUpdateManyArgs>(args: SelectSubset<T, zonesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {zonesUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zones = await prisma.zones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zonesWithIdOnly = await prisma.zones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zonesUpdateManyAndReturnArgs>(args: SelectSubset<T, zonesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zones.
     * @param {zonesUpsertArgs} args - Arguments to update or create a Zones.
     * @example
     * // Update or create a Zones
     * const zones = await prisma.zones.upsert({
     *   create: {
     *     // ... data to create a Zones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zones we want to update
     *   }
     * })
     */
    upsert<T extends zonesUpsertArgs>(args: SelectSubset<T, zonesUpsertArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zones.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends zonesCountArgs>(
      args?: Subset<T, zonesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZonesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZonesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZonesAggregateArgs>(args: Subset<T, ZonesAggregateArgs>): Prisma.PrismaPromise<GetZonesAggregateType<T>>

    /**
     * Group by Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zonesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zonesGroupByArgs['orderBy'] }
        : { orderBy?: zonesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zonesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZonesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zones model
   */
  readonly fields: zonesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zonesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends zones$parentsArgs<ExtArgs> = {}>(args?: Subset<T, zones$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends zones$studentsArgs<ExtArgs> = {}>(args?: Subset<T, zones$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends zones$teachersArgs<ExtArgs> = {}>(args?: Subset<T, zones$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    government<T extends governmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, governmentDefaultArgs<ExtArgs>>): Prisma__governmentClient<$Result.GetResult<Prisma.$governmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zones model
   */
  interface zonesFieldRefs {
    readonly id: FieldRef<"zones", 'Int'>
    readonly title: FieldRef<"zones", 'String'>
    readonly government_id: FieldRef<"zones", 'Int'>
    readonly active: FieldRef<"zones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * zones findUnique
   */
  export type zonesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones findUniqueOrThrow
   */
  export type zonesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones findFirst
   */
  export type zonesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones findFirstOrThrow
   */
  export type zonesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones findMany
   */
  export type zonesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones create
   */
  export type zonesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The data needed to create a zones.
     */
    data: XOR<zonesCreateInput, zonesUncheckedCreateInput>
  }

  /**
   * zones createMany
   */
  export type zonesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zones.
     */
    data: zonesCreateManyInput | zonesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zones createManyAndReturn
   */
  export type zonesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * The data used to create many zones.
     */
    data: zonesCreateManyInput | zonesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * zones update
   */
  export type zonesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The data needed to update a zones.
     */
    data: XOR<zonesUpdateInput, zonesUncheckedUpdateInput>
    /**
     * Choose, which zones to update.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones updateMany
   */
  export type zonesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zones.
     */
    data: XOR<zonesUpdateManyMutationInput, zonesUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zones updateManyAndReturn
   */
  export type zonesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * The data used to update zones.
     */
    data: XOR<zonesUpdateManyMutationInput, zonesUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * zones upsert
   */
  export type zonesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The filter to search for the zones to update in case it exists.
     */
    where: zonesWhereUniqueInput
    /**
     * In case the zones found by the `where` argument doesn't exist, create a new zones with this data.
     */
    create: XOR<zonesCreateInput, zonesUncheckedCreateInput>
    /**
     * In case the zones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zonesUpdateInput, zonesUncheckedUpdateInput>
  }

  /**
   * zones delete
   */
  export type zonesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter which zones to delete.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones deleteMany
   */
  export type zonesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to delete
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to delete.
     */
    limit?: number
  }

  /**
   * zones.parents
   */
  export type zones$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parents
     */
    omit?: parentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    cursor?: parentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * zones.students
   */
  export type zones$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * zones.teachers
   */
  export type zones$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    cursor?: teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * zones without action
   */
  export type zonesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
  }


  /**
   * Model email_verification_tokens
   */

  export type AggregateEmail_verification_tokens = {
    _count: Email_verification_tokensCountAggregateOutputType | null
    _avg: Email_verification_tokensAvgAggregateOutputType | null
    _sum: Email_verification_tokensSumAggregateOutputType | null
    _min: Email_verification_tokensMinAggregateOutputType | null
    _max: Email_verification_tokensMaxAggregateOutputType | null
  }

  export type Email_verification_tokensAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Email_verification_tokensSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Email_verification_tokensMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type Email_verification_tokensMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type Email_verification_tokensCountAggregateOutputType = {
    id: number
    user_id: number
    token_hash: number
    created_at: number
    expires_at: number
    used_at: number
    _all: number
  }


  export type Email_verification_tokensAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Email_verification_tokensSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Email_verification_tokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type Email_verification_tokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type Email_verification_tokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
    _all?: true
  }

  export type Email_verification_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_verification_tokens to aggregate.
     */
    where?: email_verification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_verification_tokens to fetch.
     */
    orderBy?: email_verification_tokensOrderByWithRelationInput | email_verification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_verification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_verification_tokens
    **/
    _count?: true | Email_verification_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Email_verification_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Email_verification_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_verification_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_verification_tokensMaxAggregateInputType
  }

  export type GetEmail_verification_tokensAggregateType<T extends Email_verification_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_verification_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_verification_tokens[P]>
      : GetScalarType<T[P], AggregateEmail_verification_tokens[P]>
  }




  export type email_verification_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_verification_tokensWhereInput
    orderBy?: email_verification_tokensOrderByWithAggregationInput | email_verification_tokensOrderByWithAggregationInput[]
    by: Email_verification_tokensScalarFieldEnum[] | Email_verification_tokensScalarFieldEnum
    having?: email_verification_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_verification_tokensCountAggregateInputType | true
    _avg?: Email_verification_tokensAvgAggregateInputType
    _sum?: Email_verification_tokensSumAggregateInputType
    _min?: Email_verification_tokensMinAggregateInputType
    _max?: Email_verification_tokensMaxAggregateInputType
  }

  export type Email_verification_tokensGroupByOutputType = {
    id: number
    user_id: number
    token_hash: string
    created_at: Date | null
    expires_at: Date
    used_at: Date | null
    _count: Email_verification_tokensCountAggregateOutputType | null
    _avg: Email_verification_tokensAvgAggregateOutputType | null
    _sum: Email_verification_tokensSumAggregateOutputType | null
    _min: Email_verification_tokensMinAggregateOutputType | null
    _max: Email_verification_tokensMaxAggregateOutputType | null
  }

  type GetEmail_verification_tokensGroupByPayload<T extends email_verification_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_verification_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_verification_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_verification_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Email_verification_tokensGroupByOutputType[P]>
        }
      >
    >


  export type email_verification_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email_verification_tokens"]>

  export type email_verification_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email_verification_tokens"]>

  export type email_verification_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email_verification_tokens"]>

  export type email_verification_tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
  }

  export type email_verification_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token_hash" | "created_at" | "expires_at" | "used_at", ExtArgs["result"]["email_verification_tokens"]>
  export type email_verification_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type email_verification_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type email_verification_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $email_verification_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_verification_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token_hash: string
      created_at: Date | null
      expires_at: Date
      used_at: Date | null
    }, ExtArgs["result"]["email_verification_tokens"]>
    composites: {}
  }

  type email_verification_tokensGetPayload<S extends boolean | null | undefined | email_verification_tokensDefaultArgs> = $Result.GetResult<Prisma.$email_verification_tokensPayload, S>

  type email_verification_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_verification_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_verification_tokensCountAggregateInputType | true
    }

  export interface email_verification_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_verification_tokens'], meta: { name: 'email_verification_tokens' } }
    /**
     * Find zero or one Email_verification_tokens that matches the filter.
     * @param {email_verification_tokensFindUniqueArgs} args - Arguments to find a Email_verification_tokens
     * @example
     * // Get one Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_verification_tokensFindUniqueArgs>(args: SelectSubset<T, email_verification_tokensFindUniqueArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_verification_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_verification_tokensFindUniqueOrThrowArgs} args - Arguments to find a Email_verification_tokens
     * @example
     * // Get one Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_verification_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, email_verification_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_verification_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensFindFirstArgs} args - Arguments to find a Email_verification_tokens
     * @example
     * // Get one Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_verification_tokensFindFirstArgs>(args?: SelectSubset<T, email_verification_tokensFindFirstArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_verification_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensFindFirstOrThrowArgs} args - Arguments to find a Email_verification_tokens
     * @example
     * // Get one Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_verification_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, email_verification_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_verification_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findMany()
     * 
     * // Get first 10 Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_verification_tokensWithIdOnly = await prisma.email_verification_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_verification_tokensFindManyArgs>(args?: SelectSubset<T, email_verification_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_verification_tokens.
     * @param {email_verification_tokensCreateArgs} args - Arguments to create a Email_verification_tokens.
     * @example
     * // Create one Email_verification_tokens
     * const Email_verification_tokens = await prisma.email_verification_tokens.create({
     *   data: {
     *     // ... data to create a Email_verification_tokens
     *   }
     * })
     * 
     */
    create<T extends email_verification_tokensCreateArgs>(args: SelectSubset<T, email_verification_tokensCreateArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_verification_tokens.
     * @param {email_verification_tokensCreateManyArgs} args - Arguments to create many Email_verification_tokens.
     * @example
     * // Create many Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_verification_tokensCreateManyArgs>(args?: SelectSubset<T, email_verification_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_verification_tokens and returns the data saved in the database.
     * @param {email_verification_tokensCreateManyAndReturnArgs} args - Arguments to create many Email_verification_tokens.
     * @example
     * // Create many Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_verification_tokens and only return the `id`
     * const email_verification_tokensWithIdOnly = await prisma.email_verification_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_verification_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, email_verification_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_verification_tokens.
     * @param {email_verification_tokensDeleteArgs} args - Arguments to delete one Email_verification_tokens.
     * @example
     * // Delete one Email_verification_tokens
     * const Email_verification_tokens = await prisma.email_verification_tokens.delete({
     *   where: {
     *     // ... filter to delete one Email_verification_tokens
     *   }
     * })
     * 
     */
    delete<T extends email_verification_tokensDeleteArgs>(args: SelectSubset<T, email_verification_tokensDeleteArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_verification_tokens.
     * @param {email_verification_tokensUpdateArgs} args - Arguments to update one Email_verification_tokens.
     * @example
     * // Update one Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_verification_tokensUpdateArgs>(args: SelectSubset<T, email_verification_tokensUpdateArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_verification_tokens.
     * @param {email_verification_tokensDeleteManyArgs} args - Arguments to filter Email_verification_tokens to delete.
     * @example
     * // Delete a few Email_verification_tokens
     * const { count } = await prisma.email_verification_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_verification_tokensDeleteManyArgs>(args?: SelectSubset<T, email_verification_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_verification_tokensUpdateManyArgs>(args: SelectSubset<T, email_verification_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_verification_tokens and returns the data updated in the database.
     * @param {email_verification_tokensUpdateManyAndReturnArgs} args - Arguments to update many Email_verification_tokens.
     * @example
     * // Update many Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_verification_tokens and only return the `id`
     * const email_verification_tokensWithIdOnly = await prisma.email_verification_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_verification_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, email_verification_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_verification_tokens.
     * @param {email_verification_tokensUpsertArgs} args - Arguments to update or create a Email_verification_tokens.
     * @example
     * // Update or create a Email_verification_tokens
     * const email_verification_tokens = await prisma.email_verification_tokens.upsert({
     *   create: {
     *     // ... data to create a Email_verification_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_verification_tokens we want to update
     *   }
     * })
     */
    upsert<T extends email_verification_tokensUpsertArgs>(args: SelectSubset<T, email_verification_tokensUpsertArgs<ExtArgs>>): Prisma__email_verification_tokensClient<$Result.GetResult<Prisma.$email_verification_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensCountArgs} args - Arguments to filter Email_verification_tokens to count.
     * @example
     * // Count the number of Email_verification_tokens
     * const count = await prisma.email_verification_tokens.count({
     *   where: {
     *     // ... the filter for the Email_verification_tokens we want to count
     *   }
     * })
    **/
    count<T extends email_verification_tokensCountArgs>(
      args?: Subset<T, email_verification_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_verification_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_verification_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_verification_tokensAggregateArgs>(args: Subset<T, Email_verification_tokensAggregateArgs>): Prisma.PrismaPromise<GetEmail_verification_tokensAggregateType<T>>

    /**
     * Group by Email_verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_verification_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_verification_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_verification_tokensGroupByArgs['orderBy'] }
        : { orderBy?: email_verification_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_verification_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_verification_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_verification_tokens model
   */
  readonly fields: email_verification_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_verification_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_verification_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_verification_tokens model
   */
  interface email_verification_tokensFieldRefs {
    readonly id: FieldRef<"email_verification_tokens", 'Int'>
    readonly user_id: FieldRef<"email_verification_tokens", 'Int'>
    readonly token_hash: FieldRef<"email_verification_tokens", 'String'>
    readonly created_at: FieldRef<"email_verification_tokens", 'DateTime'>
    readonly expires_at: FieldRef<"email_verification_tokens", 'DateTime'>
    readonly used_at: FieldRef<"email_verification_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * email_verification_tokens findUnique
   */
  export type email_verification_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which email_verification_tokens to fetch.
     */
    where: email_verification_tokensWhereUniqueInput
  }

  /**
   * email_verification_tokens findUniqueOrThrow
   */
  export type email_verification_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which email_verification_tokens to fetch.
     */
    where: email_verification_tokensWhereUniqueInput
  }

  /**
   * email_verification_tokens findFirst
   */
  export type email_verification_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which email_verification_tokens to fetch.
     */
    where?: email_verification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_verification_tokens to fetch.
     */
    orderBy?: email_verification_tokensOrderByWithRelationInput | email_verification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_verification_tokens.
     */
    cursor?: email_verification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_verification_tokens.
     */
    distinct?: Email_verification_tokensScalarFieldEnum | Email_verification_tokensScalarFieldEnum[]
  }

  /**
   * email_verification_tokens findFirstOrThrow
   */
  export type email_verification_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which email_verification_tokens to fetch.
     */
    where?: email_verification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_verification_tokens to fetch.
     */
    orderBy?: email_verification_tokensOrderByWithRelationInput | email_verification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_verification_tokens.
     */
    cursor?: email_verification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_verification_tokens.
     */
    distinct?: Email_verification_tokensScalarFieldEnum | Email_verification_tokensScalarFieldEnum[]
  }

  /**
   * email_verification_tokens findMany
   */
  export type email_verification_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which email_verification_tokens to fetch.
     */
    where?: email_verification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_verification_tokens to fetch.
     */
    orderBy?: email_verification_tokensOrderByWithRelationInput | email_verification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_verification_tokens.
     */
    cursor?: email_verification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_verification_tokens.
     */
    skip?: number
    distinct?: Email_verification_tokensScalarFieldEnum | Email_verification_tokensScalarFieldEnum[]
  }

  /**
   * email_verification_tokens create
   */
  export type email_verification_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a email_verification_tokens.
     */
    data: XOR<email_verification_tokensCreateInput, email_verification_tokensUncheckedCreateInput>
  }

  /**
   * email_verification_tokens createMany
   */
  export type email_verification_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_verification_tokens.
     */
    data: email_verification_tokensCreateManyInput | email_verification_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_verification_tokens createManyAndReturn
   */
  export type email_verification_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many email_verification_tokens.
     */
    data: email_verification_tokensCreateManyInput | email_verification_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_verification_tokens update
   */
  export type email_verification_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a email_verification_tokens.
     */
    data: XOR<email_verification_tokensUpdateInput, email_verification_tokensUncheckedUpdateInput>
    /**
     * Choose, which email_verification_tokens to update.
     */
    where: email_verification_tokensWhereUniqueInput
  }

  /**
   * email_verification_tokens updateMany
   */
  export type email_verification_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_verification_tokens.
     */
    data: XOR<email_verification_tokensUpdateManyMutationInput, email_verification_tokensUncheckedUpdateManyInput>
    /**
     * Filter which email_verification_tokens to update
     */
    where?: email_verification_tokensWhereInput
    /**
     * Limit how many email_verification_tokens to update.
     */
    limit?: number
  }

  /**
   * email_verification_tokens updateManyAndReturn
   */
  export type email_verification_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * The data used to update email_verification_tokens.
     */
    data: XOR<email_verification_tokensUpdateManyMutationInput, email_verification_tokensUncheckedUpdateManyInput>
    /**
     * Filter which email_verification_tokens to update
     */
    where?: email_verification_tokensWhereInput
    /**
     * Limit how many email_verification_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_verification_tokens upsert
   */
  export type email_verification_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the email_verification_tokens to update in case it exists.
     */
    where: email_verification_tokensWhereUniqueInput
    /**
     * In case the email_verification_tokens found by the `where` argument doesn't exist, create a new email_verification_tokens with this data.
     */
    create: XOR<email_verification_tokensCreateInput, email_verification_tokensUncheckedCreateInput>
    /**
     * In case the email_verification_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_verification_tokensUpdateInput, email_verification_tokensUncheckedUpdateInput>
  }

  /**
   * email_verification_tokens delete
   */
  export type email_verification_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
    /**
     * Filter which email_verification_tokens to delete.
     */
    where: email_verification_tokensWhereUniqueInput
  }

  /**
   * email_verification_tokens deleteMany
   */
  export type email_verification_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_verification_tokens to delete
     */
    where?: email_verification_tokensWhereInput
    /**
     * Limit how many email_verification_tokens to delete.
     */
    limit?: number
  }

  /**
   * email_verification_tokens without action
   */
  export type email_verification_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_verification_tokens
     */
    select?: email_verification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_verification_tokens
     */
    omit?: email_verification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_verification_tokensInclude<ExtArgs> | null
  }


  /**
   * Model password_reset_tokens
   */

  export type AggregatePassword_reset_tokens = {
    _count: Password_reset_tokensCountAggregateOutputType | null
    _avg: Password_reset_tokensAvgAggregateOutputType | null
    _sum: Password_reset_tokensSumAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  export type Password_reset_tokensAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Password_reset_tokensSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Password_reset_tokensMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type Password_reset_tokensMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token_hash: string | null
    created_at: Date | null
    expires_at: Date | null
    used_at: Date | null
  }

  export type Password_reset_tokensCountAggregateOutputType = {
    id: number
    user_id: number
    token_hash: number
    created_at: number
    expires_at: number
    used_at: number
    _all: number
  }


  export type Password_reset_tokensAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Password_reset_tokensSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Password_reset_tokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type Password_reset_tokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
  }

  export type Password_reset_tokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token_hash?: true
    created_at?: true
    expires_at?: true
    used_at?: true
    _all?: true
  }

  export type Password_reset_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to aggregate.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Password_reset_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Password_reset_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
      : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
  }




  export type password_reset_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithAggregationInput | password_reset_tokensOrderByWithAggregationInput[]
    by: Password_reset_tokensScalarFieldEnum[] | Password_reset_tokensScalarFieldEnum
    having?: password_reset_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokensCountAggregateInputType | true
    _avg?: Password_reset_tokensAvgAggregateInputType
    _sum?: Password_reset_tokensSumAggregateInputType
    _min?: Password_reset_tokensMinAggregateInputType
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type Password_reset_tokensGroupByOutputType = {
    id: number
    user_id: number
    token_hash: string
    created_at: Date | null
    expires_at: Date
    used_at: Date | null
    _count: Password_reset_tokensCountAggregateOutputType | null
    _avg: Password_reset_tokensAvgAggregateOutputType | null
    _sum: Password_reset_tokensSumAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokensGroupByPayload<T extends password_reset_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token_hash?: boolean
    created_at?: boolean
    expires_at?: boolean
    used_at?: boolean
  }

  export type password_reset_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token_hash" | "created_at" | "expires_at" | "used_at", ExtArgs["result"]["password_reset_tokens"]>
  export type password_reset_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type password_reset_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type password_reset_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $password_reset_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token_hash: string
      created_at: Date | null
      expires_at: Date
      used_at: Date | null
    }, ExtArgs["result"]["password_reset_tokens"]>
    composites: {}
  }

  type password_reset_tokensGetPayload<S extends boolean | null | undefined | password_reset_tokensDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokensPayload, S>

  type password_reset_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokensCountAggregateInputType | true
    }

  export interface password_reset_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_tokens'], meta: { name: 'password_reset_tokens' } }
    /**
     * Find zero or one Password_reset_tokens that matches the filter.
     * @param {password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokensFindUniqueArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokensFindFirstArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends password_reset_tokensFindManyArgs>(args?: SelectSubset<T, password_reset_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_tokens.
     * @param {password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
     * @example
     * // Create one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.create({
     *   data: {
     *     // ... data to create a Password_reset_tokens
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokensCreateArgs>(args: SelectSubset<T, password_reset_tokensCreateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokensCreateManyArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Password_reset_tokens and returns the data saved in the database.
     * @param {password_reset_tokensCreateManyAndReturnArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Password_reset_tokens and only return the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends password_reset_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password_reset_tokens.
     * @param {password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
     * @example
     * // Delete one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_tokens
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokensDeleteArgs>(args: SelectSubset<T, password_reset_tokensDeleteArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_tokens.
     * @param {password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
     * @example
     * // Update one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokensUpdateArgs>(args: SelectSubset<T, password_reset_tokensUpdateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokensDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokensUpdateManyArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens and returns the data updated in the database.
     * @param {password_reset_tokensUpdateManyAndReturnArgs} args - Arguments to update many Password_reset_tokens.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Password_reset_tokens and only return the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends password_reset_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password_reset_tokens.
     * @param {password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
     * @example
     * // Update or create a Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
     *   create: {
     *     // ... data to create a Password_reset_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokensUpsertArgs>(args: SelectSubset<T, password_reset_tokensUpsertArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_tokens.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokensCountArgs>(
      args?: Subset<T, password_reset_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokensAggregateArgs>(args: Subset<T, Password_reset_tokensAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

    /**
     * Group by Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokensGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_tokens model
   */
  readonly fields: password_reset_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_tokens model
   */
  interface password_reset_tokensFieldRefs {
    readonly id: FieldRef<"password_reset_tokens", 'Int'>
    readonly user_id: FieldRef<"password_reset_tokens", 'Int'>
    readonly token_hash: FieldRef<"password_reset_tokens", 'String'>
    readonly created_at: FieldRef<"password_reset_tokens", 'DateTime'>
    readonly expires_at: FieldRef<"password_reset_tokens", 'DateTime'>
    readonly used_at: FieldRef<"password_reset_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_tokens findUnique
   */
  export type password_reset_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findUniqueOrThrow
   */
  export type password_reset_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findFirst
   */
  export type password_reset_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findFirstOrThrow
   */
  export type password_reset_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findMany
   */
  export type password_reset_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens create
   */
  export type password_reset_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a password_reset_tokens.
     */
    data: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
  }

  /**
   * password_reset_tokens createMany
   */
  export type password_reset_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens createManyAndReturn
   */
  export type password_reset_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_reset_tokens update
   */
  export type password_reset_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
    /**
     * Choose, which password_reset_tokens to update.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens updateMany
   */
  export type password_reset_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens updateManyAndReturn
   */
  export type password_reset_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_reset_tokens upsert
   */
  export type password_reset_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the password_reset_tokens to update in case it exists.
     */
    where: password_reset_tokensWhereUniqueInput
    /**
     * In case the password_reset_tokens found by the `where` argument doesn't exist, create a new password_reset_tokens with this data.
     */
    create: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
    /**
     * In case the password_reset_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
  }

  /**
   * password_reset_tokens delete
   */
  export type password_reset_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter which password_reset_tokens to delete.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens deleteMany
   */
  export type password_reset_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_tokens without action
   */
  export type password_reset_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Auth_identitiesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    provider: 'provider',
    provider_user_id: 'provider_user_id',
    provider_email: 'provider_email'
  };

  export type Auth_identitiesScalarFieldEnum = (typeof Auth_identitiesScalarFieldEnum)[keyof typeof Auth_identitiesScalarFieldEnum]


  export const User_analyticsScalarFieldEnum: {
    user_id: 'user_id',
    views: 'views',
    total_spent: 'total_spent',
    number_of_purchases: 'number_of_purchases',
    successful_invites: 'successful_invites',
    monthly_confirmed_count: 'monthly_confirmed_count',
    last_confirmed_count_update: 'last_confirmed_count_update'
  };

  export type User_analyticsScalarFieldEnum = (typeof User_analyticsScalarFieldEnum)[keyof typeof User_analyticsScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    portal: 'portal',
    role: 'role'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    mongo_id: 'mongo_id',
    name: 'name',
    email: 'email',
    password: 'password',
    phone: 'phone',
    gender: 'gender',
    is_email_verified: 'is_email_verified',
    email_verified_at: 'email_verified_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    secondary_phone: 'secondary_phone',
    role: 'role',
    profile_pic_url: 'profile_pic_url',
    password_changed_at: 'password_changed_at',
    confirmed: 'confirmed',
    hasPromoCode: 'hasPromoCode',
    hasUsedPromoCode: 'hasUsedPromoCode'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Refresh_tokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token_hash: 'token_hash',
    revoked: 'revoked',
    created_at: 'created_at',
    expires_at: 'expires_at'
  };

  export type Refresh_tokensScalarFieldEnum = (typeof Refresh_tokensScalarFieldEnum)[keyof typeof Refresh_tokensScalarFieldEnum]


  export const AssistantsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    lecturer_user_id: 'lecturer_user_id'
  };

  export type AssistantsScalarFieldEnum = (typeof AssistantsScalarFieldEnum)[keyof typeof AssistantsScalarFieldEnum]


  export const GovernmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    active: 'active'
  };

  export type GovernmentScalarFieldEnum = (typeof GovernmentScalarFieldEnum)[keyof typeof GovernmentScalarFieldEnum]


  export const LecturersScalarFieldEnum: {
    user_id: 'user_id',
    bio: 'bio',
    expertise: 'expertise'
  };

  export type LecturersScalarFieldEnum = (typeof LecturersScalarFieldEnum)[keyof typeof LecturersScalarFieldEnum]


  export const LevelsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    active: 'active'
  };

  export type LevelsScalarFieldEnum = (typeof LevelsScalarFieldEnum)[keyof typeof LevelsScalarFieldEnum]


  export const Parent_childrenScalarFieldEnum: {
    id: 'id',
    parent_user_id: 'parent_user_id',
    student_user_id: 'student_user_id'
  };

  export type Parent_childrenScalarFieldEnum = (typeof Parent_childrenScalarFieldEnum)[keyof typeof Parent_childrenScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    user_id: 'user_id',
    government_id: 'government_id',
    zone_id: 'zone_id'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const SitesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    active: 'active'
  };

  export type SitesScalarFieldEnum = (typeof SitesScalarFieldEnum)[keyof typeof SitesScalarFieldEnum]


  export const Social_mediaScalarFieldEnum: {
    id: 'id',
    teacher_user_id: 'teacher_user_id',
    site_id: 'site_id',
    url: 'url',
    active: 'active'
  };

  export type Social_mediaScalarFieldEnum = (typeof Social_mediaScalarFieldEnum)[keyof typeof Social_mediaScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    user_id: 'user_id',
    level_id: 'level_id',
    government_id: 'government_id',
    zone_id: 'zone_id',
    parent_phone_number: 'parent_phone_number',
    sequenced_id: 'sequenced_id',
    faction: 'faction'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    active: 'active'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    user_id: 'user_id',
    serial: 'serial',
    is_primary: 'is_primary',
    is_preparatory: 'is_preparatory',
    is_secondary: 'is_secondary',
    government_id: 'government_id',
    zone_id: 'zone_id',
    subject_id: 'subject_id'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const Teaches_atScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    location_name: 'location_name',
    location_type: 'location_type',
    active: 'active'
  };

  export type Teaches_atScalarFieldEnum = (typeof Teaches_atScalarFieldEnum)[keyof typeof Teaches_atScalarFieldEnum]


  export const ZonesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    government_id: 'government_id',
    active: 'active'
  };

  export type ZonesScalarFieldEnum = (typeof ZonesScalarFieldEnum)[keyof typeof ZonesScalarFieldEnum]


  export const Email_verification_tokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token_hash: 'token_hash',
    created_at: 'created_at',
    expires_at: 'expires_at',
    used_at: 'used_at'
  };

  export type Email_verification_tokensScalarFieldEnum = (typeof Email_verification_tokensScalarFieldEnum)[keyof typeof Email_verification_tokensScalarFieldEnum]


  export const Password_reset_tokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token_hash: 'token_hash',
    created_at: 'created_at',
    expires_at: 'expires_at',
    used_at: 'used_at'
  };

  export type Password_reset_tokensScalarFieldEnum = (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'auth_provider_enum'
   */
  export type Enumauth_provider_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'auth_provider_enum'>
    


  /**
   * Reference to a field of type 'auth_provider_enum[]'
   */
  export type ListEnumauth_provider_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'auth_provider_enum[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'portal_enum'
   */
  export type Enumportal_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'portal_enum'>
    


  /**
   * Reference to a field of type 'portal_enum[]'
   */
  export type ListEnumportal_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'portal_enum[]'>
    


  /**
   * Reference to a field of type 'role_enum'
   */
  export type Enumrole_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role_enum'>
    


  /**
   * Reference to a field of type 'role_enum[]'
   */
  export type ListEnumrole_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role_enum[]'>
    


  /**
   * Reference to a field of type 'gender_enum'
   */
  export type Enumgender_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'gender_enum'>
    


  /**
   * Reference to a field of type 'gender_enum[]'
   */
  export type ListEnumgender_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'gender_enum[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'location_type_enum'
   */
  export type Enumlocation_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'location_type_enum'>
    


  /**
   * Reference to a field of type 'location_type_enum[]'
   */
  export type ListEnumlocation_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'location_type_enum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type auth_identitiesWhereInput = {
    AND?: auth_identitiesWhereInput | auth_identitiesWhereInput[]
    OR?: auth_identitiesWhereInput[]
    NOT?: auth_identitiesWhereInput | auth_identitiesWhereInput[]
    id?: IntFilter<"auth_identities"> | number
    user_id?: IntFilter<"auth_identities"> | number
    provider?: Enumauth_provider_enumFilter<"auth_identities"> | $Enums.auth_provider_enum
    provider_user_id?: StringFilter<"auth_identities"> | string
    provider_email?: StringNullableFilter<"auth_identities"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type auth_identitiesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_user_id?: SortOrder
    provider_email?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type auth_identitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    provider_provider_user_id?: auth_identitiesProviderProvider_user_idCompoundUniqueInput
    AND?: auth_identitiesWhereInput | auth_identitiesWhereInput[]
    OR?: auth_identitiesWhereInput[]
    NOT?: auth_identitiesWhereInput | auth_identitiesWhereInput[]
    user_id?: IntFilter<"auth_identities"> | number
    provider?: Enumauth_provider_enumFilter<"auth_identities"> | $Enums.auth_provider_enum
    provider_user_id?: StringFilter<"auth_identities"> | string
    provider_email?: StringNullableFilter<"auth_identities"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "provider_provider_user_id">

  export type auth_identitiesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_user_id?: SortOrder
    provider_email?: SortOrderInput | SortOrder
    _count?: auth_identitiesCountOrderByAggregateInput
    _avg?: auth_identitiesAvgOrderByAggregateInput
    _max?: auth_identitiesMaxOrderByAggregateInput
    _min?: auth_identitiesMinOrderByAggregateInput
    _sum?: auth_identitiesSumOrderByAggregateInput
  }

  export type auth_identitiesScalarWhereWithAggregatesInput = {
    AND?: auth_identitiesScalarWhereWithAggregatesInput | auth_identitiesScalarWhereWithAggregatesInput[]
    OR?: auth_identitiesScalarWhereWithAggregatesInput[]
    NOT?: auth_identitiesScalarWhereWithAggregatesInput | auth_identitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auth_identities"> | number
    user_id?: IntWithAggregatesFilter<"auth_identities"> | number
    provider?: Enumauth_provider_enumWithAggregatesFilter<"auth_identities"> | $Enums.auth_provider_enum
    provider_user_id?: StringWithAggregatesFilter<"auth_identities"> | string
    provider_email?: StringNullableWithAggregatesFilter<"auth_identities"> | string | null
  }

  export type user_analyticsWhereInput = {
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    user_id?: IntFilter<"user_analytics"> | number
    views?: IntNullableFilter<"user_analytics"> | number | null
    total_spent?: DecimalNullableFilter<"user_analytics"> | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: IntNullableFilter<"user_analytics"> | number | null
    successful_invites?: IntNullableFilter<"user_analytics"> | number | null
    monthly_confirmed_count?: IntNullableFilter<"user_analytics"> | number | null
    last_confirmed_count_update?: DateTimeNullableFilter<"user_analytics"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_analyticsOrderByWithRelationInput = {
    user_id?: SortOrder
    views?: SortOrderInput | SortOrder
    total_spent?: SortOrderInput | SortOrder
    number_of_purchases?: SortOrderInput | SortOrder
    successful_invites?: SortOrderInput | SortOrder
    monthly_confirmed_count?: SortOrderInput | SortOrder
    last_confirmed_count_update?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_analyticsWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    views?: IntNullableFilter<"user_analytics"> | number | null
    total_spent?: DecimalNullableFilter<"user_analytics"> | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: IntNullableFilter<"user_analytics"> | number | null
    successful_invites?: IntNullableFilter<"user_analytics"> | number | null
    monthly_confirmed_count?: IntNullableFilter<"user_analytics"> | number | null
    last_confirmed_count_update?: DateTimeNullableFilter<"user_analytics"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id">

  export type user_analyticsOrderByWithAggregationInput = {
    user_id?: SortOrder
    views?: SortOrderInput | SortOrder
    total_spent?: SortOrderInput | SortOrder
    number_of_purchases?: SortOrderInput | SortOrder
    successful_invites?: SortOrderInput | SortOrder
    monthly_confirmed_count?: SortOrderInput | SortOrder
    last_confirmed_count_update?: SortOrderInput | SortOrder
    _count?: user_analyticsCountOrderByAggregateInput
    _avg?: user_analyticsAvgOrderByAggregateInput
    _max?: user_analyticsMaxOrderByAggregateInput
    _min?: user_analyticsMinOrderByAggregateInput
    _sum?: user_analyticsSumOrderByAggregateInput
  }

  export type user_analyticsScalarWhereWithAggregatesInput = {
    AND?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    OR?: user_analyticsScalarWhereWithAggregatesInput[]
    NOT?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user_analytics"> | number
    views?: IntNullableWithAggregatesFilter<"user_analytics"> | number | null
    total_spent?: DecimalNullableWithAggregatesFilter<"user_analytics"> | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: IntNullableWithAggregatesFilter<"user_analytics"> | number | null
    successful_invites?: IntNullableWithAggregatesFilter<"user_analytics"> | number | null
    monthly_confirmed_count?: IntNullableWithAggregatesFilter<"user_analytics"> | number | null
    last_confirmed_count_update?: DateTimeNullableWithAggregatesFilter<"user_analytics"> | Date | string | null
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    id?: IntFilter<"user_roles"> | number
    user_id?: IntFilter<"user_roles"> | number
    portal?: Enumportal_enumFilter<"user_roles"> | $Enums.portal_enum
    role?: Enumrole_enumFilter<"user_roles"> | $Enums.role_enum
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    portal?: SortOrder
    role?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_portal_role?: user_rolesUser_idPortalRoleCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    user_id?: IntFilter<"user_roles"> | number
    portal?: Enumportal_enumFilter<"user_roles"> | $Enums.portal_enum
    role?: Enumrole_enumFilter<"user_roles"> | $Enums.role_enum
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "user_id_portal_role">

  export type user_rolesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    portal?: SortOrder
    role?: SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _avg?: user_rolesAvgOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
    _sum?: user_rolesSumOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_roles"> | number
    user_id?: IntWithAggregatesFilter<"user_roles"> | number
    portal?: Enumportal_enumWithAggregatesFilter<"user_roles"> | $Enums.portal_enum
    role?: Enumrole_enumWithAggregatesFilter<"user_roles"> | $Enums.role_enum
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    mongo_id?: StringNullableFilter<"users"> | string | null
    name?: StringFilter<"users"> | string
    email?: StringNullableFilter<"users"> | string | null
    password?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    gender?: Enumgender_enumNullableFilter<"users"> | $Enums.gender_enum | null
    is_email_verified?: BoolNullableFilter<"users"> | boolean | null
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    secondary_phone?: StringNullableFilter<"users"> | string | null
    role?: Enumrole_enumNullableFilter<"users"> | $Enums.role_enum | null
    profile_pic_url?: StringNullableFilter<"users"> | string | null
    password_changed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmed?: BoolNullableFilter<"users"> | boolean | null
    hasPromoCode?: BoolNullableFilter<"users"> | boolean | null
    hasUsedPromoCode?: BoolNullableFilter<"users"> | boolean | null
    assistants?: AssistantsListRelationFilter
    auth_identities?: Auth_identitiesListRelationFilter
    email_verification_tokens?: XOR<Email_verification_tokensNullableScalarRelationFilter, email_verification_tokensWhereInput> | null
    lecturers?: XOR<LecturersNullableScalarRelationFilter, lecturersWhereInput> | null
    parents?: XOR<ParentsNullableScalarRelationFilter, parentsWhereInput> | null
    password_reset_tokens?: XOR<Password_reset_tokensNullableScalarRelationFilter, password_reset_tokensWhereInput> | null
    refresh_tokens?: Refresh_tokensListRelationFilter
    social_media?: Social_mediaListRelationFilter
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    teaches_at?: Teaches_atListRelationFilter
    user_analytics?: XOR<User_analyticsNullableScalarRelationFilter, user_analyticsWhereInput> | null
    user_roles?: User_rolesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    mongo_id?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_email_verified?: SortOrderInput | SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    secondary_phone?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    profile_pic_url?: SortOrderInput | SortOrder
    password_changed_at?: SortOrderInput | SortOrder
    confirmed?: SortOrderInput | SortOrder
    hasPromoCode?: SortOrderInput | SortOrder
    hasUsedPromoCode?: SortOrderInput | SortOrder
    assistants?: assistantsOrderByRelationAggregateInput
    auth_identities?: auth_identitiesOrderByRelationAggregateInput
    email_verification_tokens?: email_verification_tokensOrderByWithRelationInput
    lecturers?: lecturersOrderByWithRelationInput
    parents?: parentsOrderByWithRelationInput
    password_reset_tokens?: password_reset_tokensOrderByWithRelationInput
    refresh_tokens?: refresh_tokensOrderByRelationAggregateInput
    social_media?: social_mediaOrderByRelationAggregateInput
    students?: studentsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    teaches_at?: teaches_atOrderByRelationAggregateInput
    user_analytics?: user_analyticsOrderByWithRelationInput
    user_roles?: user_rolesOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mongo_id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    password?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    gender?: Enumgender_enumNullableFilter<"users"> | $Enums.gender_enum | null
    is_email_verified?: BoolNullableFilter<"users"> | boolean | null
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    secondary_phone?: StringNullableFilter<"users"> | string | null
    role?: Enumrole_enumNullableFilter<"users"> | $Enums.role_enum | null
    profile_pic_url?: StringNullableFilter<"users"> | string | null
    password_changed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    confirmed?: BoolNullableFilter<"users"> | boolean | null
    hasPromoCode?: BoolNullableFilter<"users"> | boolean | null
    hasUsedPromoCode?: BoolNullableFilter<"users"> | boolean | null
    assistants?: AssistantsListRelationFilter
    auth_identities?: Auth_identitiesListRelationFilter
    email_verification_tokens?: XOR<Email_verification_tokensNullableScalarRelationFilter, email_verification_tokensWhereInput> | null
    lecturers?: XOR<LecturersNullableScalarRelationFilter, lecturersWhereInput> | null
    parents?: XOR<ParentsNullableScalarRelationFilter, parentsWhereInput> | null
    password_reset_tokens?: XOR<Password_reset_tokensNullableScalarRelationFilter, password_reset_tokensWhereInput> | null
    refresh_tokens?: Refresh_tokensListRelationFilter
    social_media?: Social_mediaListRelationFilter
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    teaches_at?: Teaches_atListRelationFilter
    user_analytics?: XOR<User_analyticsNullableScalarRelationFilter, user_analyticsWhereInput> | null
    user_roles?: User_rolesListRelationFilter
  }, "id" | "mongo_id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    mongo_id?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_email_verified?: SortOrderInput | SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    secondary_phone?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    profile_pic_url?: SortOrderInput | SortOrder
    password_changed_at?: SortOrderInput | SortOrder
    confirmed?: SortOrderInput | SortOrder
    hasPromoCode?: SortOrderInput | SortOrder
    hasUsedPromoCode?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    mongo_id?: StringNullableWithAggregatesFilter<"users"> | string | null
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    password?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    gender?: Enumgender_enumNullableWithAggregatesFilter<"users"> | $Enums.gender_enum | null
    is_email_verified?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    secondary_phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    role?: Enumrole_enumNullableWithAggregatesFilter<"users"> | $Enums.role_enum | null
    profile_pic_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    password_changed_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    confirmed?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    hasPromoCode?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    hasUsedPromoCode?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
  }

  export type refresh_tokensWhereInput = {
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    id?: IntFilter<"refresh_tokens"> | number
    user_id?: IntFilter<"refresh_tokens"> | number
    token_hash?: StringFilter<"refresh_tokens"> | string
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"refresh_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type refresh_tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    revoked?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type refresh_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    user_id?: IntFilter<"refresh_tokens"> | number
    token_hash?: StringFilter<"refresh_tokens"> | string
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"refresh_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type refresh_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    revoked?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    _count?: refresh_tokensCountOrderByAggregateInput
    _avg?: refresh_tokensAvgOrderByAggregateInput
    _max?: refresh_tokensMaxOrderByAggregateInput
    _min?: refresh_tokensMinOrderByAggregateInput
    _sum?: refresh_tokensSumOrderByAggregateInput
  }

  export type refresh_tokensScalarWhereWithAggregatesInput = {
    AND?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    OR?: refresh_tokensScalarWhereWithAggregatesInput[]
    NOT?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refresh_tokens"> | number
    user_id?: IntWithAggregatesFilter<"refresh_tokens"> | number
    token_hash?: StringWithAggregatesFilter<"refresh_tokens"> | string
    revoked?: BoolNullableWithAggregatesFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"refresh_tokens"> | Date | string | null
    expires_at?: DateTimeWithAggregatesFilter<"refresh_tokens"> | Date | string
  }

  export type assistantsWhereInput = {
    AND?: assistantsWhereInput | assistantsWhereInput[]
    OR?: assistantsWhereInput[]
    NOT?: assistantsWhereInput | assistantsWhereInput[]
    id?: IntFilter<"assistants"> | number
    user_id?: IntFilter<"assistants"> | number
    lecturer_user_id?: IntFilter<"assistants"> | number
    lecturers?: XOR<LecturersScalarRelationFilter, lecturersWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type assistantsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
    lecturers?: lecturersOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type assistantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: assistantsWhereInput | assistantsWhereInput[]
    OR?: assistantsWhereInput[]
    NOT?: assistantsWhereInput | assistantsWhereInput[]
    user_id?: IntFilter<"assistants"> | number
    lecturer_user_id?: IntFilter<"assistants"> | number
    lecturers?: XOR<LecturersScalarRelationFilter, lecturersWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type assistantsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
    _count?: assistantsCountOrderByAggregateInput
    _avg?: assistantsAvgOrderByAggregateInput
    _max?: assistantsMaxOrderByAggregateInput
    _min?: assistantsMinOrderByAggregateInput
    _sum?: assistantsSumOrderByAggregateInput
  }

  export type assistantsScalarWhereWithAggregatesInput = {
    AND?: assistantsScalarWhereWithAggregatesInput | assistantsScalarWhereWithAggregatesInput[]
    OR?: assistantsScalarWhereWithAggregatesInput[]
    NOT?: assistantsScalarWhereWithAggregatesInput | assistantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"assistants"> | number
    user_id?: IntWithAggregatesFilter<"assistants"> | number
    lecturer_user_id?: IntWithAggregatesFilter<"assistants"> | number
  }

  export type governmentWhereInput = {
    AND?: governmentWhereInput | governmentWhereInput[]
    OR?: governmentWhereInput[]
    NOT?: governmentWhereInput | governmentWhereInput[]
    id?: IntFilter<"government"> | number
    title?: StringFilter<"government"> | string
    active?: BoolNullableFilter<"government"> | boolean | null
    parents?: ParentsListRelationFilter
    students?: StudentsListRelationFilter
    teachers?: TeachersListRelationFilter
    zones?: ZonesListRelationFilter
  }

  export type governmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    parents?: parentsOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
    teachers?: teachersOrderByRelationAggregateInput
    zones?: zonesOrderByRelationAggregateInput
  }

  export type governmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: governmentWhereInput | governmentWhereInput[]
    OR?: governmentWhereInput[]
    NOT?: governmentWhereInput | governmentWhereInput[]
    active?: BoolNullableFilter<"government"> | boolean | null
    parents?: ParentsListRelationFilter
    students?: StudentsListRelationFilter
    teachers?: TeachersListRelationFilter
    zones?: ZonesListRelationFilter
  }, "id" | "title">

  export type governmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: governmentCountOrderByAggregateInput
    _avg?: governmentAvgOrderByAggregateInput
    _max?: governmentMaxOrderByAggregateInput
    _min?: governmentMinOrderByAggregateInput
    _sum?: governmentSumOrderByAggregateInput
  }

  export type governmentScalarWhereWithAggregatesInput = {
    AND?: governmentScalarWhereWithAggregatesInput | governmentScalarWhereWithAggregatesInput[]
    OR?: governmentScalarWhereWithAggregatesInput[]
    NOT?: governmentScalarWhereWithAggregatesInput | governmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"government"> | number
    title?: StringWithAggregatesFilter<"government"> | string
    active?: BoolNullableWithAggregatesFilter<"government"> | boolean | null
  }

  export type lecturersWhereInput = {
    AND?: lecturersWhereInput | lecturersWhereInput[]
    OR?: lecturersWhereInput[]
    NOT?: lecturersWhereInput | lecturersWhereInput[]
    user_id?: IntFilter<"lecturers"> | number
    bio?: StringNullableFilter<"lecturers"> | string | null
    expertise?: StringNullableFilter<"lecturers"> | string | null
    assistants?: AssistantsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type lecturersOrderByWithRelationInput = {
    user_id?: SortOrder
    bio?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    assistants?: assistantsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type lecturersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: lecturersWhereInput | lecturersWhereInput[]
    OR?: lecturersWhereInput[]
    NOT?: lecturersWhereInput | lecturersWhereInput[]
    bio?: StringNullableFilter<"lecturers"> | string | null
    expertise?: StringNullableFilter<"lecturers"> | string | null
    assistants?: AssistantsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id">

  export type lecturersOrderByWithAggregationInput = {
    user_id?: SortOrder
    bio?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    _count?: lecturersCountOrderByAggregateInput
    _avg?: lecturersAvgOrderByAggregateInput
    _max?: lecturersMaxOrderByAggregateInput
    _min?: lecturersMinOrderByAggregateInput
    _sum?: lecturersSumOrderByAggregateInput
  }

  export type lecturersScalarWhereWithAggregatesInput = {
    AND?: lecturersScalarWhereWithAggregatesInput | lecturersScalarWhereWithAggregatesInput[]
    OR?: lecturersScalarWhereWithAggregatesInput[]
    NOT?: lecturersScalarWhereWithAggregatesInput | lecturersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"lecturers"> | number
    bio?: StringNullableWithAggregatesFilter<"lecturers"> | string | null
    expertise?: StringNullableWithAggregatesFilter<"lecturers"> | string | null
  }

  export type levelsWhereInput = {
    AND?: levelsWhereInput | levelsWhereInput[]
    OR?: levelsWhereInput[]
    NOT?: levelsWhereInput | levelsWhereInput[]
    id?: IntFilter<"levels"> | number
    title?: StringFilter<"levels"> | string
    active?: BoolNullableFilter<"levels"> | boolean | null
    students?: StudentsListRelationFilter
  }

  export type levelsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    students?: studentsOrderByRelationAggregateInput
  }

  export type levelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: levelsWhereInput | levelsWhereInput[]
    OR?: levelsWhereInput[]
    NOT?: levelsWhereInput | levelsWhereInput[]
    active?: BoolNullableFilter<"levels"> | boolean | null
    students?: StudentsListRelationFilter
  }, "id" | "title">

  export type levelsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: levelsCountOrderByAggregateInput
    _avg?: levelsAvgOrderByAggregateInput
    _max?: levelsMaxOrderByAggregateInput
    _min?: levelsMinOrderByAggregateInput
    _sum?: levelsSumOrderByAggregateInput
  }

  export type levelsScalarWhereWithAggregatesInput = {
    AND?: levelsScalarWhereWithAggregatesInput | levelsScalarWhereWithAggregatesInput[]
    OR?: levelsScalarWhereWithAggregatesInput[]
    NOT?: levelsScalarWhereWithAggregatesInput | levelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"levels"> | number
    title?: StringWithAggregatesFilter<"levels"> | string
    active?: BoolNullableWithAggregatesFilter<"levels"> | boolean | null
  }

  export type parent_childrenWhereInput = {
    AND?: parent_childrenWhereInput | parent_childrenWhereInput[]
    OR?: parent_childrenWhereInput[]
    NOT?: parent_childrenWhereInput | parent_childrenWhereInput[]
    id?: IntFilter<"parent_children"> | number
    parent_user_id?: IntFilter<"parent_children"> | number
    student_user_id?: IntFilter<"parent_children"> | number
    parents?: XOR<ParentsScalarRelationFilter, parentsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type parent_childrenOrderByWithRelationInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
    parents?: parentsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type parent_childrenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parent_user_id_student_user_id?: parent_childrenParent_user_idStudent_user_idCompoundUniqueInput
    AND?: parent_childrenWhereInput | parent_childrenWhereInput[]
    OR?: parent_childrenWhereInput[]
    NOT?: parent_childrenWhereInput | parent_childrenWhereInput[]
    parent_user_id?: IntFilter<"parent_children"> | number
    student_user_id?: IntFilter<"parent_children"> | number
    parents?: XOR<ParentsScalarRelationFilter, parentsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "id" | "parent_user_id_student_user_id">

  export type parent_childrenOrderByWithAggregationInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
    _count?: parent_childrenCountOrderByAggregateInput
    _avg?: parent_childrenAvgOrderByAggregateInput
    _max?: parent_childrenMaxOrderByAggregateInput
    _min?: parent_childrenMinOrderByAggregateInput
    _sum?: parent_childrenSumOrderByAggregateInput
  }

  export type parent_childrenScalarWhereWithAggregatesInput = {
    AND?: parent_childrenScalarWhereWithAggregatesInput | parent_childrenScalarWhereWithAggregatesInput[]
    OR?: parent_childrenScalarWhereWithAggregatesInput[]
    NOT?: parent_childrenScalarWhereWithAggregatesInput | parent_childrenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"parent_children"> | number
    parent_user_id?: IntWithAggregatesFilter<"parent_children"> | number
    student_user_id?: IntWithAggregatesFilter<"parent_children"> | number
  }

  export type parentsWhereInput = {
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    user_id?: IntFilter<"parents"> | number
    government_id?: IntNullableFilter<"parents"> | number | null
    zone_id?: IntNullableFilter<"parents"> | number | null
    parent_children?: Parent_childrenListRelationFilter
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }

  export type parentsOrderByWithRelationInput = {
    user_id?: SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    parent_children?: parent_childrenOrderByRelationAggregateInput
    government?: governmentOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    zones?: zonesOrderByWithRelationInput
  }

  export type parentsWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    government_id?: IntNullableFilter<"parents"> | number | null
    zone_id?: IntNullableFilter<"parents"> | number | null
    parent_children?: Parent_childrenListRelationFilter
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }, "user_id">

  export type parentsOrderByWithAggregationInput = {
    user_id?: SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    _count?: parentsCountOrderByAggregateInput
    _avg?: parentsAvgOrderByAggregateInput
    _max?: parentsMaxOrderByAggregateInput
    _min?: parentsMinOrderByAggregateInput
    _sum?: parentsSumOrderByAggregateInput
  }

  export type parentsScalarWhereWithAggregatesInput = {
    AND?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    OR?: parentsScalarWhereWithAggregatesInput[]
    NOT?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"parents"> | number
    government_id?: IntNullableWithAggregatesFilter<"parents"> | number | null
    zone_id?: IntNullableWithAggregatesFilter<"parents"> | number | null
  }

  export type sitesWhereInput = {
    AND?: sitesWhereInput | sitesWhereInput[]
    OR?: sitesWhereInput[]
    NOT?: sitesWhereInput | sitesWhereInput[]
    id?: IntFilter<"sites"> | number
    title?: StringFilter<"sites"> | string
    active?: BoolNullableFilter<"sites"> | boolean | null
    social_media?: Social_mediaListRelationFilter
  }

  export type sitesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    social_media?: social_mediaOrderByRelationAggregateInput
  }

  export type sitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: sitesWhereInput | sitesWhereInput[]
    OR?: sitesWhereInput[]
    NOT?: sitesWhereInput | sitesWhereInput[]
    active?: BoolNullableFilter<"sites"> | boolean | null
    social_media?: Social_mediaListRelationFilter
  }, "id" | "title">

  export type sitesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: sitesCountOrderByAggregateInput
    _avg?: sitesAvgOrderByAggregateInput
    _max?: sitesMaxOrderByAggregateInput
    _min?: sitesMinOrderByAggregateInput
    _sum?: sitesSumOrderByAggregateInput
  }

  export type sitesScalarWhereWithAggregatesInput = {
    AND?: sitesScalarWhereWithAggregatesInput | sitesScalarWhereWithAggregatesInput[]
    OR?: sitesScalarWhereWithAggregatesInput[]
    NOT?: sitesScalarWhereWithAggregatesInput | sitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sites"> | number
    title?: StringWithAggregatesFilter<"sites"> | string
    active?: BoolNullableWithAggregatesFilter<"sites"> | boolean | null
  }

  export type social_mediaWhereInput = {
    AND?: social_mediaWhereInput | social_mediaWhereInput[]
    OR?: social_mediaWhereInput[]
    NOT?: social_mediaWhereInput | social_mediaWhereInput[]
    id?: IntFilter<"social_media"> | number
    teacher_user_id?: IntFilter<"social_media"> | number
    site_id?: IntNullableFilter<"social_media"> | number | null
    url?: StringFilter<"social_media"> | string
    active?: BoolNullableFilter<"social_media"> | boolean | null
    sites?: XOR<SitesNullableScalarRelationFilter, sitesWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type social_mediaOrderByWithRelationInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrderInput | SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    sites?: sitesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type social_mediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: social_mediaWhereInput | social_mediaWhereInput[]
    OR?: social_mediaWhereInput[]
    NOT?: social_mediaWhereInput | social_mediaWhereInput[]
    teacher_user_id?: IntFilter<"social_media"> | number
    site_id?: IntNullableFilter<"social_media"> | number | null
    url?: StringFilter<"social_media"> | string
    active?: BoolNullableFilter<"social_media"> | boolean | null
    sites?: XOR<SitesNullableScalarRelationFilter, sitesWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type social_mediaOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrderInput | SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: social_mediaCountOrderByAggregateInput
    _avg?: social_mediaAvgOrderByAggregateInput
    _max?: social_mediaMaxOrderByAggregateInput
    _min?: social_mediaMinOrderByAggregateInput
    _sum?: social_mediaSumOrderByAggregateInput
  }

  export type social_mediaScalarWhereWithAggregatesInput = {
    AND?: social_mediaScalarWhereWithAggregatesInput | social_mediaScalarWhereWithAggregatesInput[]
    OR?: social_mediaScalarWhereWithAggregatesInput[]
    NOT?: social_mediaScalarWhereWithAggregatesInput | social_mediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"social_media"> | number
    teacher_user_id?: IntWithAggregatesFilter<"social_media"> | number
    site_id?: IntNullableWithAggregatesFilter<"social_media"> | number | null
    url?: StringWithAggregatesFilter<"social_media"> | string
    active?: BoolNullableWithAggregatesFilter<"social_media"> | boolean | null
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    user_id?: IntFilter<"students"> | number
    level_id?: IntNullableFilter<"students"> | number | null
    government_id?: IntNullableFilter<"students"> | number | null
    zone_id?: IntNullableFilter<"students"> | number | null
    parent_phone_number?: StringNullableFilter<"students"> | string | null
    sequenced_id?: IntNullableFilter<"students"> | number | null
    faction?: StringNullableFilter<"students"> | string | null
    parent_children?: Parent_childrenListRelationFilter
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    levels?: XOR<LevelsNullableScalarRelationFilter, levelsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }

  export type studentsOrderByWithRelationInput = {
    user_id?: SortOrder
    level_id?: SortOrderInput | SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    parent_phone_number?: SortOrderInput | SortOrder
    sequenced_id?: SortOrderInput | SortOrder
    faction?: SortOrderInput | SortOrder
    parent_children?: parent_childrenOrderByRelationAggregateInput
    government?: governmentOrderByWithRelationInput
    levels?: levelsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    zones?: zonesOrderByWithRelationInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    level_id?: IntNullableFilter<"students"> | number | null
    government_id?: IntNullableFilter<"students"> | number | null
    zone_id?: IntNullableFilter<"students"> | number | null
    parent_phone_number?: StringNullableFilter<"students"> | string | null
    sequenced_id?: IntNullableFilter<"students"> | number | null
    faction?: StringNullableFilter<"students"> | string | null
    parent_children?: Parent_childrenListRelationFilter
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    levels?: XOR<LevelsNullableScalarRelationFilter, levelsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }, "user_id">

  export type studentsOrderByWithAggregationInput = {
    user_id?: SortOrder
    level_id?: SortOrderInput | SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    parent_phone_number?: SortOrderInput | SortOrder
    sequenced_id?: SortOrderInput | SortOrder
    faction?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _avg?: studentsAvgOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
    _sum?: studentsSumOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"students"> | number
    level_id?: IntNullableWithAggregatesFilter<"students"> | number | null
    government_id?: IntNullableWithAggregatesFilter<"students"> | number | null
    zone_id?: IntNullableWithAggregatesFilter<"students"> | number | null
    parent_phone_number?: StringNullableWithAggregatesFilter<"students"> | string | null
    sequenced_id?: IntNullableWithAggregatesFilter<"students"> | number | null
    faction?: StringNullableWithAggregatesFilter<"students"> | string | null
  }

  export type subjectsWhereInput = {
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    id?: IntFilter<"subjects"> | number
    title?: StringFilter<"subjects"> | string
    active?: BoolNullableFilter<"subjects"> | boolean | null
    teachers?: TeachersListRelationFilter
  }

  export type subjectsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    teachers?: teachersOrderByRelationAggregateInput
  }

  export type subjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    active?: BoolNullableFilter<"subjects"> | boolean | null
    teachers?: TeachersListRelationFilter
  }, "id" | "title">

  export type subjectsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: subjectsCountOrderByAggregateInput
    _avg?: subjectsAvgOrderByAggregateInput
    _max?: subjectsMaxOrderByAggregateInput
    _min?: subjectsMinOrderByAggregateInput
    _sum?: subjectsSumOrderByAggregateInput
  }

  export type subjectsScalarWhereWithAggregatesInput = {
    AND?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    OR?: subjectsScalarWhereWithAggregatesInput[]
    NOT?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"subjects"> | number
    title?: StringWithAggregatesFilter<"subjects"> | string
    active?: BoolNullableWithAggregatesFilter<"subjects"> | boolean | null
  }

  export type teachersWhereInput = {
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    user_id?: IntFilter<"teachers"> | number
    serial?: StringNullableFilter<"teachers"> | string | null
    is_primary?: BoolNullableFilter<"teachers"> | boolean | null
    is_preparatory?: BoolNullableFilter<"teachers"> | boolean | null
    is_secondary?: BoolNullableFilter<"teachers"> | boolean | null
    government_id?: IntNullableFilter<"teachers"> | number | null
    zone_id?: IntNullableFilter<"teachers"> | number | null
    subject_id?: IntNullableFilter<"teachers"> | number | null
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }

  export type teachersOrderByWithRelationInput = {
    user_id?: SortOrder
    serial?: SortOrderInput | SortOrder
    is_primary?: SortOrderInput | SortOrder
    is_preparatory?: SortOrderInput | SortOrder
    is_secondary?: SortOrderInput | SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    government?: governmentOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    zones?: zonesOrderByWithRelationInput
  }

  export type teachersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    serial?: string
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    is_primary?: BoolNullableFilter<"teachers"> | boolean | null
    is_preparatory?: BoolNullableFilter<"teachers"> | boolean | null
    is_secondary?: BoolNullableFilter<"teachers"> | boolean | null
    government_id?: IntNullableFilter<"teachers"> | number | null
    zone_id?: IntNullableFilter<"teachers"> | number | null
    subject_id?: IntNullableFilter<"teachers"> | number | null
    government?: XOR<GovernmentNullableScalarRelationFilter, governmentWhereInput> | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }, "user_id" | "serial">

  export type teachersOrderByWithAggregationInput = {
    user_id?: SortOrder
    serial?: SortOrderInput | SortOrder
    is_primary?: SortOrderInput | SortOrder
    is_preparatory?: SortOrderInput | SortOrder
    is_secondary?: SortOrderInput | SortOrder
    government_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    _count?: teachersCountOrderByAggregateInput
    _avg?: teachersAvgOrderByAggregateInput
    _max?: teachersMaxOrderByAggregateInput
    _min?: teachersMinOrderByAggregateInput
    _sum?: teachersSumOrderByAggregateInput
  }

  export type teachersScalarWhereWithAggregatesInput = {
    AND?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    OR?: teachersScalarWhereWithAggregatesInput[]
    NOT?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"teachers"> | number
    serial?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    is_primary?: BoolNullableWithAggregatesFilter<"teachers"> | boolean | null
    is_preparatory?: BoolNullableWithAggregatesFilter<"teachers"> | boolean | null
    is_secondary?: BoolNullableWithAggregatesFilter<"teachers"> | boolean | null
    government_id?: IntNullableWithAggregatesFilter<"teachers"> | number | null
    zone_id?: IntNullableWithAggregatesFilter<"teachers"> | number | null
    subject_id?: IntNullableWithAggregatesFilter<"teachers"> | number | null
  }

  export type teaches_atWhereInput = {
    AND?: teaches_atWhereInput | teaches_atWhereInput[]
    OR?: teaches_atWhereInput[]
    NOT?: teaches_atWhereInput | teaches_atWhereInput[]
    id?: IntFilter<"teaches_at"> | number
    user_id?: IntFilter<"teaches_at"> | number
    location_name?: StringNullableFilter<"teaches_at"> | string | null
    location_type?: Enumlocation_type_enumNullableFilter<"teaches_at"> | $Enums.location_type_enum | null
    active?: BoolNullableFilter<"teaches_at"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type teaches_atOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_name?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type teaches_atWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: teaches_atWhereInput | teaches_atWhereInput[]
    OR?: teaches_atWhereInput[]
    NOT?: teaches_atWhereInput | teaches_atWhereInput[]
    user_id?: IntFilter<"teaches_at"> | number
    location_name?: StringNullableFilter<"teaches_at"> | string | null
    location_type?: Enumlocation_type_enumNullableFilter<"teaches_at"> | $Enums.location_type_enum | null
    active?: BoolNullableFilter<"teaches_at"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type teaches_atOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_name?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    _count?: teaches_atCountOrderByAggregateInput
    _avg?: teaches_atAvgOrderByAggregateInput
    _max?: teaches_atMaxOrderByAggregateInput
    _min?: teaches_atMinOrderByAggregateInput
    _sum?: teaches_atSumOrderByAggregateInput
  }

  export type teaches_atScalarWhereWithAggregatesInput = {
    AND?: teaches_atScalarWhereWithAggregatesInput | teaches_atScalarWhereWithAggregatesInput[]
    OR?: teaches_atScalarWhereWithAggregatesInput[]
    NOT?: teaches_atScalarWhereWithAggregatesInput | teaches_atScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"teaches_at"> | number
    user_id?: IntWithAggregatesFilter<"teaches_at"> | number
    location_name?: StringNullableWithAggregatesFilter<"teaches_at"> | string | null
    location_type?: Enumlocation_type_enumNullableWithAggregatesFilter<"teaches_at"> | $Enums.location_type_enum | null
    active?: BoolNullableWithAggregatesFilter<"teaches_at"> | boolean | null
  }

  export type zonesWhereInput = {
    AND?: zonesWhereInput | zonesWhereInput[]
    OR?: zonesWhereInput[]
    NOT?: zonesWhereInput | zonesWhereInput[]
    id?: IntFilter<"zones"> | number
    title?: StringFilter<"zones"> | string
    government_id?: IntFilter<"zones"> | number
    active?: BoolNullableFilter<"zones"> | boolean | null
    parents?: ParentsListRelationFilter
    students?: StudentsListRelationFilter
    teachers?: TeachersListRelationFilter
    government?: XOR<GovernmentScalarRelationFilter, governmentWhereInput>
  }

  export type zonesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    government_id?: SortOrder
    active?: SortOrderInput | SortOrder
    parents?: parentsOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
    teachers?: teachersOrderByRelationAggregateInput
    government?: governmentOrderByWithRelationInput
  }

  export type zonesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title_government_id?: zonesTitleGovernment_idCompoundUniqueInput
    AND?: zonesWhereInput | zonesWhereInput[]
    OR?: zonesWhereInput[]
    NOT?: zonesWhereInput | zonesWhereInput[]
    title?: StringFilter<"zones"> | string
    government_id?: IntFilter<"zones"> | number
    active?: BoolNullableFilter<"zones"> | boolean | null
    parents?: ParentsListRelationFilter
    students?: StudentsListRelationFilter
    teachers?: TeachersListRelationFilter
    government?: XOR<GovernmentScalarRelationFilter, governmentWhereInput>
  }, "id" | "title_government_id">

  export type zonesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    government_id?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: zonesCountOrderByAggregateInput
    _avg?: zonesAvgOrderByAggregateInput
    _max?: zonesMaxOrderByAggregateInput
    _min?: zonesMinOrderByAggregateInput
    _sum?: zonesSumOrderByAggregateInput
  }

  export type zonesScalarWhereWithAggregatesInput = {
    AND?: zonesScalarWhereWithAggregatesInput | zonesScalarWhereWithAggregatesInput[]
    OR?: zonesScalarWhereWithAggregatesInput[]
    NOT?: zonesScalarWhereWithAggregatesInput | zonesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zones"> | number
    title?: StringWithAggregatesFilter<"zones"> | string
    government_id?: IntWithAggregatesFilter<"zones"> | number
    active?: BoolNullableWithAggregatesFilter<"zones"> | boolean | null
  }

  export type email_verification_tokensWhereInput = {
    AND?: email_verification_tokensWhereInput | email_verification_tokensWhereInput[]
    OR?: email_verification_tokensWhereInput[]
    NOT?: email_verification_tokensWhereInput | email_verification_tokensWhereInput[]
    id?: IntFilter<"email_verification_tokens"> | number
    user_id?: IntFilter<"email_verification_tokens"> | number
    token_hash?: StringFilter<"email_verification_tokens"> | string
    created_at?: DateTimeNullableFilter<"email_verification_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"email_verification_tokens"> | Date | string
    used_at?: DateTimeNullableFilter<"email_verification_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type email_verification_tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type email_verification_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: email_verification_tokensWhereInput | email_verification_tokensWhereInput[]
    OR?: email_verification_tokensWhereInput[]
    NOT?: email_verification_tokensWhereInput | email_verification_tokensWhereInput[]
    token_hash?: StringFilter<"email_verification_tokens"> | string
    created_at?: DateTimeNullableFilter<"email_verification_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"email_verification_tokens"> | Date | string
    used_at?: DateTimeNullableFilter<"email_verification_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type email_verification_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    _count?: email_verification_tokensCountOrderByAggregateInput
    _avg?: email_verification_tokensAvgOrderByAggregateInput
    _max?: email_verification_tokensMaxOrderByAggregateInput
    _min?: email_verification_tokensMinOrderByAggregateInput
    _sum?: email_verification_tokensSumOrderByAggregateInput
  }

  export type email_verification_tokensScalarWhereWithAggregatesInput = {
    AND?: email_verification_tokensScalarWhereWithAggregatesInput | email_verification_tokensScalarWhereWithAggregatesInput[]
    OR?: email_verification_tokensScalarWhereWithAggregatesInput[]
    NOT?: email_verification_tokensScalarWhereWithAggregatesInput | email_verification_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"email_verification_tokens"> | number
    user_id?: IntWithAggregatesFilter<"email_verification_tokens"> | number
    token_hash?: StringWithAggregatesFilter<"email_verification_tokens"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"email_verification_tokens"> | Date | string | null
    expires_at?: DateTimeWithAggregatesFilter<"email_verification_tokens"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"email_verification_tokens"> | Date | string | null
  }

  export type password_reset_tokensWhereInput = {
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    id?: IntFilter<"password_reset_tokens"> | number
    user_id?: IntFilter<"password_reset_tokens"> | number
    token_hash?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"password_reset_tokens"> | Date | string
    used_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type password_reset_tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type password_reset_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    token_hash?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"password_reset_tokens"> | Date | string
    used_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type password_reset_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    _count?: password_reset_tokensCountOrderByAggregateInput
    _avg?: password_reset_tokensAvgOrderByAggregateInput
    _max?: password_reset_tokensMaxOrderByAggregateInput
    _min?: password_reset_tokensMinOrderByAggregateInput
    _sum?: password_reset_tokensSumOrderByAggregateInput
  }

  export type password_reset_tokensScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokensScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"password_reset_tokens"> | number
    user_id?: IntWithAggregatesFilter<"password_reset_tokens"> | number
    token_hash?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"password_reset_tokens"> | Date | string | null
    expires_at?: DateTimeWithAggregatesFilter<"password_reset_tokens"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"password_reset_tokens"> | Date | string | null
  }

  export type auth_identitiesCreateInput = {
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
    users: usersCreateNestedOneWithoutAuth_identitiesInput
  }

  export type auth_identitiesUncheckedCreateInput = {
    id?: number
    user_id: number
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
  }

  export type auth_identitiesUpdateInput = {
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutAuth_identitiesNestedInput
  }

  export type auth_identitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_identitiesCreateManyInput = {
    id?: number
    user_id: number
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
  }

  export type auth_identitiesUpdateManyMutationInput = {
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_identitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_analyticsCreateInput = {
    views?: number | null
    total_spent?: Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: number | null
    successful_invites?: number | null
    monthly_confirmed_count?: number | null
    last_confirmed_count_update?: Date | string | null
    users: usersCreateNestedOneWithoutUser_analyticsInput
  }

  export type user_analyticsUncheckedCreateInput = {
    user_id: number
    views?: number | null
    total_spent?: Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: number | null
    successful_invites?: number | null
    monthly_confirmed_count?: number | null
    last_confirmed_count_update?: Date | string | null
  }

  export type user_analyticsUpdateInput = {
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUser_analyticsNestedInput
  }

  export type user_analyticsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_analyticsCreateManyInput = {
    user_id: number
    views?: number | null
    total_spent?: Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: number | null
    successful_invites?: number | null
    monthly_confirmed_count?: number | null
    last_confirmed_count_update?: Date | string | null
  }

  export type user_analyticsUpdateManyMutationInput = {
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_analyticsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_rolesCreateInput = {
    portal: $Enums.portal_enum
    role: $Enums.role_enum
    users: usersCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    id?: number
    user_id: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type user_rolesUpdateInput = {
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type user_rolesCreateManyInput = {
    id?: number
    user_id: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type user_rolesUpdateManyMutationInput = {
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type user_rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type usersCreateInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
  }

  export type usersUpdateManyMutationInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type refresh_tokensCreateInput = {
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
    users: usersCreateNestedOneWithoutRefresh_tokensInput
  }

  export type refresh_tokensUncheckedCreateInput = {
    id?: number
    user_id: number
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
  }

  export type refresh_tokensUpdateInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutRefresh_tokensNestedInput
  }

  export type refresh_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensCreateManyInput = {
    id?: number
    user_id: number
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
  }

  export type refresh_tokensUpdateManyMutationInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assistantsCreateInput = {
    lecturers: lecturersCreateNestedOneWithoutAssistantsInput
    users: usersCreateNestedOneWithoutAssistantsInput
  }

  export type assistantsUncheckedCreateInput = {
    id?: number
    user_id: number
    lecturer_user_id: number
  }

  export type assistantsUpdateInput = {
    lecturers?: lecturersUpdateOneRequiredWithoutAssistantsNestedInput
    users?: usersUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type assistantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lecturer_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type assistantsCreateManyInput = {
    id?: number
    user_id: number
    lecturer_user_id: number
  }

  export type assistantsUpdateManyMutationInput = {

  }

  export type assistantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lecturer_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type governmentCreateInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutGovernmentInput
    students?: studentsCreateNestedManyWithoutGovernmentInput
    teachers?: teachersCreateNestedManyWithoutGovernmentInput
    zones?: zonesCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUncheckedCreateInput = {
    id?: number
    title: string
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutGovernmentInput
    students?: studentsUncheckedCreateNestedManyWithoutGovernmentInput
    teachers?: teachersUncheckedCreateNestedManyWithoutGovernmentInput
    zones?: zonesUncheckedCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutGovernmentNestedInput
    students?: studentsUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutGovernmentNestedInput
    students?: studentsUncheckedUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUncheckedUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentCreateManyInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type governmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type governmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type lecturersCreateInput = {
    bio?: string | null
    expertise?: string | null
    assistants?: assistantsCreateNestedManyWithoutLecturersInput
    users: usersCreateNestedOneWithoutLecturersInput
  }

  export type lecturersUncheckedCreateInput = {
    user_id: number
    bio?: string | null
    expertise?: string | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutLecturersInput
  }

  export type lecturersUpdateInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: assistantsUpdateManyWithoutLecturersNestedInput
    users?: usersUpdateOneRequiredWithoutLecturersNestedInput
  }

  export type lecturersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: assistantsUncheckedUpdateManyWithoutLecturersNestedInput
  }

  export type lecturersCreateManyInput = {
    user_id: number
    bio?: string | null
    expertise?: string | null
  }

  export type lecturersUpdateManyMutationInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lecturersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type levelsCreateInput = {
    title: string
    active?: boolean | null
    students?: studentsCreateNestedManyWithoutLevelsInput
  }

  export type levelsUncheckedCreateInput = {
    id?: number
    title: string
    active?: boolean | null
    students?: studentsUncheckedCreateNestedManyWithoutLevelsInput
  }

  export type levelsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUpdateManyWithoutLevelsNestedInput
  }

  export type levelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUncheckedUpdateManyWithoutLevelsNestedInput
  }

  export type levelsCreateManyInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type levelsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type levelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type parent_childrenCreateInput = {
    parents: parentsCreateNestedOneWithoutParent_childrenInput
    students: studentsCreateNestedOneWithoutParent_childrenInput
  }

  export type parent_childrenUncheckedCreateInput = {
    id?: number
    parent_user_id: number
    student_user_id: number
  }

  export type parent_childrenUpdateInput = {
    parents?: parentsUpdateOneRequiredWithoutParent_childrenNestedInput
    students?: studentsUpdateOneRequiredWithoutParent_childrenNestedInput
  }

  export type parent_childrenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_user_id?: IntFieldUpdateOperationsInput | number
    student_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type parent_childrenCreateManyInput = {
    id?: number
    parent_user_id: number
    student_user_id: number
  }

  export type parent_childrenUpdateManyMutationInput = {

  }

  export type parent_childrenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_user_id?: IntFieldUpdateOperationsInput | number
    student_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type parentsCreateInput = {
    parent_children?: parent_childrenCreateNestedManyWithoutParentsInput
    government?: governmentCreateNestedOneWithoutParentsInput
    users: usersCreateNestedOneWithoutParentsInput
    zones?: zonesCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateInput = {
    user_id: number
    government_id?: number | null
    zone_id?: number | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsUpdateInput = {
    parent_children?: parent_childrenUpdateManyWithoutParentsNestedInput
    government?: governmentUpdateOneWithoutParentsNestedInput
    users?: usersUpdateOneRequiredWithoutParentsNestedInput
    zones?: zonesUpdateOneWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsCreateManyInput = {
    user_id: number
    government_id?: number | null
    zone_id?: number | null
  }

  export type parentsUpdateManyMutationInput = {

  }

  export type parentsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sitesCreateInput = {
    title: string
    active?: boolean | null
    social_media?: social_mediaCreateNestedManyWithoutSitesInput
  }

  export type sitesUncheckedCreateInput = {
    id?: number
    title: string
    active?: boolean | null
    social_media?: social_mediaUncheckedCreateNestedManyWithoutSitesInput
  }

  export type sitesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: social_mediaUpdateManyWithoutSitesNestedInput
  }

  export type sitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    social_media?: social_mediaUncheckedUpdateManyWithoutSitesNestedInput
  }

  export type sitesCreateManyInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type sitesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type sitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type social_mediaCreateInput = {
    url: string
    active?: boolean | null
    sites?: sitesCreateNestedOneWithoutSocial_mediaInput
    users: usersCreateNestedOneWithoutSocial_mediaInput
  }

  export type social_mediaUncheckedCreateInput = {
    id?: number
    teacher_user_id: number
    site_id?: number | null
    url: string
    active?: boolean | null
  }

  export type social_mediaUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sites?: sitesUpdateOneWithoutSocial_mediaNestedInput
    users?: usersUpdateOneRequiredWithoutSocial_mediaNestedInput
  }

  export type social_mediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_user_id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type social_mediaCreateManyInput = {
    id?: number
    teacher_user_id: number
    site_id?: number | null
    url: string
    active?: boolean | null
  }

  export type social_mediaUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type social_mediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_user_id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type studentsCreateInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenCreateNestedManyWithoutStudentsInput
    government?: governmentCreateNestedOneWithoutStudentsInput
    levels?: levelsCreateNestedOneWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    zones?: zonesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    user_id: number
    level_id?: number | null
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUpdateManyWithoutStudentsNestedInput
    government?: governmentUpdateOneWithoutStudentsNestedInput
    levels?: levelsUpdateOneWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    zones?: zonesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    user_id: number
    level_id?: number | null
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
  }

  export type studentsUpdateManyMutationInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectsCreateInput = {
    title: string
    active?: boolean | null
    teachers?: teachersCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateInput = {
    id?: number
    title: string
    active?: boolean | null
    teachers?: teachersUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    teachers?: teachersUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    teachers?: teachersUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsCreateManyInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type subjectsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type subjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teachersCreateInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government?: governmentCreateNestedOneWithoutTeachersInput
    subjects?: subjectsCreateNestedOneWithoutTeachersInput
    users: usersCreateNestedOneWithoutTeachersInput
    zones?: zonesCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    zone_id?: number | null
    subject_id?: number | null
  }

  export type teachersUpdateInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government?: governmentUpdateOneWithoutTeachersNestedInput
    subjects?: subjectsUpdateOneWithoutTeachersNestedInput
    users?: usersUpdateOneRequiredWithoutTeachersNestedInput
    zones?: zonesUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teachersCreateManyInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    zone_id?: number | null
    subject_id?: number | null
  }

  export type teachersUpdateManyMutationInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teachersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teaches_atCreateInput = {
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
    users: usersCreateNestedOneWithoutTeaches_atInput
  }

  export type teaches_atUncheckedCreateInput = {
    id?: number
    user_id: number
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
  }

  export type teaches_atUpdateInput = {
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutTeaches_atNestedInput
  }

  export type teaches_atUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teaches_atCreateManyInput = {
    id?: number
    user_id: number
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
  }

  export type teaches_atUpdateManyMutationInput = {
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teaches_atUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type zonesCreateInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutZonesInput
    students?: studentsCreateNestedManyWithoutZonesInput
    teachers?: teachersCreateNestedManyWithoutZonesInput
    government: governmentCreateNestedOneWithoutZonesInput
  }

  export type zonesUncheckedCreateInput = {
    id?: number
    title: string
    government_id: number
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutZonesInput
    students?: studentsUncheckedCreateNestedManyWithoutZonesInput
    teachers?: teachersUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutZonesNestedInput
    students?: studentsUpdateManyWithoutZonesNestedInput
    teachers?: teachersUpdateManyWithoutZonesNestedInput
    government?: governmentUpdateOneRequiredWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    government_id?: IntFieldUpdateOperationsInput | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutZonesNestedInput
    students?: studentsUncheckedUpdateManyWithoutZonesNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type zonesCreateManyInput = {
    id?: number
    title: string
    government_id: number
    active?: boolean | null
  }

  export type zonesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type zonesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    government_id?: IntFieldUpdateOperationsInput | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type email_verification_tokensCreateInput = {
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
    users: usersCreateNestedOneWithoutEmail_verification_tokensInput
  }

  export type email_verification_tokensUncheckedCreateInput = {
    id?: number
    user_id: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type email_verification_tokensUpdateInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutEmail_verification_tokensNestedInput
  }

  export type email_verification_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_verification_tokensCreateManyInput = {
    id?: number
    user_id: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type email_verification_tokensUpdateManyMutationInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_verification_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateInput = {
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
    users: usersCreateNestedOneWithoutPassword_reset_tokensInput
  }

  export type password_reset_tokensUncheckedCreateInput = {
    id?: number
    user_id: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type password_reset_tokensUpdateInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutPassword_reset_tokensNestedInput
  }

  export type password_reset_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateManyInput = {
    id?: number
    user_id: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type password_reset_tokensUpdateManyMutationInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Enumauth_provider_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.auth_provider_enum | Enumauth_provider_enumFieldRefInput<$PrismaModel>
    in?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumauth_provider_enumFilter<$PrismaModel> | $Enums.auth_provider_enum
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auth_identitiesProviderProvider_user_idCompoundUniqueInput = {
    provider: $Enums.auth_provider_enum
    provider_user_id: string
  }

  export type auth_identitiesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_user_id?: SortOrder
    provider_email?: SortOrder
  }

  export type auth_identitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type auth_identitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_user_id?: SortOrder
    provider_email?: SortOrder
  }

  export type auth_identitiesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_user_id?: SortOrder
    provider_email?: SortOrder
  }

  export type auth_identitiesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Enumauth_provider_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.auth_provider_enum | Enumauth_provider_enumFieldRefInput<$PrismaModel>
    in?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumauth_provider_enumWithAggregatesFilter<$PrismaModel> | $Enums.auth_provider_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumauth_provider_enumFilter<$PrismaModel>
    _max?: NestedEnumauth_provider_enumFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type user_analyticsCountOrderByAggregateInput = {
    user_id?: SortOrder
    views?: SortOrder
    total_spent?: SortOrder
    number_of_purchases?: SortOrder
    successful_invites?: SortOrder
    monthly_confirmed_count?: SortOrder
    last_confirmed_count_update?: SortOrder
  }

  export type user_analyticsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    views?: SortOrder
    total_spent?: SortOrder
    number_of_purchases?: SortOrder
    successful_invites?: SortOrder
    monthly_confirmed_count?: SortOrder
  }

  export type user_analyticsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    views?: SortOrder
    total_spent?: SortOrder
    number_of_purchases?: SortOrder
    successful_invites?: SortOrder
    monthly_confirmed_count?: SortOrder
    last_confirmed_count_update?: SortOrder
  }

  export type user_analyticsMinOrderByAggregateInput = {
    user_id?: SortOrder
    views?: SortOrder
    total_spent?: SortOrder
    number_of_purchases?: SortOrder
    successful_invites?: SortOrder
    monthly_confirmed_count?: SortOrder
    last_confirmed_count_update?: SortOrder
  }

  export type user_analyticsSumOrderByAggregateInput = {
    user_id?: SortOrder
    views?: SortOrder
    total_spent?: SortOrder
    number_of_purchases?: SortOrder
    successful_invites?: SortOrder
    monthly_confirmed_count?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumportal_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.portal_enum | Enumportal_enumFieldRefInput<$PrismaModel>
    in?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumportal_enumFilter<$PrismaModel> | $Enums.portal_enum
  }

  export type Enumrole_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel>
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumrole_enumFilter<$PrismaModel> | $Enums.role_enum
  }

  export type user_rolesUser_idPortalRoleCompoundUniqueInput = {
    user_id: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type user_rolesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    portal?: SortOrder
    role?: SortOrder
  }

  export type user_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    portal?: SortOrder
    role?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    portal?: SortOrder
    role?: SortOrder
  }

  export type user_rolesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Enumportal_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portal_enum | Enumportal_enumFieldRefInput<$PrismaModel>
    in?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumportal_enumWithAggregatesFilter<$PrismaModel> | $Enums.portal_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumportal_enumFilter<$PrismaModel>
    _max?: NestedEnumportal_enumFilter<$PrismaModel>
  }

  export type Enumrole_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel>
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumrole_enumWithAggregatesFilter<$PrismaModel> | $Enums.role_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrole_enumFilter<$PrismaModel>
    _max?: NestedEnumrole_enumFilter<$PrismaModel>
  }

  export type Enumgender_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.gender_enum | Enumgender_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumgender_enumNullableFilter<$PrismaModel> | $Enums.gender_enum | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Enumrole_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_enumNullableFilter<$PrismaModel> | $Enums.role_enum | null
  }

  export type AssistantsListRelationFilter = {
    every?: assistantsWhereInput
    some?: assistantsWhereInput
    none?: assistantsWhereInput
  }

  export type Auth_identitiesListRelationFilter = {
    every?: auth_identitiesWhereInput
    some?: auth_identitiesWhereInput
    none?: auth_identitiesWhereInput
  }

  export type Email_verification_tokensNullableScalarRelationFilter = {
    is?: email_verification_tokensWhereInput | null
    isNot?: email_verification_tokensWhereInput | null
  }

  export type LecturersNullableScalarRelationFilter = {
    is?: lecturersWhereInput | null
    isNot?: lecturersWhereInput | null
  }

  export type ParentsNullableScalarRelationFilter = {
    is?: parentsWhereInput | null
    isNot?: parentsWhereInput | null
  }

  export type Password_reset_tokensNullableScalarRelationFilter = {
    is?: password_reset_tokensWhereInput | null
    isNot?: password_reset_tokensWhereInput | null
  }

  export type Refresh_tokensListRelationFilter = {
    every?: refresh_tokensWhereInput
    some?: refresh_tokensWhereInput
    none?: refresh_tokensWhereInput
  }

  export type Social_mediaListRelationFilter = {
    every?: social_mediaWhereInput
    some?: social_mediaWhereInput
    none?: social_mediaWhereInput
  }

  export type StudentsNullableScalarRelationFilter = {
    is?: studentsWhereInput | null
    isNot?: studentsWhereInput | null
  }

  export type TeachersNullableScalarRelationFilter = {
    is?: teachersWhereInput | null
    isNot?: teachersWhereInput | null
  }

  export type Teaches_atListRelationFilter = {
    every?: teaches_atWhereInput
    some?: teaches_atWhereInput
    none?: teaches_atWhereInput
  }

  export type User_analyticsNullableScalarRelationFilter = {
    is?: user_analyticsWhereInput | null
    isNot?: user_analyticsWhereInput | null
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type assistantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_identitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refresh_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type social_mediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teaches_atOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    mongo_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    is_email_verified?: SortOrder
    email_verified_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secondary_phone?: SortOrder
    role?: SortOrder
    profile_pic_url?: SortOrder
    password_changed_at?: SortOrder
    confirmed?: SortOrder
    hasPromoCode?: SortOrder
    hasUsedPromoCode?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    mongo_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    is_email_verified?: SortOrder
    email_verified_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secondary_phone?: SortOrder
    role?: SortOrder
    profile_pic_url?: SortOrder
    password_changed_at?: SortOrder
    confirmed?: SortOrder
    hasPromoCode?: SortOrder
    hasUsedPromoCode?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    mongo_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    is_email_verified?: SortOrder
    email_verified_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    secondary_phone?: SortOrder
    role?: SortOrder
    profile_pic_url?: SortOrder
    password_changed_at?: SortOrder
    confirmed?: SortOrder
    hasPromoCode?: SortOrder
    hasUsedPromoCode?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumgender_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.gender_enum | Enumgender_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumgender_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.gender_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumgender_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumgender_enumNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumrole_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.role_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrole_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumrole_enumNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type refresh_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type refresh_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type refresh_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type refresh_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    revoked?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type refresh_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LecturersScalarRelationFilter = {
    is?: lecturersWhereInput
    isNot?: lecturersWhereInput
  }

  export type assistantsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
  }

  export type assistantsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
  }

  export type assistantsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
  }

  export type assistantsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
  }

  export type assistantsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lecturer_user_id?: SortOrder
  }

  export type ParentsListRelationFilter = {
    every?: parentsWhereInput
    some?: parentsWhereInput
    none?: parentsWhereInput
  }

  export type StudentsListRelationFilter = {
    every?: studentsWhereInput
    some?: studentsWhereInput
    none?: studentsWhereInput
  }

  export type TeachersListRelationFilter = {
    every?: teachersWhereInput
    some?: teachersWhereInput
    none?: teachersWhereInput
  }

  export type ZonesListRelationFilter = {
    every?: zonesWhereInput
    some?: zonesWhereInput
    none?: zonesWhereInput
  }

  export type parentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teachersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type zonesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type governmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type governmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type governmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type governmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type governmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type lecturersCountOrderByAggregateInput = {
    user_id?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
  }

  export type lecturersAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type lecturersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
  }

  export type lecturersMinOrderByAggregateInput = {
    user_id?: SortOrder
    bio?: SortOrder
    expertise?: SortOrder
  }

  export type lecturersSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type levelsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type levelsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type levelsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type levelsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type levelsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentsScalarRelationFilter = {
    is?: parentsWhereInput
    isNot?: parentsWhereInput
  }

  export type StudentsScalarRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type parent_childrenParent_user_idStudent_user_idCompoundUniqueInput = {
    parent_user_id: number
    student_user_id: number
  }

  export type parent_childrenCountOrderByAggregateInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
  }

  export type parent_childrenAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
  }

  export type parent_childrenMaxOrderByAggregateInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
  }

  export type parent_childrenMinOrderByAggregateInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
  }

  export type parent_childrenSumOrderByAggregateInput = {
    id?: SortOrder
    parent_user_id?: SortOrder
    student_user_id?: SortOrder
  }

  export type Parent_childrenListRelationFilter = {
    every?: parent_childrenWhereInput
    some?: parent_childrenWhereInput
    none?: parent_childrenWhereInput
  }

  export type GovernmentNullableScalarRelationFilter = {
    is?: governmentWhereInput | null
    isNot?: governmentWhereInput | null
  }

  export type ZonesNullableScalarRelationFilter = {
    is?: zonesWhereInput | null
    isNot?: zonesWhereInput | null
  }

  export type parent_childrenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parentsCountOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
  }

  export type parentsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
  }

  export type parentsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
  }

  export type parentsMinOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
  }

  export type parentsSumOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
  }

  export type sitesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type sitesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sitesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type sitesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type sitesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SitesNullableScalarRelationFilter = {
    is?: sitesWhereInput | null
    isNot?: sitesWhereInput | null
  }

  export type social_mediaCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type social_mediaAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrder
  }

  export type social_mediaMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type social_mediaMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type social_mediaSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_user_id?: SortOrder
    site_id?: SortOrder
  }

  export type LevelsNullableScalarRelationFilter = {
    is?: levelsWhereInput | null
    isNot?: levelsWhereInput | null
  }

  export type studentsCountOrderByAggregateInput = {
    user_id?: SortOrder
    level_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    parent_phone_number?: SortOrder
    sequenced_id?: SortOrder
    faction?: SortOrder
  }

  export type studentsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    level_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    sequenced_id?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    level_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    parent_phone_number?: SortOrder
    sequenced_id?: SortOrder
    faction?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    user_id?: SortOrder
    level_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    parent_phone_number?: SortOrder
    sequenced_id?: SortOrder
    faction?: SortOrder
  }

  export type studentsSumOrderByAggregateInput = {
    user_id?: SortOrder
    level_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    sequenced_id?: SortOrder
  }

  export type subjectsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type subjectsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type subjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type subjectsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    active?: SortOrder
  }

  export type subjectsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubjectsNullableScalarRelationFilter = {
    is?: subjectsWhereInput | null
    isNot?: subjectsWhereInput | null
  }

  export type teachersCountOrderByAggregateInput = {
    user_id?: SortOrder
    serial?: SortOrder
    is_primary?: SortOrder
    is_preparatory?: SortOrder
    is_secondary?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    serial?: SortOrder
    is_primary?: SortOrder
    is_preparatory?: SortOrder
    is_secondary?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachersMinOrderByAggregateInput = {
    user_id?: SortOrder
    serial?: SortOrder
    is_primary?: SortOrder
    is_preparatory?: SortOrder
    is_secondary?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachersSumOrderByAggregateInput = {
    user_id?: SortOrder
    government_id?: SortOrder
    zone_id?: SortOrder
    subject_id?: SortOrder
  }

  export type Enumlocation_type_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.location_type_enum | Enumlocation_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel> | $Enums.location_type_enum | null
  }

  export type teaches_atCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_name?: SortOrder
    location_type?: SortOrder
    active?: SortOrder
  }

  export type teaches_atAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type teaches_atMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_name?: SortOrder
    location_type?: SortOrder
    active?: SortOrder
  }

  export type teaches_atMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_name?: SortOrder
    location_type?: SortOrder
    active?: SortOrder
  }

  export type teaches_atSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Enumlocation_type_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.location_type_enum | Enumlocation_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumlocation_type_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.location_type_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel>
  }

  export type GovernmentScalarRelationFilter = {
    is?: governmentWhereInput
    isNot?: governmentWhereInput
  }

  export type zonesTitleGovernment_idCompoundUniqueInput = {
    title: string
    government_id: number
  }

  export type zonesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    government_id?: SortOrder
    active?: SortOrder
  }

  export type zonesAvgOrderByAggregateInput = {
    id?: SortOrder
    government_id?: SortOrder
  }

  export type zonesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    government_id?: SortOrder
    active?: SortOrder
  }

  export type zonesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    government_id?: SortOrder
    active?: SortOrder
  }

  export type zonesSumOrderByAggregateInput = {
    id?: SortOrder
    government_id?: SortOrder
  }

  export type email_verification_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type email_verification_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type email_verification_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type email_verification_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type email_verification_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type password_reset_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type password_reset_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type password_reset_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type password_reset_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token_hash?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
  }

  export type password_reset_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type usersCreateNestedOneWithoutAuth_identitiesInput = {
    create?: XOR<usersCreateWithoutAuth_identitiesInput, usersUncheckedCreateWithoutAuth_identitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuth_identitiesInput
    connect?: usersWhereUniqueInput
  }

  export type Enumauth_provider_enumFieldUpdateOperationsInput = {
    set?: $Enums.auth_provider_enum
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type usersUpdateOneRequiredWithoutAuth_identitiesNestedInput = {
    create?: XOR<usersCreateWithoutAuth_identitiesInput, usersUncheckedCreateWithoutAuth_identitiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuth_identitiesInput
    upsert?: usersUpsertWithoutAuth_identitiesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuth_identitiesInput, usersUpdateWithoutAuth_identitiesInput>, usersUncheckedUpdateWithoutAuth_identitiesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutUser_analyticsInput = {
    create?: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_analyticsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneRequiredWithoutUser_analyticsNestedInput = {
    create?: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_analyticsInput
    upsert?: usersUpsertWithoutUser_analyticsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_analyticsInput, usersUpdateWithoutUser_analyticsInput>, usersUncheckedUpdateWithoutUser_analyticsInput>
  }

  export type usersCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
  }

  export type Enumportal_enumFieldUpdateOperationsInput = {
    set?: $Enums.portal_enum
  }

  export type Enumrole_enumFieldUpdateOperationsInput = {
    set?: $Enums.role_enum
  }

  export type usersUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    upsert?: usersUpsertWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_rolesInput, usersUpdateWithoutUser_rolesInput>, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type assistantsCreateNestedManyWithoutUsersInput = {
    create?: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput> | assistantsCreateWithoutUsersInput[] | assistantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutUsersInput | assistantsCreateOrConnectWithoutUsersInput[]
    createMany?: assistantsCreateManyUsersInputEnvelope
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
  }

  export type auth_identitiesCreateNestedManyWithoutUsersInput = {
    create?: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput> | auth_identitiesCreateWithoutUsersInput[] | auth_identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auth_identitiesCreateOrConnectWithoutUsersInput | auth_identitiesCreateOrConnectWithoutUsersInput[]
    createMany?: auth_identitiesCreateManyUsersInputEnvelope
    connect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
  }

  export type email_verification_tokensCreateNestedOneWithoutUsersInput = {
    create?: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: email_verification_tokensCreateOrConnectWithoutUsersInput
    connect?: email_verification_tokensWhereUniqueInput
  }

  export type lecturersCreateNestedOneWithoutUsersInput = {
    create?: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutUsersInput
    connect?: lecturersWhereUniqueInput
  }

  export type parentsCreateNestedOneWithoutUsersInput = {
    create?: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: parentsCreateOrConnectWithoutUsersInput
    connect?: parentsWhereUniqueInput
  }

  export type password_reset_tokensCreateNestedOneWithoutUsersInput = {
    create?: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutUsersInput
    connect?: password_reset_tokensWhereUniqueInput
  }

  export type refresh_tokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput> | refresh_tokensCreateWithoutUsersInput[] | refresh_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput | refresh_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: refresh_tokensCreateManyUsersInputEnvelope
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
  }

  export type social_mediaCreateNestedManyWithoutUsersInput = {
    create?: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput> | social_mediaCreateWithoutUsersInput[] | social_mediaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutUsersInput | social_mediaCreateOrConnectWithoutUsersInput[]
    createMany?: social_mediaCreateManyUsersInputEnvelope
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
  }

  export type studentsCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    connect?: studentsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutUsersInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput
    connect?: teachersWhereUniqueInput
  }

  export type teaches_atCreateNestedManyWithoutUsersInput = {
    create?: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput> | teaches_atCreateWithoutUsersInput[] | teaches_atUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teaches_atCreateOrConnectWithoutUsersInput | teaches_atCreateOrConnectWithoutUsersInput[]
    createMany?: teaches_atCreateManyUsersInputEnvelope
    connect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
  }

  export type user_analyticsCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput
    connect?: user_analyticsWhereUniqueInput
  }

  export type user_rolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type assistantsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput> | assistantsCreateWithoutUsersInput[] | assistantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutUsersInput | assistantsCreateOrConnectWithoutUsersInput[]
    createMany?: assistantsCreateManyUsersInputEnvelope
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
  }

  export type auth_identitiesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput> | auth_identitiesCreateWithoutUsersInput[] | auth_identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auth_identitiesCreateOrConnectWithoutUsersInput | auth_identitiesCreateOrConnectWithoutUsersInput[]
    createMany?: auth_identitiesCreateManyUsersInputEnvelope
    connect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
  }

  export type email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: email_verification_tokensCreateOrConnectWithoutUsersInput
    connect?: email_verification_tokensWhereUniqueInput
  }

  export type lecturersUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutUsersInput
    connect?: lecturersWhereUniqueInput
  }

  export type parentsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: parentsCreateOrConnectWithoutUsersInput
    connect?: parentsWhereUniqueInput
  }

  export type password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutUsersInput
    connect?: password_reset_tokensWhereUniqueInput
  }

  export type refresh_tokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput> | refresh_tokensCreateWithoutUsersInput[] | refresh_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput | refresh_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: refresh_tokensCreateManyUsersInputEnvelope
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
  }

  export type social_mediaUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput> | social_mediaCreateWithoutUsersInput[] | social_mediaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutUsersInput | social_mediaCreateOrConnectWithoutUsersInput[]
    createMany?: social_mediaCreateManyUsersInputEnvelope
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    connect?: studentsWhereUniqueInput
  }

  export type teachersUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput
    connect?: teachersWhereUniqueInput
  }

  export type teaches_atUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput> | teaches_atCreateWithoutUsersInput[] | teaches_atUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teaches_atCreateOrConnectWithoutUsersInput | teaches_atCreateOrConnectWithoutUsersInput[]
    createMany?: teaches_atCreateManyUsersInputEnvelope
    connect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
  }

  export type user_analyticsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput
    connect?: user_analyticsWhereUniqueInput
  }

  export type user_rolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type NullableEnumgender_enumFieldUpdateOperationsInput = {
    set?: $Enums.gender_enum | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumrole_enumFieldUpdateOperationsInput = {
    set?: $Enums.role_enum | null
  }

  export type assistantsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput> | assistantsCreateWithoutUsersInput[] | assistantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutUsersInput | assistantsCreateOrConnectWithoutUsersInput[]
    upsert?: assistantsUpsertWithWhereUniqueWithoutUsersInput | assistantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: assistantsCreateManyUsersInputEnvelope
    set?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    disconnect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    delete?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    update?: assistantsUpdateWithWhereUniqueWithoutUsersInput | assistantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: assistantsUpdateManyWithWhereWithoutUsersInput | assistantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
  }

  export type auth_identitiesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput> | auth_identitiesCreateWithoutUsersInput[] | auth_identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auth_identitiesCreateOrConnectWithoutUsersInput | auth_identitiesCreateOrConnectWithoutUsersInput[]
    upsert?: auth_identitiesUpsertWithWhereUniqueWithoutUsersInput | auth_identitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: auth_identitiesCreateManyUsersInputEnvelope
    set?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    disconnect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    delete?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    connect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    update?: auth_identitiesUpdateWithWhereUniqueWithoutUsersInput | auth_identitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: auth_identitiesUpdateManyWithWhereWithoutUsersInput | auth_identitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: auth_identitiesScalarWhereInput | auth_identitiesScalarWhereInput[]
  }

  export type email_verification_tokensUpdateOneWithoutUsersNestedInput = {
    create?: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: email_verification_tokensCreateOrConnectWithoutUsersInput
    upsert?: email_verification_tokensUpsertWithoutUsersInput
    disconnect?: email_verification_tokensWhereInput | boolean
    delete?: email_verification_tokensWhereInput | boolean
    connect?: email_verification_tokensWhereUniqueInput
    update?: XOR<XOR<email_verification_tokensUpdateToOneWithWhereWithoutUsersInput, email_verification_tokensUpdateWithoutUsersInput>, email_verification_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type lecturersUpdateOneWithoutUsersNestedInput = {
    create?: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutUsersInput
    upsert?: lecturersUpsertWithoutUsersInput
    disconnect?: lecturersWhereInput | boolean
    delete?: lecturersWhereInput | boolean
    connect?: lecturersWhereUniqueInput
    update?: XOR<XOR<lecturersUpdateToOneWithWhereWithoutUsersInput, lecturersUpdateWithoutUsersInput>, lecturersUncheckedUpdateWithoutUsersInput>
  }

  export type parentsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: parentsCreateOrConnectWithoutUsersInput
    upsert?: parentsUpsertWithoutUsersInput
    disconnect?: parentsWhereInput | boolean
    delete?: parentsWhereInput | boolean
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutUsersInput, parentsUpdateWithoutUsersInput>, parentsUncheckedUpdateWithoutUsersInput>
  }

  export type password_reset_tokensUpdateOneWithoutUsersNestedInput = {
    create?: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutUsersInput
    upsert?: password_reset_tokensUpsertWithoutUsersInput
    disconnect?: password_reset_tokensWhereInput | boolean
    delete?: password_reset_tokensWhereInput | boolean
    connect?: password_reset_tokensWhereUniqueInput
    update?: XOR<XOR<password_reset_tokensUpdateToOneWithWhereWithoutUsersInput, password_reset_tokensUpdateWithoutUsersInput>, password_reset_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type refresh_tokensUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput> | refresh_tokensCreateWithoutUsersInput[] | refresh_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput | refresh_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: refresh_tokensUpsertWithWhereUniqueWithoutUsersInput | refresh_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refresh_tokensCreateManyUsersInputEnvelope
    set?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    disconnect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    delete?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    update?: refresh_tokensUpdateWithWhereUniqueWithoutUsersInput | refresh_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refresh_tokensUpdateManyWithWhereWithoutUsersInput | refresh_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
  }

  export type social_mediaUpdateManyWithoutUsersNestedInput = {
    create?: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput> | social_mediaCreateWithoutUsersInput[] | social_mediaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutUsersInput | social_mediaCreateOrConnectWithoutUsersInput[]
    upsert?: social_mediaUpsertWithWhereUniqueWithoutUsersInput | social_mediaUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: social_mediaCreateManyUsersInputEnvelope
    set?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    disconnect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    delete?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    update?: social_mediaUpdateWithWhereUniqueWithoutUsersInput | social_mediaUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: social_mediaUpdateManyWithWhereWithoutUsersInput | social_mediaUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
  }

  export type studentsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    upsert?: studentsUpsertWithoutUsersInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutUsersInput, studentsUpdateWithoutUsersInput>, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type teachersUpdateOneWithoutUsersNestedInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput
    upsert?: teachersUpsertWithoutUsersInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutUsersInput, teachersUpdateWithoutUsersInput>, teachersUncheckedUpdateWithoutUsersInput>
  }

  export type teaches_atUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput> | teaches_atCreateWithoutUsersInput[] | teaches_atUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teaches_atCreateOrConnectWithoutUsersInput | teaches_atCreateOrConnectWithoutUsersInput[]
    upsert?: teaches_atUpsertWithWhereUniqueWithoutUsersInput | teaches_atUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teaches_atCreateManyUsersInputEnvelope
    set?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    disconnect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    delete?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    connect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    update?: teaches_atUpdateWithWhereUniqueWithoutUsersInput | teaches_atUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teaches_atUpdateManyWithWhereWithoutUsersInput | teaches_atUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teaches_atScalarWhereInput | teaches_atScalarWhereInput[]
  }

  export type user_analyticsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput
    upsert?: user_analyticsUpsertWithoutUsersInput
    disconnect?: user_analyticsWhereInput | boolean
    delete?: user_analyticsWhereInput | boolean
    connect?: user_analyticsWhereUniqueInput
    update?: XOR<XOR<user_analyticsUpdateToOneWithWhereWithoutUsersInput, user_analyticsUpdateWithoutUsersInput>, user_analyticsUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type assistantsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput> | assistantsCreateWithoutUsersInput[] | assistantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutUsersInput | assistantsCreateOrConnectWithoutUsersInput[]
    upsert?: assistantsUpsertWithWhereUniqueWithoutUsersInput | assistantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: assistantsCreateManyUsersInputEnvelope
    set?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    disconnect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    delete?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    update?: assistantsUpdateWithWhereUniqueWithoutUsersInput | assistantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: assistantsUpdateManyWithWhereWithoutUsersInput | assistantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
  }

  export type auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput> | auth_identitiesCreateWithoutUsersInput[] | auth_identitiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auth_identitiesCreateOrConnectWithoutUsersInput | auth_identitiesCreateOrConnectWithoutUsersInput[]
    upsert?: auth_identitiesUpsertWithWhereUniqueWithoutUsersInput | auth_identitiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: auth_identitiesCreateManyUsersInputEnvelope
    set?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    disconnect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    delete?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    connect?: auth_identitiesWhereUniqueInput | auth_identitiesWhereUniqueInput[]
    update?: auth_identitiesUpdateWithWhereUniqueWithoutUsersInput | auth_identitiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: auth_identitiesUpdateManyWithWhereWithoutUsersInput | auth_identitiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: auth_identitiesScalarWhereInput | auth_identitiesScalarWhereInput[]
  }

  export type email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: email_verification_tokensCreateOrConnectWithoutUsersInput
    upsert?: email_verification_tokensUpsertWithoutUsersInput
    disconnect?: email_verification_tokensWhereInput | boolean
    delete?: email_verification_tokensWhereInput | boolean
    connect?: email_verification_tokensWhereUniqueInput
    update?: XOR<XOR<email_verification_tokensUpdateToOneWithWhereWithoutUsersInput, email_verification_tokensUpdateWithoutUsersInput>, email_verification_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type lecturersUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutUsersInput
    upsert?: lecturersUpsertWithoutUsersInput
    disconnect?: lecturersWhereInput | boolean
    delete?: lecturersWhereInput | boolean
    connect?: lecturersWhereUniqueInput
    update?: XOR<XOR<lecturersUpdateToOneWithWhereWithoutUsersInput, lecturersUpdateWithoutUsersInput>, lecturersUncheckedUpdateWithoutUsersInput>
  }

  export type parentsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: parentsCreateOrConnectWithoutUsersInput
    upsert?: parentsUpsertWithoutUsersInput
    disconnect?: parentsWhereInput | boolean
    delete?: parentsWhereInput | boolean
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutUsersInput, parentsUpdateWithoutUsersInput>, parentsUncheckedUpdateWithoutUsersInput>
  }

  export type password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutUsersInput
    upsert?: password_reset_tokensUpsertWithoutUsersInput
    disconnect?: password_reset_tokensWhereInput | boolean
    delete?: password_reset_tokensWhereInput | boolean
    connect?: password_reset_tokensWhereUniqueInput
    update?: XOR<XOR<password_reset_tokensUpdateToOneWithWhereWithoutUsersInput, password_reset_tokensUpdateWithoutUsersInput>, password_reset_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput> | refresh_tokensCreateWithoutUsersInput[] | refresh_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput | refresh_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: refresh_tokensUpsertWithWhereUniqueWithoutUsersInput | refresh_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refresh_tokensCreateManyUsersInputEnvelope
    set?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    disconnect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    delete?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    connect?: refresh_tokensWhereUniqueInput | refresh_tokensWhereUniqueInput[]
    update?: refresh_tokensUpdateWithWhereUniqueWithoutUsersInput | refresh_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refresh_tokensUpdateManyWithWhereWithoutUsersInput | refresh_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
  }

  export type social_mediaUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput> | social_mediaCreateWithoutUsersInput[] | social_mediaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutUsersInput | social_mediaCreateOrConnectWithoutUsersInput[]
    upsert?: social_mediaUpsertWithWhereUniqueWithoutUsersInput | social_mediaUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: social_mediaCreateManyUsersInputEnvelope
    set?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    disconnect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    delete?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    update?: social_mediaUpdateWithWhereUniqueWithoutUsersInput | social_mediaUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: social_mediaUpdateManyWithWhereWithoutUsersInput | social_mediaUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
  }

  export type studentsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    upsert?: studentsUpsertWithoutUsersInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutUsersInput, studentsUpdateWithoutUsersInput>, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type teachersUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput
    upsert?: teachersUpsertWithoutUsersInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutUsersInput, teachersUpdateWithoutUsersInput>, teachersUncheckedUpdateWithoutUsersInput>
  }

  export type teaches_atUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput> | teaches_atCreateWithoutUsersInput[] | teaches_atUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teaches_atCreateOrConnectWithoutUsersInput | teaches_atCreateOrConnectWithoutUsersInput[]
    upsert?: teaches_atUpsertWithWhereUniqueWithoutUsersInput | teaches_atUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teaches_atCreateManyUsersInputEnvelope
    set?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    disconnect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    delete?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    connect?: teaches_atWhereUniqueInput | teaches_atWhereUniqueInput[]
    update?: teaches_atUpdateWithWhereUniqueWithoutUsersInput | teaches_atUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teaches_atUpdateManyWithWhereWithoutUsersInput | teaches_atUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teaches_atScalarWhereInput | teaches_atScalarWhereInput[]
  }

  export type user_analyticsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput
    upsert?: user_analyticsUpsertWithoutUsersInput
    disconnect?: user_analyticsWhereInput | boolean
    delete?: user_analyticsWhereInput | boolean
    connect?: user_analyticsWhereUniqueInput
    update?: XOR<XOR<user_analyticsUpdateToOneWithWhereWithoutUsersInput, user_analyticsUpdateWithoutUsersInput>, user_analyticsUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutRefresh_tokensInput = {
    create?: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefresh_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutRefresh_tokensNestedInput = {
    create?: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefresh_tokensInput
    upsert?: usersUpsertWithoutRefresh_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRefresh_tokensInput, usersUpdateWithoutRefresh_tokensInput>, usersUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type lecturersCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<lecturersCreateWithoutAssistantsInput, lecturersUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutAssistantsInput
    connect?: lecturersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<usersCreateWithoutAssistantsInput, usersUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssistantsInput
    connect?: usersWhereUniqueInput
  }

  export type lecturersUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<lecturersCreateWithoutAssistantsInput, lecturersUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: lecturersCreateOrConnectWithoutAssistantsInput
    upsert?: lecturersUpsertWithoutAssistantsInput
    connect?: lecturersWhereUniqueInput
    update?: XOR<XOR<lecturersUpdateToOneWithWhereWithoutAssistantsInput, lecturersUpdateWithoutAssistantsInput>, lecturersUncheckedUpdateWithoutAssistantsInput>
  }

  export type usersUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<usersCreateWithoutAssistantsInput, usersUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAssistantsInput
    upsert?: usersUpsertWithoutAssistantsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAssistantsInput, usersUpdateWithoutAssistantsInput>, usersUncheckedUpdateWithoutAssistantsInput>
  }

  export type parentsCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput> | parentsCreateWithoutGovernmentInput[] | parentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutGovernmentInput | parentsCreateOrConnectWithoutGovernmentInput[]
    createMany?: parentsCreateManyGovernmentInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput> | studentsCreateWithoutGovernmentInput[] | studentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutGovernmentInput | studentsCreateOrConnectWithoutGovernmentInput[]
    createMany?: studentsCreateManyGovernmentInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teachersCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput> | teachersCreateWithoutGovernmentInput[] | teachersUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutGovernmentInput | teachersCreateOrConnectWithoutGovernmentInput[]
    createMany?: teachersCreateManyGovernmentInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type zonesCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput> | zonesCreateWithoutGovernmentInput[] | zonesUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: zonesCreateOrConnectWithoutGovernmentInput | zonesCreateOrConnectWithoutGovernmentInput[]
    createMany?: zonesCreateManyGovernmentInputEnvelope
    connect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
  }

  export type parentsUncheckedCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput> | parentsCreateWithoutGovernmentInput[] | parentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutGovernmentInput | parentsCreateOrConnectWithoutGovernmentInput[]
    createMany?: parentsCreateManyGovernmentInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput> | studentsCreateWithoutGovernmentInput[] | studentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutGovernmentInput | studentsCreateOrConnectWithoutGovernmentInput[]
    createMany?: studentsCreateManyGovernmentInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teachersUncheckedCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput> | teachersCreateWithoutGovernmentInput[] | teachersUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutGovernmentInput | teachersCreateOrConnectWithoutGovernmentInput[]
    createMany?: teachersCreateManyGovernmentInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type zonesUncheckedCreateNestedManyWithoutGovernmentInput = {
    create?: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput> | zonesCreateWithoutGovernmentInput[] | zonesUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: zonesCreateOrConnectWithoutGovernmentInput | zonesCreateOrConnectWithoutGovernmentInput[]
    createMany?: zonesCreateManyGovernmentInputEnvelope
    connect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
  }

  export type parentsUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput> | parentsCreateWithoutGovernmentInput[] | parentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutGovernmentInput | parentsCreateOrConnectWithoutGovernmentInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutGovernmentInput | parentsUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: parentsCreateManyGovernmentInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutGovernmentInput | parentsUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutGovernmentInput | parentsUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput> | studentsCreateWithoutGovernmentInput[] | studentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutGovernmentInput | studentsCreateOrConnectWithoutGovernmentInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutGovernmentInput | studentsUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: studentsCreateManyGovernmentInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutGovernmentInput | studentsUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutGovernmentInput | studentsUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teachersUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput> | teachersCreateWithoutGovernmentInput[] | teachersUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutGovernmentInput | teachersCreateOrConnectWithoutGovernmentInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutGovernmentInput | teachersUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: teachersCreateManyGovernmentInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutGovernmentInput | teachersUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutGovernmentInput | teachersUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type zonesUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput> | zonesCreateWithoutGovernmentInput[] | zonesUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: zonesCreateOrConnectWithoutGovernmentInput | zonesCreateOrConnectWithoutGovernmentInput[]
    upsert?: zonesUpsertWithWhereUniqueWithoutGovernmentInput | zonesUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: zonesCreateManyGovernmentInputEnvelope
    set?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    disconnect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    delete?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    connect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    update?: zonesUpdateWithWhereUniqueWithoutGovernmentInput | zonesUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: zonesUpdateManyWithWhereWithoutGovernmentInput | zonesUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: zonesScalarWhereInput | zonesScalarWhereInput[]
  }

  export type parentsUncheckedUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput> | parentsCreateWithoutGovernmentInput[] | parentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutGovernmentInput | parentsCreateOrConnectWithoutGovernmentInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutGovernmentInput | parentsUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: parentsCreateManyGovernmentInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutGovernmentInput | parentsUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutGovernmentInput | parentsUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput> | studentsCreateWithoutGovernmentInput[] | studentsUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutGovernmentInput | studentsCreateOrConnectWithoutGovernmentInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutGovernmentInput | studentsUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: studentsCreateManyGovernmentInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutGovernmentInput | studentsUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutGovernmentInput | studentsUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teachersUncheckedUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput> | teachersCreateWithoutGovernmentInput[] | teachersUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutGovernmentInput | teachersCreateOrConnectWithoutGovernmentInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutGovernmentInput | teachersUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: teachersCreateManyGovernmentInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutGovernmentInput | teachersUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutGovernmentInput | teachersUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type zonesUncheckedUpdateManyWithoutGovernmentNestedInput = {
    create?: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput> | zonesCreateWithoutGovernmentInput[] | zonesUncheckedCreateWithoutGovernmentInput[]
    connectOrCreate?: zonesCreateOrConnectWithoutGovernmentInput | zonesCreateOrConnectWithoutGovernmentInput[]
    upsert?: zonesUpsertWithWhereUniqueWithoutGovernmentInput | zonesUpsertWithWhereUniqueWithoutGovernmentInput[]
    createMany?: zonesCreateManyGovernmentInputEnvelope
    set?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    disconnect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    delete?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    connect?: zonesWhereUniqueInput | zonesWhereUniqueInput[]
    update?: zonesUpdateWithWhereUniqueWithoutGovernmentInput | zonesUpdateWithWhereUniqueWithoutGovernmentInput[]
    updateMany?: zonesUpdateManyWithWhereWithoutGovernmentInput | zonesUpdateManyWithWhereWithoutGovernmentInput[]
    deleteMany?: zonesScalarWhereInput | zonesScalarWhereInput[]
  }

  export type assistantsCreateNestedManyWithoutLecturersInput = {
    create?: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput> | assistantsCreateWithoutLecturersInput[] | assistantsUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutLecturersInput | assistantsCreateOrConnectWithoutLecturersInput[]
    createMany?: assistantsCreateManyLecturersInputEnvelope
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutLecturersInput = {
    create?: XOR<usersCreateWithoutLecturersInput, usersUncheckedCreateWithoutLecturersInput>
    connectOrCreate?: usersCreateOrConnectWithoutLecturersInput
    connect?: usersWhereUniqueInput
  }

  export type assistantsUncheckedCreateNestedManyWithoutLecturersInput = {
    create?: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput> | assistantsCreateWithoutLecturersInput[] | assistantsUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutLecturersInput | assistantsCreateOrConnectWithoutLecturersInput[]
    createMany?: assistantsCreateManyLecturersInputEnvelope
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
  }

  export type assistantsUpdateManyWithoutLecturersNestedInput = {
    create?: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput> | assistantsCreateWithoutLecturersInput[] | assistantsUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutLecturersInput | assistantsCreateOrConnectWithoutLecturersInput[]
    upsert?: assistantsUpsertWithWhereUniqueWithoutLecturersInput | assistantsUpsertWithWhereUniqueWithoutLecturersInput[]
    createMany?: assistantsCreateManyLecturersInputEnvelope
    set?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    disconnect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    delete?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    update?: assistantsUpdateWithWhereUniqueWithoutLecturersInput | assistantsUpdateWithWhereUniqueWithoutLecturersInput[]
    updateMany?: assistantsUpdateManyWithWhereWithoutLecturersInput | assistantsUpdateManyWithWhereWithoutLecturersInput[]
    deleteMany?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutLecturersNestedInput = {
    create?: XOR<usersCreateWithoutLecturersInput, usersUncheckedCreateWithoutLecturersInput>
    connectOrCreate?: usersCreateOrConnectWithoutLecturersInput
    upsert?: usersUpsertWithoutLecturersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLecturersInput, usersUpdateWithoutLecturersInput>, usersUncheckedUpdateWithoutLecturersInput>
  }

  export type assistantsUncheckedUpdateManyWithoutLecturersNestedInput = {
    create?: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput> | assistantsCreateWithoutLecturersInput[] | assistantsUncheckedCreateWithoutLecturersInput[]
    connectOrCreate?: assistantsCreateOrConnectWithoutLecturersInput | assistantsCreateOrConnectWithoutLecturersInput[]
    upsert?: assistantsUpsertWithWhereUniqueWithoutLecturersInput | assistantsUpsertWithWhereUniqueWithoutLecturersInput[]
    createMany?: assistantsCreateManyLecturersInputEnvelope
    set?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    disconnect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    delete?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    connect?: assistantsWhereUniqueInput | assistantsWhereUniqueInput[]
    update?: assistantsUpdateWithWhereUniqueWithoutLecturersInput | assistantsUpdateWithWhereUniqueWithoutLecturersInput[]
    updateMany?: assistantsUpdateManyWithWhereWithoutLecturersInput | assistantsUpdateManyWithWhereWithoutLecturersInput[]
    deleteMany?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
  }

  export type studentsCreateNestedManyWithoutLevelsInput = {
    create?: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput> | studentsCreateWithoutLevelsInput[] | studentsUncheckedCreateWithoutLevelsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutLevelsInput | studentsCreateOrConnectWithoutLevelsInput[]
    createMany?: studentsCreateManyLevelsInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutLevelsInput = {
    create?: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput> | studentsCreateWithoutLevelsInput[] | studentsUncheckedCreateWithoutLevelsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutLevelsInput | studentsCreateOrConnectWithoutLevelsInput[]
    createMany?: studentsCreateManyLevelsInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type studentsUpdateManyWithoutLevelsNestedInput = {
    create?: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput> | studentsCreateWithoutLevelsInput[] | studentsUncheckedCreateWithoutLevelsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutLevelsInput | studentsCreateOrConnectWithoutLevelsInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutLevelsInput | studentsUpsertWithWhereUniqueWithoutLevelsInput[]
    createMany?: studentsCreateManyLevelsInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutLevelsInput | studentsUpdateWithWhereUniqueWithoutLevelsInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutLevelsInput | studentsUpdateManyWithWhereWithoutLevelsInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutLevelsNestedInput = {
    create?: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput> | studentsCreateWithoutLevelsInput[] | studentsUncheckedCreateWithoutLevelsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutLevelsInput | studentsCreateOrConnectWithoutLevelsInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutLevelsInput | studentsUpsertWithWhereUniqueWithoutLevelsInput[]
    createMany?: studentsCreateManyLevelsInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutLevelsInput | studentsUpdateWithWhereUniqueWithoutLevelsInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutLevelsInput | studentsUpdateManyWithWhereWithoutLevelsInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type parentsCreateNestedOneWithoutParent_childrenInput = {
    create?: XOR<parentsCreateWithoutParent_childrenInput, parentsUncheckedCreateWithoutParent_childrenInput>
    connectOrCreate?: parentsCreateOrConnectWithoutParent_childrenInput
    connect?: parentsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutParent_childrenInput = {
    create?: XOR<studentsCreateWithoutParent_childrenInput, studentsUncheckedCreateWithoutParent_childrenInput>
    connectOrCreate?: studentsCreateOrConnectWithoutParent_childrenInput
    connect?: studentsWhereUniqueInput
  }

  export type parentsUpdateOneRequiredWithoutParent_childrenNestedInput = {
    create?: XOR<parentsCreateWithoutParent_childrenInput, parentsUncheckedCreateWithoutParent_childrenInput>
    connectOrCreate?: parentsCreateOrConnectWithoutParent_childrenInput
    upsert?: parentsUpsertWithoutParent_childrenInput
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutParent_childrenInput, parentsUpdateWithoutParent_childrenInput>, parentsUncheckedUpdateWithoutParent_childrenInput>
  }

  export type studentsUpdateOneRequiredWithoutParent_childrenNestedInput = {
    create?: XOR<studentsCreateWithoutParent_childrenInput, studentsUncheckedCreateWithoutParent_childrenInput>
    connectOrCreate?: studentsCreateOrConnectWithoutParent_childrenInput
    upsert?: studentsUpsertWithoutParent_childrenInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutParent_childrenInput, studentsUpdateWithoutParent_childrenInput>, studentsUncheckedUpdateWithoutParent_childrenInput>
  }

  export type parent_childrenCreateNestedManyWithoutParentsInput = {
    create?: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput> | parent_childrenCreateWithoutParentsInput[] | parent_childrenUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutParentsInput | parent_childrenCreateOrConnectWithoutParentsInput[]
    createMany?: parent_childrenCreateManyParentsInputEnvelope
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
  }

  export type governmentCreateNestedOneWithoutParentsInput = {
    create?: XOR<governmentCreateWithoutParentsInput, governmentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: governmentCreateOrConnectWithoutParentsInput
    connect?: governmentWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutParentsInput = {
    create?: XOR<usersCreateWithoutParentsInput, usersUncheckedCreateWithoutParentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutParentsInput
    connect?: usersWhereUniqueInput
  }

  export type zonesCreateNestedOneWithoutParentsInput = {
    create?: XOR<zonesCreateWithoutParentsInput, zonesUncheckedCreateWithoutParentsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutParentsInput
    connect?: zonesWhereUniqueInput
  }

  export type parent_childrenUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput> | parent_childrenCreateWithoutParentsInput[] | parent_childrenUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutParentsInput | parent_childrenCreateOrConnectWithoutParentsInput[]
    createMany?: parent_childrenCreateManyParentsInputEnvelope
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
  }

  export type parent_childrenUpdateManyWithoutParentsNestedInput = {
    create?: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput> | parent_childrenCreateWithoutParentsInput[] | parent_childrenUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutParentsInput | parent_childrenCreateOrConnectWithoutParentsInput[]
    upsert?: parent_childrenUpsertWithWhereUniqueWithoutParentsInput | parent_childrenUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: parent_childrenCreateManyParentsInputEnvelope
    set?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    disconnect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    delete?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    update?: parent_childrenUpdateWithWhereUniqueWithoutParentsInput | parent_childrenUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: parent_childrenUpdateManyWithWhereWithoutParentsInput | parent_childrenUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
  }

  export type governmentUpdateOneWithoutParentsNestedInput = {
    create?: XOR<governmentCreateWithoutParentsInput, governmentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: governmentCreateOrConnectWithoutParentsInput
    upsert?: governmentUpsertWithoutParentsInput
    disconnect?: governmentWhereInput | boolean
    delete?: governmentWhereInput | boolean
    connect?: governmentWhereUniqueInput
    update?: XOR<XOR<governmentUpdateToOneWithWhereWithoutParentsInput, governmentUpdateWithoutParentsInput>, governmentUncheckedUpdateWithoutParentsInput>
  }

  export type usersUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<usersCreateWithoutParentsInput, usersUncheckedCreateWithoutParentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutParentsInput
    upsert?: usersUpsertWithoutParentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutParentsInput, usersUpdateWithoutParentsInput>, usersUncheckedUpdateWithoutParentsInput>
  }

  export type zonesUpdateOneWithoutParentsNestedInput = {
    create?: XOR<zonesCreateWithoutParentsInput, zonesUncheckedCreateWithoutParentsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutParentsInput
    upsert?: zonesUpsertWithoutParentsInput
    disconnect?: zonesWhereInput | boolean
    delete?: zonesWhereInput | boolean
    connect?: zonesWhereUniqueInput
    update?: XOR<XOR<zonesUpdateToOneWithWhereWithoutParentsInput, zonesUpdateWithoutParentsInput>, zonesUncheckedUpdateWithoutParentsInput>
  }

  export type parent_childrenUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput> | parent_childrenCreateWithoutParentsInput[] | parent_childrenUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutParentsInput | parent_childrenCreateOrConnectWithoutParentsInput[]
    upsert?: parent_childrenUpsertWithWhereUniqueWithoutParentsInput | parent_childrenUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: parent_childrenCreateManyParentsInputEnvelope
    set?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    disconnect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    delete?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    update?: parent_childrenUpdateWithWhereUniqueWithoutParentsInput | parent_childrenUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: parent_childrenUpdateManyWithWhereWithoutParentsInput | parent_childrenUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
  }

  export type social_mediaCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput> | social_mediaCreateWithoutSitesInput[] | social_mediaUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutSitesInput | social_mediaCreateOrConnectWithoutSitesInput[]
    createMany?: social_mediaCreateManySitesInputEnvelope
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
  }

  export type social_mediaUncheckedCreateNestedManyWithoutSitesInput = {
    create?: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput> | social_mediaCreateWithoutSitesInput[] | social_mediaUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutSitesInput | social_mediaCreateOrConnectWithoutSitesInput[]
    createMany?: social_mediaCreateManySitesInputEnvelope
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
  }

  export type social_mediaUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput> | social_mediaCreateWithoutSitesInput[] | social_mediaUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutSitesInput | social_mediaCreateOrConnectWithoutSitesInput[]
    upsert?: social_mediaUpsertWithWhereUniqueWithoutSitesInput | social_mediaUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_mediaCreateManySitesInputEnvelope
    set?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    disconnect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    delete?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    update?: social_mediaUpdateWithWhereUniqueWithoutSitesInput | social_mediaUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_mediaUpdateManyWithWhereWithoutSitesInput | social_mediaUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
  }

  export type social_mediaUncheckedUpdateManyWithoutSitesNestedInput = {
    create?: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput> | social_mediaCreateWithoutSitesInput[] | social_mediaUncheckedCreateWithoutSitesInput[]
    connectOrCreate?: social_mediaCreateOrConnectWithoutSitesInput | social_mediaCreateOrConnectWithoutSitesInput[]
    upsert?: social_mediaUpsertWithWhereUniqueWithoutSitesInput | social_mediaUpsertWithWhereUniqueWithoutSitesInput[]
    createMany?: social_mediaCreateManySitesInputEnvelope
    set?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    disconnect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    delete?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    connect?: social_mediaWhereUniqueInput | social_mediaWhereUniqueInput[]
    update?: social_mediaUpdateWithWhereUniqueWithoutSitesInput | social_mediaUpdateWithWhereUniqueWithoutSitesInput[]
    updateMany?: social_mediaUpdateManyWithWhereWithoutSitesInput | social_mediaUpdateManyWithWhereWithoutSitesInput[]
    deleteMany?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
  }

  export type sitesCreateNestedOneWithoutSocial_mediaInput = {
    create?: XOR<sitesCreateWithoutSocial_mediaInput, sitesUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: sitesCreateOrConnectWithoutSocial_mediaInput
    connect?: sitesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSocial_mediaInput = {
    create?: XOR<usersCreateWithoutSocial_mediaInput, usersUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: usersCreateOrConnectWithoutSocial_mediaInput
    connect?: usersWhereUniqueInput
  }

  export type sitesUpdateOneWithoutSocial_mediaNestedInput = {
    create?: XOR<sitesCreateWithoutSocial_mediaInput, sitesUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: sitesCreateOrConnectWithoutSocial_mediaInput
    upsert?: sitesUpsertWithoutSocial_mediaInput
    disconnect?: sitesWhereInput | boolean
    delete?: sitesWhereInput | boolean
    connect?: sitesWhereUniqueInput
    update?: XOR<XOR<sitesUpdateToOneWithWhereWithoutSocial_mediaInput, sitesUpdateWithoutSocial_mediaInput>, sitesUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type usersUpdateOneRequiredWithoutSocial_mediaNestedInput = {
    create?: XOR<usersCreateWithoutSocial_mediaInput, usersUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: usersCreateOrConnectWithoutSocial_mediaInput
    upsert?: usersUpsertWithoutSocial_mediaInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSocial_mediaInput, usersUpdateWithoutSocial_mediaInput>, usersUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type parent_childrenCreateNestedManyWithoutStudentsInput = {
    create?: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput> | parent_childrenCreateWithoutStudentsInput[] | parent_childrenUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutStudentsInput | parent_childrenCreateOrConnectWithoutStudentsInput[]
    createMany?: parent_childrenCreateManyStudentsInputEnvelope
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
  }

  export type governmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<governmentCreateWithoutStudentsInput, governmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: governmentCreateOrConnectWithoutStudentsInput
    connect?: governmentWhereUniqueInput
  }

  export type levelsCreateNestedOneWithoutStudentsInput = {
    create?: XOR<levelsCreateWithoutStudentsInput, levelsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: levelsCreateOrConnectWithoutStudentsInput
    connect?: levelsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutStudentsInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    connect?: usersWhereUniqueInput
  }

  export type zonesCreateNestedOneWithoutStudentsInput = {
    create?: XOR<zonesCreateWithoutStudentsInput, zonesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutStudentsInput
    connect?: zonesWhereUniqueInput
  }

  export type parent_childrenUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput> | parent_childrenCreateWithoutStudentsInput[] | parent_childrenUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutStudentsInput | parent_childrenCreateOrConnectWithoutStudentsInput[]
    createMany?: parent_childrenCreateManyStudentsInputEnvelope
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
  }

  export type parent_childrenUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput> | parent_childrenCreateWithoutStudentsInput[] | parent_childrenUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutStudentsInput | parent_childrenCreateOrConnectWithoutStudentsInput[]
    upsert?: parent_childrenUpsertWithWhereUniqueWithoutStudentsInput | parent_childrenUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: parent_childrenCreateManyStudentsInputEnvelope
    set?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    disconnect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    delete?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    update?: parent_childrenUpdateWithWhereUniqueWithoutStudentsInput | parent_childrenUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: parent_childrenUpdateManyWithWhereWithoutStudentsInput | parent_childrenUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
  }

  export type governmentUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<governmentCreateWithoutStudentsInput, governmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: governmentCreateOrConnectWithoutStudentsInput
    upsert?: governmentUpsertWithoutStudentsInput
    disconnect?: governmentWhereInput | boolean
    delete?: governmentWhereInput | boolean
    connect?: governmentWhereUniqueInput
    update?: XOR<XOR<governmentUpdateToOneWithWhereWithoutStudentsInput, governmentUpdateWithoutStudentsInput>, governmentUncheckedUpdateWithoutStudentsInput>
  }

  export type levelsUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<levelsCreateWithoutStudentsInput, levelsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: levelsCreateOrConnectWithoutStudentsInput
    upsert?: levelsUpsertWithoutStudentsInput
    disconnect?: levelsWhereInput | boolean
    delete?: levelsWhereInput | boolean
    connect?: levelsWhereUniqueInput
    update?: XOR<XOR<levelsUpdateToOneWithWhereWithoutStudentsInput, levelsUpdateWithoutStudentsInput>, levelsUncheckedUpdateWithoutStudentsInput>
  }

  export type usersUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    upsert?: usersUpsertWithoutStudentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudentsInput, usersUpdateWithoutStudentsInput>, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type zonesUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<zonesCreateWithoutStudentsInput, zonesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutStudentsInput
    upsert?: zonesUpsertWithoutStudentsInput
    disconnect?: zonesWhereInput | boolean
    delete?: zonesWhereInput | boolean
    connect?: zonesWhereUniqueInput
    update?: XOR<XOR<zonesUpdateToOneWithWhereWithoutStudentsInput, zonesUpdateWithoutStudentsInput>, zonesUncheckedUpdateWithoutStudentsInput>
  }

  export type parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput> | parent_childrenCreateWithoutStudentsInput[] | parent_childrenUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_childrenCreateOrConnectWithoutStudentsInput | parent_childrenCreateOrConnectWithoutStudentsInput[]
    upsert?: parent_childrenUpsertWithWhereUniqueWithoutStudentsInput | parent_childrenUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: parent_childrenCreateManyStudentsInputEnvelope
    set?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    disconnect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    delete?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    connect?: parent_childrenWhereUniqueInput | parent_childrenWhereUniqueInput[]
    update?: parent_childrenUpdateWithWhereUniqueWithoutStudentsInput | parent_childrenUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: parent_childrenUpdateManyWithWhereWithoutStudentsInput | parent_childrenUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
  }

  export type teachersCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput> | teachersCreateWithoutSubjectsInput[] | teachersUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSubjectsInput | teachersCreateOrConnectWithoutSubjectsInput[]
    createMany?: teachersCreateManySubjectsInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type teachersUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput> | teachersCreateWithoutSubjectsInput[] | teachersUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSubjectsInput | teachersCreateOrConnectWithoutSubjectsInput[]
    createMany?: teachersCreateManySubjectsInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type teachersUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput> | teachersCreateWithoutSubjectsInput[] | teachersUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSubjectsInput | teachersCreateOrConnectWithoutSubjectsInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutSubjectsInput | teachersUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: teachersCreateManySubjectsInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutSubjectsInput | teachersUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutSubjectsInput | teachersUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type teachersUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput> | teachersCreateWithoutSubjectsInput[] | teachersUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSubjectsInput | teachersCreateOrConnectWithoutSubjectsInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutSubjectsInput | teachersUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: teachersCreateManySubjectsInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutSubjectsInput | teachersUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutSubjectsInput | teachersUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type governmentCreateNestedOneWithoutTeachersInput = {
    create?: XOR<governmentCreateWithoutTeachersInput, governmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: governmentCreateOrConnectWithoutTeachersInput
    connect?: governmentWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutTeachersInput = {
    create?: XOR<subjectsCreateWithoutTeachersInput, subjectsUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTeachersInput
    connect?: subjectsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTeachersInput = {
    create?: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeachersInput
    connect?: usersWhereUniqueInput
  }

  export type zonesCreateNestedOneWithoutTeachersInput = {
    create?: XOR<zonesCreateWithoutTeachersInput, zonesUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: zonesCreateOrConnectWithoutTeachersInput
    connect?: zonesWhereUniqueInput
  }

  export type governmentUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<governmentCreateWithoutTeachersInput, governmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: governmentCreateOrConnectWithoutTeachersInput
    upsert?: governmentUpsertWithoutTeachersInput
    disconnect?: governmentWhereInput | boolean
    delete?: governmentWhereInput | boolean
    connect?: governmentWhereUniqueInput
    update?: XOR<XOR<governmentUpdateToOneWithWhereWithoutTeachersInput, governmentUpdateWithoutTeachersInput>, governmentUncheckedUpdateWithoutTeachersInput>
  }

  export type subjectsUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<subjectsCreateWithoutTeachersInput, subjectsUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTeachersInput
    upsert?: subjectsUpsertWithoutTeachersInput
    disconnect?: subjectsWhereInput | boolean
    delete?: subjectsWhereInput | boolean
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutTeachersInput, subjectsUpdateWithoutTeachersInput>, subjectsUncheckedUpdateWithoutTeachersInput>
  }

  export type usersUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeachersInput
    upsert?: usersUpsertWithoutTeachersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTeachersInput, usersUpdateWithoutTeachersInput>, usersUncheckedUpdateWithoutTeachersInput>
  }

  export type zonesUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<zonesCreateWithoutTeachersInput, zonesUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: zonesCreateOrConnectWithoutTeachersInput
    upsert?: zonesUpsertWithoutTeachersInput
    disconnect?: zonesWhereInput | boolean
    delete?: zonesWhereInput | boolean
    connect?: zonesWhereUniqueInput
    update?: XOR<XOR<zonesUpdateToOneWithWhereWithoutTeachersInput, zonesUpdateWithoutTeachersInput>, zonesUncheckedUpdateWithoutTeachersInput>
  }

  export type usersCreateNestedOneWithoutTeaches_atInput = {
    create?: XOR<usersCreateWithoutTeaches_atInput, usersUncheckedCreateWithoutTeaches_atInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeaches_atInput
    connect?: usersWhereUniqueInput
  }

  export type NullableEnumlocation_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.location_type_enum | null
  }

  export type usersUpdateOneRequiredWithoutTeaches_atNestedInput = {
    create?: XOR<usersCreateWithoutTeaches_atInput, usersUncheckedCreateWithoutTeaches_atInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeaches_atInput
    upsert?: usersUpsertWithoutTeaches_atInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTeaches_atInput, usersUpdateWithoutTeaches_atInput>, usersUncheckedUpdateWithoutTeaches_atInput>
  }

  export type parentsCreateNestedManyWithoutZonesInput = {
    create?: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput> | parentsCreateWithoutZonesInput[] | parentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutZonesInput | parentsCreateOrConnectWithoutZonesInput[]
    createMany?: parentsCreateManyZonesInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutZonesInput = {
    create?: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput> | studentsCreateWithoutZonesInput[] | studentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutZonesInput | studentsCreateOrConnectWithoutZonesInput[]
    createMany?: studentsCreateManyZonesInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teachersCreateNestedManyWithoutZonesInput = {
    create?: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput> | teachersCreateWithoutZonesInput[] | teachersUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutZonesInput | teachersCreateOrConnectWithoutZonesInput[]
    createMany?: teachersCreateManyZonesInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type governmentCreateNestedOneWithoutZonesInput = {
    create?: XOR<governmentCreateWithoutZonesInput, governmentUncheckedCreateWithoutZonesInput>
    connectOrCreate?: governmentCreateOrConnectWithoutZonesInput
    connect?: governmentWhereUniqueInput
  }

  export type parentsUncheckedCreateNestedManyWithoutZonesInput = {
    create?: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput> | parentsCreateWithoutZonesInput[] | parentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutZonesInput | parentsCreateOrConnectWithoutZonesInput[]
    createMany?: parentsCreateManyZonesInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutZonesInput = {
    create?: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput> | studentsCreateWithoutZonesInput[] | studentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutZonesInput | studentsCreateOrConnectWithoutZonesInput[]
    createMany?: studentsCreateManyZonesInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teachersUncheckedCreateNestedManyWithoutZonesInput = {
    create?: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput> | teachersCreateWithoutZonesInput[] | teachersUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutZonesInput | teachersCreateOrConnectWithoutZonesInput[]
    createMany?: teachersCreateManyZonesInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type parentsUpdateManyWithoutZonesNestedInput = {
    create?: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput> | parentsCreateWithoutZonesInput[] | parentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutZonesInput | parentsCreateOrConnectWithoutZonesInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutZonesInput | parentsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: parentsCreateManyZonesInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutZonesInput | parentsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutZonesInput | parentsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutZonesNestedInput = {
    create?: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput> | studentsCreateWithoutZonesInput[] | studentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutZonesInput | studentsCreateOrConnectWithoutZonesInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutZonesInput | studentsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: studentsCreateManyZonesInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutZonesInput | studentsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutZonesInput | studentsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teachersUpdateManyWithoutZonesNestedInput = {
    create?: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput> | teachersCreateWithoutZonesInput[] | teachersUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutZonesInput | teachersCreateOrConnectWithoutZonesInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutZonesInput | teachersUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: teachersCreateManyZonesInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutZonesInput | teachersUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutZonesInput | teachersUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type governmentUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<governmentCreateWithoutZonesInput, governmentUncheckedCreateWithoutZonesInput>
    connectOrCreate?: governmentCreateOrConnectWithoutZonesInput
    upsert?: governmentUpsertWithoutZonesInput
    connect?: governmentWhereUniqueInput
    update?: XOR<XOR<governmentUpdateToOneWithWhereWithoutZonesInput, governmentUpdateWithoutZonesInput>, governmentUncheckedUpdateWithoutZonesInput>
  }

  export type parentsUncheckedUpdateManyWithoutZonesNestedInput = {
    create?: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput> | parentsCreateWithoutZonesInput[] | parentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutZonesInput | parentsCreateOrConnectWithoutZonesInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutZonesInput | parentsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: parentsCreateManyZonesInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutZonesInput | parentsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutZonesInput | parentsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutZonesNestedInput = {
    create?: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput> | studentsCreateWithoutZonesInput[] | studentsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutZonesInput | studentsCreateOrConnectWithoutZonesInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutZonesInput | studentsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: studentsCreateManyZonesInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutZonesInput | studentsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutZonesInput | studentsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teachersUncheckedUpdateManyWithoutZonesNestedInput = {
    create?: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput> | teachersCreateWithoutZonesInput[] | teachersUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutZonesInput | teachersCreateOrConnectWithoutZonesInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutZonesInput | teachersUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: teachersCreateManyZonesInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutZonesInput | teachersUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutZonesInput | teachersUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutEmail_verification_tokensInput = {
    create?: XOR<usersCreateWithoutEmail_verification_tokensInput, usersUncheckedCreateWithoutEmail_verification_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutEmail_verification_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutEmail_verification_tokensNestedInput = {
    create?: XOR<usersCreateWithoutEmail_verification_tokensInput, usersUncheckedCreateWithoutEmail_verification_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutEmail_verification_tokensInput
    upsert?: usersUpsertWithoutEmail_verification_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutEmail_verification_tokensInput, usersUpdateWithoutEmail_verification_tokensInput>, usersUncheckedUpdateWithoutEmail_verification_tokensInput>
  }

  export type usersCreateNestedOneWithoutPassword_reset_tokensInput = {
    create?: XOR<usersCreateWithoutPassword_reset_tokensInput, usersUncheckedCreateWithoutPassword_reset_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutPassword_reset_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPassword_reset_tokensNestedInput = {
    create?: XOR<usersCreateWithoutPassword_reset_tokensInput, usersUncheckedCreateWithoutPassword_reset_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutPassword_reset_tokensInput
    upsert?: usersUpsertWithoutPassword_reset_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPassword_reset_tokensInput, usersUpdateWithoutPassword_reset_tokensInput>, usersUncheckedUpdateWithoutPassword_reset_tokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumauth_provider_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.auth_provider_enum | Enumauth_provider_enumFieldRefInput<$PrismaModel>
    in?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumauth_provider_enumFilter<$PrismaModel> | $Enums.auth_provider_enum
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumauth_provider_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.auth_provider_enum | Enumauth_provider_enumFieldRefInput<$PrismaModel>
    in?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.auth_provider_enum[] | ListEnumauth_provider_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumauth_provider_enumWithAggregatesFilter<$PrismaModel> | $Enums.auth_provider_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumauth_provider_enumFilter<$PrismaModel>
    _max?: NestedEnumauth_provider_enumFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumportal_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.portal_enum | Enumportal_enumFieldRefInput<$PrismaModel>
    in?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumportal_enumFilter<$PrismaModel> | $Enums.portal_enum
  }

  export type NestedEnumrole_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel>
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumrole_enumFilter<$PrismaModel> | $Enums.role_enum
  }

  export type NestedEnumportal_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.portal_enum | Enumportal_enumFieldRefInput<$PrismaModel>
    in?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.portal_enum[] | ListEnumportal_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumportal_enumWithAggregatesFilter<$PrismaModel> | $Enums.portal_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumportal_enumFilter<$PrismaModel>
    _max?: NestedEnumportal_enumFilter<$PrismaModel>
  }

  export type NestedEnumrole_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel>
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumrole_enumWithAggregatesFilter<$PrismaModel> | $Enums.role_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrole_enumFilter<$PrismaModel>
    _max?: NestedEnumrole_enumFilter<$PrismaModel>
  }

  export type NestedEnumgender_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.gender_enum | Enumgender_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumgender_enumNullableFilter<$PrismaModel> | $Enums.gender_enum | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumrole_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_enumNullableFilter<$PrismaModel> | $Enums.role_enum | null
  }

  export type NestedEnumgender_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.gender_enum | Enumgender_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.gender_enum[] | ListEnumgender_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumgender_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.gender_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumgender_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumgender_enumNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumrole_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role_enum | Enumrole_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.role_enum[] | ListEnumrole_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrole_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.role_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrole_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumrole_enumNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumlocation_type_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.location_type_enum | Enumlocation_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel> | $Enums.location_type_enum | null
  }

  export type NestedEnumlocation_type_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.location_type_enum | Enumlocation_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.location_type_enum[] | ListEnumlocation_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumlocation_type_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.location_type_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumlocation_type_enumNullableFilter<$PrismaModel>
  }

  export type usersCreateWithoutAuth_identitiesInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAuth_identitiesInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAuth_identitiesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuth_identitiesInput, usersUncheckedCreateWithoutAuth_identitiesInput>
  }

  export type usersUpsertWithoutAuth_identitiesInput = {
    update: XOR<usersUpdateWithoutAuth_identitiesInput, usersUncheckedUpdateWithoutAuth_identitiesInput>
    create: XOR<usersCreateWithoutAuth_identitiesInput, usersUncheckedCreateWithoutAuth_identitiesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuth_identitiesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuth_identitiesInput, usersUncheckedUpdateWithoutAuth_identitiesInput>
  }

  export type usersUpdateWithoutAuth_identitiesInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAuth_identitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_analyticsInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_analyticsInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_analyticsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
  }

  export type usersUpsertWithoutUser_analyticsInput = {
    update: XOR<usersUpdateWithoutUser_analyticsInput, usersUncheckedUpdateWithoutUser_analyticsInput>
    create: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_analyticsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_analyticsInput, usersUncheckedUpdateWithoutUser_analyticsInput>
  }

  export type usersUpdateWithoutUser_analyticsInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_analyticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_rolesInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_rolesInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_rolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
  }

  export type usersUpsertWithoutUser_rolesInput = {
    update: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type usersUpdateWithoutUser_rolesInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type assistantsCreateWithoutUsersInput = {
    lecturers: lecturersCreateNestedOneWithoutAssistantsInput
  }

  export type assistantsUncheckedCreateWithoutUsersInput = {
    id?: number
    lecturer_user_id: number
  }

  export type assistantsCreateOrConnectWithoutUsersInput = {
    where: assistantsWhereUniqueInput
    create: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput>
  }

  export type assistantsCreateManyUsersInputEnvelope = {
    data: assistantsCreateManyUsersInput | assistantsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type auth_identitiesCreateWithoutUsersInput = {
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
  }

  export type auth_identitiesUncheckedCreateWithoutUsersInput = {
    id?: number
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
  }

  export type auth_identitiesCreateOrConnectWithoutUsersInput = {
    where: auth_identitiesWhereUniqueInput
    create: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput>
  }

  export type auth_identitiesCreateManyUsersInputEnvelope = {
    data: auth_identitiesCreateManyUsersInput | auth_identitiesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type email_verification_tokensCreateWithoutUsersInput = {
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type email_verification_tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type email_verification_tokensCreateOrConnectWithoutUsersInput = {
    where: email_verification_tokensWhereUniqueInput
    create: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
  }

  export type lecturersCreateWithoutUsersInput = {
    bio?: string | null
    expertise?: string | null
    assistants?: assistantsCreateNestedManyWithoutLecturersInput
  }

  export type lecturersUncheckedCreateWithoutUsersInput = {
    bio?: string | null
    expertise?: string | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutLecturersInput
  }

  export type lecturersCreateOrConnectWithoutUsersInput = {
    where: lecturersWhereUniqueInput
    create: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
  }

  export type parentsCreateWithoutUsersInput = {
    parent_children?: parent_childrenCreateNestedManyWithoutParentsInput
    government?: governmentCreateNestedOneWithoutParentsInput
    zones?: zonesCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutUsersInput = {
    government_id?: number | null
    zone_id?: number | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutUsersInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
  }

  export type password_reset_tokensCreateWithoutUsersInput = {
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type password_reset_tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token_hash: string
    created_at?: Date | string | null
    expires_at: Date | string
    used_at?: Date | string | null
  }

  export type password_reset_tokensCreateOrConnectWithoutUsersInput = {
    where: password_reset_tokensWhereUniqueInput
    create: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
  }

  export type refresh_tokensCreateWithoutUsersInput = {
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
  }

  export type refresh_tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
  }

  export type refresh_tokensCreateOrConnectWithoutUsersInput = {
    where: refresh_tokensWhereUniqueInput
    create: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
  }

  export type refresh_tokensCreateManyUsersInputEnvelope = {
    data: refresh_tokensCreateManyUsersInput | refresh_tokensCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type social_mediaCreateWithoutUsersInput = {
    url: string
    active?: boolean | null
    sites?: sitesCreateNestedOneWithoutSocial_mediaInput
  }

  export type social_mediaUncheckedCreateWithoutUsersInput = {
    id?: number
    site_id?: number | null
    url: string
    active?: boolean | null
  }

  export type social_mediaCreateOrConnectWithoutUsersInput = {
    where: social_mediaWhereUniqueInput
    create: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput>
  }

  export type social_mediaCreateManyUsersInputEnvelope = {
    data: social_mediaCreateManyUsersInput | social_mediaCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutUsersInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenCreateNestedManyWithoutStudentsInput
    government?: governmentCreateNestedOneWithoutStudentsInput
    levels?: levelsCreateNestedOneWithoutStudentsInput
    zones?: zonesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutUsersInput = {
    level_id?: number | null
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutUsersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
  }

  export type teachersCreateWithoutUsersInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government?: governmentCreateNestedOneWithoutTeachersInput
    subjects?: subjectsCreateNestedOneWithoutTeachersInput
    zones?: zonesCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutUsersInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    zone_id?: number | null
    subject_id?: number | null
  }

  export type teachersCreateOrConnectWithoutUsersInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
  }

  export type teaches_atCreateWithoutUsersInput = {
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
  }

  export type teaches_atUncheckedCreateWithoutUsersInput = {
    id?: number
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
  }

  export type teaches_atCreateOrConnectWithoutUsersInput = {
    where: teaches_atWhereUniqueInput
    create: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput>
  }

  export type teaches_atCreateManyUsersInputEnvelope = {
    data: teaches_atCreateManyUsersInput | teaches_atCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_analyticsCreateWithoutUsersInput = {
    views?: number | null
    total_spent?: Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: number | null
    successful_invites?: number | null
    monthly_confirmed_count?: number | null
    last_confirmed_count_update?: Date | string | null
  }

  export type user_analyticsUncheckedCreateWithoutUsersInput = {
    views?: number | null
    total_spent?: Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: number | null
    successful_invites?: number | null
    monthly_confirmed_count?: number | null
    last_confirmed_count_update?: Date | string | null
  }

  export type user_analyticsCreateOrConnectWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesCreateWithoutUsersInput = {
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type user_rolesUncheckedCreateWithoutUsersInput = {
    id?: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type user_rolesCreateOrConnectWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesCreateManyUsersInputEnvelope = {
    data: user_rolesCreateManyUsersInput | user_rolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type assistantsUpsertWithWhereUniqueWithoutUsersInput = {
    where: assistantsWhereUniqueInput
    update: XOR<assistantsUpdateWithoutUsersInput, assistantsUncheckedUpdateWithoutUsersInput>
    create: XOR<assistantsCreateWithoutUsersInput, assistantsUncheckedCreateWithoutUsersInput>
  }

  export type assistantsUpdateWithWhereUniqueWithoutUsersInput = {
    where: assistantsWhereUniqueInput
    data: XOR<assistantsUpdateWithoutUsersInput, assistantsUncheckedUpdateWithoutUsersInput>
  }

  export type assistantsUpdateManyWithWhereWithoutUsersInput = {
    where: assistantsScalarWhereInput
    data: XOR<assistantsUpdateManyMutationInput, assistantsUncheckedUpdateManyWithoutUsersInput>
  }

  export type assistantsScalarWhereInput = {
    AND?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
    OR?: assistantsScalarWhereInput[]
    NOT?: assistantsScalarWhereInput | assistantsScalarWhereInput[]
    id?: IntFilter<"assistants"> | number
    user_id?: IntFilter<"assistants"> | number
    lecturer_user_id?: IntFilter<"assistants"> | number
  }

  export type auth_identitiesUpsertWithWhereUniqueWithoutUsersInput = {
    where: auth_identitiesWhereUniqueInput
    update: XOR<auth_identitiesUpdateWithoutUsersInput, auth_identitiesUncheckedUpdateWithoutUsersInput>
    create: XOR<auth_identitiesCreateWithoutUsersInput, auth_identitiesUncheckedCreateWithoutUsersInput>
  }

  export type auth_identitiesUpdateWithWhereUniqueWithoutUsersInput = {
    where: auth_identitiesWhereUniqueInput
    data: XOR<auth_identitiesUpdateWithoutUsersInput, auth_identitiesUncheckedUpdateWithoutUsersInput>
  }

  export type auth_identitiesUpdateManyWithWhereWithoutUsersInput = {
    where: auth_identitiesScalarWhereInput
    data: XOR<auth_identitiesUpdateManyMutationInput, auth_identitiesUncheckedUpdateManyWithoutUsersInput>
  }

  export type auth_identitiesScalarWhereInput = {
    AND?: auth_identitiesScalarWhereInput | auth_identitiesScalarWhereInput[]
    OR?: auth_identitiesScalarWhereInput[]
    NOT?: auth_identitiesScalarWhereInput | auth_identitiesScalarWhereInput[]
    id?: IntFilter<"auth_identities"> | number
    user_id?: IntFilter<"auth_identities"> | number
    provider?: Enumauth_provider_enumFilter<"auth_identities"> | $Enums.auth_provider_enum
    provider_user_id?: StringFilter<"auth_identities"> | string
    provider_email?: StringNullableFilter<"auth_identities"> | string | null
  }

  export type email_verification_tokensUpsertWithoutUsersInput = {
    update: XOR<email_verification_tokensUpdateWithoutUsersInput, email_verification_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<email_verification_tokensCreateWithoutUsersInput, email_verification_tokensUncheckedCreateWithoutUsersInput>
    where?: email_verification_tokensWhereInput
  }

  export type email_verification_tokensUpdateToOneWithWhereWithoutUsersInput = {
    where?: email_verification_tokensWhereInput
    data: XOR<email_verification_tokensUpdateWithoutUsersInput, email_verification_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type email_verification_tokensUpdateWithoutUsersInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_verification_tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lecturersUpsertWithoutUsersInput = {
    update: XOR<lecturersUpdateWithoutUsersInput, lecturersUncheckedUpdateWithoutUsersInput>
    create: XOR<lecturersCreateWithoutUsersInput, lecturersUncheckedCreateWithoutUsersInput>
    where?: lecturersWhereInput
  }

  export type lecturersUpdateToOneWithWhereWithoutUsersInput = {
    where?: lecturersWhereInput
    data: XOR<lecturersUpdateWithoutUsersInput, lecturersUncheckedUpdateWithoutUsersInput>
  }

  export type lecturersUpdateWithoutUsersInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: assistantsUpdateManyWithoutLecturersNestedInput
  }

  export type lecturersUncheckedUpdateWithoutUsersInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: assistantsUncheckedUpdateManyWithoutLecturersNestedInput
  }

  export type parentsUpsertWithoutUsersInput = {
    update: XOR<parentsUpdateWithoutUsersInput, parentsUncheckedUpdateWithoutUsersInput>
    create: XOR<parentsCreateWithoutUsersInput, parentsUncheckedCreateWithoutUsersInput>
    where?: parentsWhereInput
  }

  export type parentsUpdateToOneWithWhereWithoutUsersInput = {
    where?: parentsWhereInput
    data: XOR<parentsUpdateWithoutUsersInput, parentsUncheckedUpdateWithoutUsersInput>
  }

  export type parentsUpdateWithoutUsersInput = {
    parent_children?: parent_childrenUpdateManyWithoutParentsNestedInput
    government?: governmentUpdateOneWithoutParentsNestedInput
    zones?: zonesUpdateOneWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutUsersInput = {
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type password_reset_tokensUpsertWithoutUsersInput = {
    update: XOR<password_reset_tokensUpdateWithoutUsersInput, password_reset_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<password_reset_tokensCreateWithoutUsersInput, password_reset_tokensUncheckedCreateWithoutUsersInput>
    where?: password_reset_tokensWhereInput
  }

  export type password_reset_tokensUpdateToOneWithWhereWithoutUsersInput = {
    where?: password_reset_tokensWhereInput
    data: XOR<password_reset_tokensUpdateWithoutUsersInput, password_reset_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type password_reset_tokensUpdateWithoutUsersInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refresh_tokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: refresh_tokensWhereUniqueInput
    update: XOR<refresh_tokensUpdateWithoutUsersInput, refresh_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
  }

  export type refresh_tokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: refresh_tokensWhereUniqueInput
    data: XOR<refresh_tokensUpdateWithoutUsersInput, refresh_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type refresh_tokensUpdateManyWithWhereWithoutUsersInput = {
    where: refresh_tokensScalarWhereInput
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyWithoutUsersInput>
  }

  export type refresh_tokensScalarWhereInput = {
    AND?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
    OR?: refresh_tokensScalarWhereInput[]
    NOT?: refresh_tokensScalarWhereInput | refresh_tokensScalarWhereInput[]
    id?: IntFilter<"refresh_tokens"> | number
    user_id?: IntFilter<"refresh_tokens"> | number
    token_hash?: StringFilter<"refresh_tokens"> | string
    revoked?: BoolNullableFilter<"refresh_tokens"> | boolean | null
    created_at?: DateTimeNullableFilter<"refresh_tokens"> | Date | string | null
    expires_at?: DateTimeFilter<"refresh_tokens"> | Date | string
  }

  export type social_mediaUpsertWithWhereUniqueWithoutUsersInput = {
    where: social_mediaWhereUniqueInput
    update: XOR<social_mediaUpdateWithoutUsersInput, social_mediaUncheckedUpdateWithoutUsersInput>
    create: XOR<social_mediaCreateWithoutUsersInput, social_mediaUncheckedCreateWithoutUsersInput>
  }

  export type social_mediaUpdateWithWhereUniqueWithoutUsersInput = {
    where: social_mediaWhereUniqueInput
    data: XOR<social_mediaUpdateWithoutUsersInput, social_mediaUncheckedUpdateWithoutUsersInput>
  }

  export type social_mediaUpdateManyWithWhereWithoutUsersInput = {
    where: social_mediaScalarWhereInput
    data: XOR<social_mediaUpdateManyMutationInput, social_mediaUncheckedUpdateManyWithoutUsersInput>
  }

  export type social_mediaScalarWhereInput = {
    AND?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
    OR?: social_mediaScalarWhereInput[]
    NOT?: social_mediaScalarWhereInput | social_mediaScalarWhereInput[]
    id?: IntFilter<"social_media"> | number
    teacher_user_id?: IntFilter<"social_media"> | number
    site_id?: IntNullableFilter<"social_media"> | number | null
    url?: StringFilter<"social_media"> | string
    active?: BoolNullableFilter<"social_media"> | boolean | null
  }

  export type studentsUpsertWithoutUsersInput = {
    update: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutUsersInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type studentsUpdateWithoutUsersInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUpdateManyWithoutStudentsNestedInput
    government?: governmentUpdateOneWithoutStudentsNestedInput
    levels?: levelsUpdateOneWithoutStudentsNestedInput
    zones?: zonesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutUsersInput = {
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersUpsertWithoutUsersInput = {
    update: XOR<teachersUpdateWithoutUsersInput, teachersUncheckedUpdateWithoutUsersInput>
    create: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutUsersInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutUsersInput, teachersUncheckedUpdateWithoutUsersInput>
  }

  export type teachersUpdateWithoutUsersInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government?: governmentUpdateOneWithoutTeachersNestedInput
    subjects?: subjectsUpdateOneWithoutTeachersNestedInput
    zones?: zonesUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutUsersInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teaches_atUpsertWithWhereUniqueWithoutUsersInput = {
    where: teaches_atWhereUniqueInput
    update: XOR<teaches_atUpdateWithoutUsersInput, teaches_atUncheckedUpdateWithoutUsersInput>
    create: XOR<teaches_atCreateWithoutUsersInput, teaches_atUncheckedCreateWithoutUsersInput>
  }

  export type teaches_atUpdateWithWhereUniqueWithoutUsersInput = {
    where: teaches_atWhereUniqueInput
    data: XOR<teaches_atUpdateWithoutUsersInput, teaches_atUncheckedUpdateWithoutUsersInput>
  }

  export type teaches_atUpdateManyWithWhereWithoutUsersInput = {
    where: teaches_atScalarWhereInput
    data: XOR<teaches_atUpdateManyMutationInput, teaches_atUncheckedUpdateManyWithoutUsersInput>
  }

  export type teaches_atScalarWhereInput = {
    AND?: teaches_atScalarWhereInput | teaches_atScalarWhereInput[]
    OR?: teaches_atScalarWhereInput[]
    NOT?: teaches_atScalarWhereInput | teaches_atScalarWhereInput[]
    id?: IntFilter<"teaches_at"> | number
    user_id?: IntFilter<"teaches_at"> | number
    location_name?: StringNullableFilter<"teaches_at"> | string | null
    location_type?: Enumlocation_type_enumNullableFilter<"teaches_at"> | $Enums.location_type_enum | null
    active?: BoolNullableFilter<"teaches_at"> | boolean | null
  }

  export type user_analyticsUpsertWithoutUsersInput = {
    update: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
    where?: user_analyticsWhereInput
  }

  export type user_analyticsUpdateToOneWithWhereWithoutUsersInput = {
    where?: user_analyticsWhereInput
    data: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
  }

  export type user_analyticsUpdateWithoutUsersInput = {
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_analyticsUncheckedUpdateWithoutUsersInput = {
    views?: NullableIntFieldUpdateOperationsInput | number | null
    total_spent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number_of_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    successful_invites?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_confirmed_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_confirmed_count_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_rolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutUsersInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    id?: IntFilter<"user_roles"> | number
    user_id?: IntFilter<"user_roles"> | number
    portal?: Enumportal_enumFilter<"user_roles"> | $Enums.portal_enum
    role?: Enumrole_enumFilter<"user_roles"> | $Enums.role_enum
  }

  export type usersCreateWithoutRefresh_tokensInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRefresh_tokensInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRefresh_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
  }

  export type usersUpsertWithoutRefresh_tokensInput = {
    update: XOR<usersUpdateWithoutRefresh_tokensInput, usersUncheckedUpdateWithoutRefresh_tokensInput>
    create: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRefresh_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRefresh_tokensInput, usersUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type usersUpdateWithoutRefresh_tokensInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRefresh_tokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type lecturersCreateWithoutAssistantsInput = {
    bio?: string | null
    expertise?: string | null
    users: usersCreateNestedOneWithoutLecturersInput
  }

  export type lecturersUncheckedCreateWithoutAssistantsInput = {
    user_id: number
    bio?: string | null
    expertise?: string | null
  }

  export type lecturersCreateOrConnectWithoutAssistantsInput = {
    where: lecturersWhereUniqueInput
    create: XOR<lecturersCreateWithoutAssistantsInput, lecturersUncheckedCreateWithoutAssistantsInput>
  }

  export type usersCreateWithoutAssistantsInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAssistantsInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAssistantsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAssistantsInput, usersUncheckedCreateWithoutAssistantsInput>
  }

  export type lecturersUpsertWithoutAssistantsInput = {
    update: XOR<lecturersUpdateWithoutAssistantsInput, lecturersUncheckedUpdateWithoutAssistantsInput>
    create: XOR<lecturersCreateWithoutAssistantsInput, lecturersUncheckedCreateWithoutAssistantsInput>
    where?: lecturersWhereInput
  }

  export type lecturersUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: lecturersWhereInput
    data: XOR<lecturersUpdateWithoutAssistantsInput, lecturersUncheckedUpdateWithoutAssistantsInput>
  }

  export type lecturersUpdateWithoutAssistantsInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutLecturersNestedInput
  }

  export type lecturersUncheckedUpdateWithoutAssistantsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutAssistantsInput = {
    update: XOR<usersUpdateWithoutAssistantsInput, usersUncheckedUpdateWithoutAssistantsInput>
    create: XOR<usersCreateWithoutAssistantsInput, usersUncheckedCreateWithoutAssistantsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAssistantsInput, usersUncheckedUpdateWithoutAssistantsInput>
  }

  export type usersUpdateWithoutAssistantsInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAssistantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type parentsCreateWithoutGovernmentInput = {
    parent_children?: parent_childrenCreateNestedManyWithoutParentsInput
    users: usersCreateNestedOneWithoutParentsInput
    zones?: zonesCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutGovernmentInput = {
    user_id: number
    zone_id?: number | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutGovernmentInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput>
  }

  export type parentsCreateManyGovernmentInputEnvelope = {
    data: parentsCreateManyGovernmentInput | parentsCreateManyGovernmentInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutGovernmentInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenCreateNestedManyWithoutStudentsInput
    levels?: levelsCreateNestedOneWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    zones?: zonesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutGovernmentInput = {
    user_id: number
    level_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutGovernmentInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput>
  }

  export type studentsCreateManyGovernmentInputEnvelope = {
    data: studentsCreateManyGovernmentInput | studentsCreateManyGovernmentInput[]
    skipDuplicates?: boolean
  }

  export type teachersCreateWithoutGovernmentInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    subjects?: subjectsCreateNestedOneWithoutTeachersInput
    users: usersCreateNestedOneWithoutTeachersInput
    zones?: zonesCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutGovernmentInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    zone_id?: number | null
    subject_id?: number | null
  }

  export type teachersCreateOrConnectWithoutGovernmentInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput>
  }

  export type teachersCreateManyGovernmentInputEnvelope = {
    data: teachersCreateManyGovernmentInput | teachersCreateManyGovernmentInput[]
    skipDuplicates?: boolean
  }

  export type zonesCreateWithoutGovernmentInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutZonesInput
    students?: studentsCreateNestedManyWithoutZonesInput
    teachers?: teachersCreateNestedManyWithoutZonesInput
  }

  export type zonesUncheckedCreateWithoutGovernmentInput = {
    id?: number
    title: string
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutZonesInput
    students?: studentsUncheckedCreateNestedManyWithoutZonesInput
    teachers?: teachersUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesCreateOrConnectWithoutGovernmentInput = {
    where: zonesWhereUniqueInput
    create: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput>
  }

  export type zonesCreateManyGovernmentInputEnvelope = {
    data: zonesCreateManyGovernmentInput | zonesCreateManyGovernmentInput[]
    skipDuplicates?: boolean
  }

  export type parentsUpsertWithWhereUniqueWithoutGovernmentInput = {
    where: parentsWhereUniqueInput
    update: XOR<parentsUpdateWithoutGovernmentInput, parentsUncheckedUpdateWithoutGovernmentInput>
    create: XOR<parentsCreateWithoutGovernmentInput, parentsUncheckedCreateWithoutGovernmentInput>
  }

  export type parentsUpdateWithWhereUniqueWithoutGovernmentInput = {
    where: parentsWhereUniqueInput
    data: XOR<parentsUpdateWithoutGovernmentInput, parentsUncheckedUpdateWithoutGovernmentInput>
  }

  export type parentsUpdateManyWithWhereWithoutGovernmentInput = {
    where: parentsScalarWhereInput
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyWithoutGovernmentInput>
  }

  export type parentsScalarWhereInput = {
    AND?: parentsScalarWhereInput | parentsScalarWhereInput[]
    OR?: parentsScalarWhereInput[]
    NOT?: parentsScalarWhereInput | parentsScalarWhereInput[]
    user_id?: IntFilter<"parents"> | number
    government_id?: IntNullableFilter<"parents"> | number | null
    zone_id?: IntNullableFilter<"parents"> | number | null
  }

  export type studentsUpsertWithWhereUniqueWithoutGovernmentInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutGovernmentInput, studentsUncheckedUpdateWithoutGovernmentInput>
    create: XOR<studentsCreateWithoutGovernmentInput, studentsUncheckedCreateWithoutGovernmentInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutGovernmentInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutGovernmentInput, studentsUncheckedUpdateWithoutGovernmentInput>
  }

  export type studentsUpdateManyWithWhereWithoutGovernmentInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutGovernmentInput>
  }

  export type studentsScalarWhereInput = {
    AND?: studentsScalarWhereInput | studentsScalarWhereInput[]
    OR?: studentsScalarWhereInput[]
    NOT?: studentsScalarWhereInput | studentsScalarWhereInput[]
    user_id?: IntFilter<"students"> | number
    level_id?: IntNullableFilter<"students"> | number | null
    government_id?: IntNullableFilter<"students"> | number | null
    zone_id?: IntNullableFilter<"students"> | number | null
    parent_phone_number?: StringNullableFilter<"students"> | string | null
    sequenced_id?: IntNullableFilter<"students"> | number | null
    faction?: StringNullableFilter<"students"> | string | null
  }

  export type teachersUpsertWithWhereUniqueWithoutGovernmentInput = {
    where: teachersWhereUniqueInput
    update: XOR<teachersUpdateWithoutGovernmentInput, teachersUncheckedUpdateWithoutGovernmentInput>
    create: XOR<teachersCreateWithoutGovernmentInput, teachersUncheckedCreateWithoutGovernmentInput>
  }

  export type teachersUpdateWithWhereUniqueWithoutGovernmentInput = {
    where: teachersWhereUniqueInput
    data: XOR<teachersUpdateWithoutGovernmentInput, teachersUncheckedUpdateWithoutGovernmentInput>
  }

  export type teachersUpdateManyWithWhereWithoutGovernmentInput = {
    where: teachersScalarWhereInput
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyWithoutGovernmentInput>
  }

  export type teachersScalarWhereInput = {
    AND?: teachersScalarWhereInput | teachersScalarWhereInput[]
    OR?: teachersScalarWhereInput[]
    NOT?: teachersScalarWhereInput | teachersScalarWhereInput[]
    user_id?: IntFilter<"teachers"> | number
    serial?: StringNullableFilter<"teachers"> | string | null
    is_primary?: BoolNullableFilter<"teachers"> | boolean | null
    is_preparatory?: BoolNullableFilter<"teachers"> | boolean | null
    is_secondary?: BoolNullableFilter<"teachers"> | boolean | null
    government_id?: IntNullableFilter<"teachers"> | number | null
    zone_id?: IntNullableFilter<"teachers"> | number | null
    subject_id?: IntNullableFilter<"teachers"> | number | null
  }

  export type zonesUpsertWithWhereUniqueWithoutGovernmentInput = {
    where: zonesWhereUniqueInput
    update: XOR<zonesUpdateWithoutGovernmentInput, zonesUncheckedUpdateWithoutGovernmentInput>
    create: XOR<zonesCreateWithoutGovernmentInput, zonesUncheckedCreateWithoutGovernmentInput>
  }

  export type zonesUpdateWithWhereUniqueWithoutGovernmentInput = {
    where: zonesWhereUniqueInput
    data: XOR<zonesUpdateWithoutGovernmentInput, zonesUncheckedUpdateWithoutGovernmentInput>
  }

  export type zonesUpdateManyWithWhereWithoutGovernmentInput = {
    where: zonesScalarWhereInput
    data: XOR<zonesUpdateManyMutationInput, zonesUncheckedUpdateManyWithoutGovernmentInput>
  }

  export type zonesScalarWhereInput = {
    AND?: zonesScalarWhereInput | zonesScalarWhereInput[]
    OR?: zonesScalarWhereInput[]
    NOT?: zonesScalarWhereInput | zonesScalarWhereInput[]
    id?: IntFilter<"zones"> | number
    title?: StringFilter<"zones"> | string
    government_id?: IntFilter<"zones"> | number
    active?: BoolNullableFilter<"zones"> | boolean | null
  }

  export type assistantsCreateWithoutLecturersInput = {
    users: usersCreateNestedOneWithoutAssistantsInput
  }

  export type assistantsUncheckedCreateWithoutLecturersInput = {
    id?: number
    user_id: number
  }

  export type assistantsCreateOrConnectWithoutLecturersInput = {
    where: assistantsWhereUniqueInput
    create: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput>
  }

  export type assistantsCreateManyLecturersInputEnvelope = {
    data: assistantsCreateManyLecturersInput | assistantsCreateManyLecturersInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutLecturersInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLecturersInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLecturersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLecturersInput, usersUncheckedCreateWithoutLecturersInput>
  }

  export type assistantsUpsertWithWhereUniqueWithoutLecturersInput = {
    where: assistantsWhereUniqueInput
    update: XOR<assistantsUpdateWithoutLecturersInput, assistantsUncheckedUpdateWithoutLecturersInput>
    create: XOR<assistantsCreateWithoutLecturersInput, assistantsUncheckedCreateWithoutLecturersInput>
  }

  export type assistantsUpdateWithWhereUniqueWithoutLecturersInput = {
    where: assistantsWhereUniqueInput
    data: XOR<assistantsUpdateWithoutLecturersInput, assistantsUncheckedUpdateWithoutLecturersInput>
  }

  export type assistantsUpdateManyWithWhereWithoutLecturersInput = {
    where: assistantsScalarWhereInput
    data: XOR<assistantsUpdateManyMutationInput, assistantsUncheckedUpdateManyWithoutLecturersInput>
  }

  export type usersUpsertWithoutLecturersInput = {
    update: XOR<usersUpdateWithoutLecturersInput, usersUncheckedUpdateWithoutLecturersInput>
    create: XOR<usersCreateWithoutLecturersInput, usersUncheckedCreateWithoutLecturersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLecturersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLecturersInput, usersUncheckedUpdateWithoutLecturersInput>
  }

  export type usersUpdateWithoutLecturersInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLecturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type studentsCreateWithoutLevelsInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenCreateNestedManyWithoutStudentsInput
    government?: governmentCreateNestedOneWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    zones?: zonesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutLevelsInput = {
    user_id: number
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutLevelsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput>
  }

  export type studentsCreateManyLevelsInputEnvelope = {
    data: studentsCreateManyLevelsInput | studentsCreateManyLevelsInput[]
    skipDuplicates?: boolean
  }

  export type studentsUpsertWithWhereUniqueWithoutLevelsInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutLevelsInput, studentsUncheckedUpdateWithoutLevelsInput>
    create: XOR<studentsCreateWithoutLevelsInput, studentsUncheckedCreateWithoutLevelsInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutLevelsInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutLevelsInput, studentsUncheckedUpdateWithoutLevelsInput>
  }

  export type studentsUpdateManyWithWhereWithoutLevelsInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutLevelsInput>
  }

  export type parentsCreateWithoutParent_childrenInput = {
    government?: governmentCreateNestedOneWithoutParentsInput
    users: usersCreateNestedOneWithoutParentsInput
    zones?: zonesCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutParent_childrenInput = {
    user_id: number
    government_id?: number | null
    zone_id?: number | null
  }

  export type parentsCreateOrConnectWithoutParent_childrenInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutParent_childrenInput, parentsUncheckedCreateWithoutParent_childrenInput>
  }

  export type studentsCreateWithoutParent_childrenInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    government?: governmentCreateNestedOneWithoutStudentsInput
    levels?: levelsCreateNestedOneWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    zones?: zonesCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutParent_childrenInput = {
    user_id: number
    level_id?: number | null
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
  }

  export type studentsCreateOrConnectWithoutParent_childrenInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutParent_childrenInput, studentsUncheckedCreateWithoutParent_childrenInput>
  }

  export type parentsUpsertWithoutParent_childrenInput = {
    update: XOR<parentsUpdateWithoutParent_childrenInput, parentsUncheckedUpdateWithoutParent_childrenInput>
    create: XOR<parentsCreateWithoutParent_childrenInput, parentsUncheckedCreateWithoutParent_childrenInput>
    where?: parentsWhereInput
  }

  export type parentsUpdateToOneWithWhereWithoutParent_childrenInput = {
    where?: parentsWhereInput
    data: XOR<parentsUpdateWithoutParent_childrenInput, parentsUncheckedUpdateWithoutParent_childrenInput>
  }

  export type parentsUpdateWithoutParent_childrenInput = {
    government?: governmentUpdateOneWithoutParentsNestedInput
    users?: usersUpdateOneRequiredWithoutParentsNestedInput
    zones?: zonesUpdateOneWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutParent_childrenInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentsUpsertWithoutParent_childrenInput = {
    update: XOR<studentsUpdateWithoutParent_childrenInput, studentsUncheckedUpdateWithoutParent_childrenInput>
    create: XOR<studentsCreateWithoutParent_childrenInput, studentsUncheckedCreateWithoutParent_childrenInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutParent_childrenInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutParent_childrenInput, studentsUncheckedUpdateWithoutParent_childrenInput>
  }

  export type studentsUpdateWithoutParent_childrenInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    government?: governmentUpdateOneWithoutStudentsNestedInput
    levels?: levelsUpdateOneWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    zones?: zonesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutParent_childrenInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parent_childrenCreateWithoutParentsInput = {
    students: studentsCreateNestedOneWithoutParent_childrenInput
  }

  export type parent_childrenUncheckedCreateWithoutParentsInput = {
    id?: number
    student_user_id: number
  }

  export type parent_childrenCreateOrConnectWithoutParentsInput = {
    where: parent_childrenWhereUniqueInput
    create: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput>
  }

  export type parent_childrenCreateManyParentsInputEnvelope = {
    data: parent_childrenCreateManyParentsInput | parent_childrenCreateManyParentsInput[]
    skipDuplicates?: boolean
  }

  export type governmentCreateWithoutParentsInput = {
    title: string
    active?: boolean | null
    students?: studentsCreateNestedManyWithoutGovernmentInput
    teachers?: teachersCreateNestedManyWithoutGovernmentInput
    zones?: zonesCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUncheckedCreateWithoutParentsInput = {
    id?: number
    title: string
    active?: boolean | null
    students?: studentsUncheckedCreateNestedManyWithoutGovernmentInput
    teachers?: teachersUncheckedCreateNestedManyWithoutGovernmentInput
    zones?: zonesUncheckedCreateNestedManyWithoutGovernmentInput
  }

  export type governmentCreateOrConnectWithoutParentsInput = {
    where: governmentWhereUniqueInput
    create: XOR<governmentCreateWithoutParentsInput, governmentUncheckedCreateWithoutParentsInput>
  }

  export type usersCreateWithoutParentsInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutParentsInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutParentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutParentsInput, usersUncheckedCreateWithoutParentsInput>
  }

  export type zonesCreateWithoutParentsInput = {
    title: string
    active?: boolean | null
    students?: studentsCreateNestedManyWithoutZonesInput
    teachers?: teachersCreateNestedManyWithoutZonesInput
    government: governmentCreateNestedOneWithoutZonesInput
  }

  export type zonesUncheckedCreateWithoutParentsInput = {
    id?: number
    title: string
    government_id: number
    active?: boolean | null
    students?: studentsUncheckedCreateNestedManyWithoutZonesInput
    teachers?: teachersUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesCreateOrConnectWithoutParentsInput = {
    where: zonesWhereUniqueInput
    create: XOR<zonesCreateWithoutParentsInput, zonesUncheckedCreateWithoutParentsInput>
  }

  export type parent_childrenUpsertWithWhereUniqueWithoutParentsInput = {
    where: parent_childrenWhereUniqueInput
    update: XOR<parent_childrenUpdateWithoutParentsInput, parent_childrenUncheckedUpdateWithoutParentsInput>
    create: XOR<parent_childrenCreateWithoutParentsInput, parent_childrenUncheckedCreateWithoutParentsInput>
  }

  export type parent_childrenUpdateWithWhereUniqueWithoutParentsInput = {
    where: parent_childrenWhereUniqueInput
    data: XOR<parent_childrenUpdateWithoutParentsInput, parent_childrenUncheckedUpdateWithoutParentsInput>
  }

  export type parent_childrenUpdateManyWithWhereWithoutParentsInput = {
    where: parent_childrenScalarWhereInput
    data: XOR<parent_childrenUpdateManyMutationInput, parent_childrenUncheckedUpdateManyWithoutParentsInput>
  }

  export type parent_childrenScalarWhereInput = {
    AND?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
    OR?: parent_childrenScalarWhereInput[]
    NOT?: parent_childrenScalarWhereInput | parent_childrenScalarWhereInput[]
    id?: IntFilter<"parent_children"> | number
    parent_user_id?: IntFilter<"parent_children"> | number
    student_user_id?: IntFilter<"parent_children"> | number
  }

  export type governmentUpsertWithoutParentsInput = {
    update: XOR<governmentUpdateWithoutParentsInput, governmentUncheckedUpdateWithoutParentsInput>
    create: XOR<governmentCreateWithoutParentsInput, governmentUncheckedCreateWithoutParentsInput>
    where?: governmentWhereInput
  }

  export type governmentUpdateToOneWithWhereWithoutParentsInput = {
    where?: governmentWhereInput
    data: XOR<governmentUpdateWithoutParentsInput, governmentUncheckedUpdateWithoutParentsInput>
  }

  export type governmentUpdateWithoutParentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentUncheckedUpdateWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUncheckedUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUncheckedUpdateManyWithoutGovernmentNestedInput
  }

  export type usersUpsertWithoutParentsInput = {
    update: XOR<usersUpdateWithoutParentsInput, usersUncheckedUpdateWithoutParentsInput>
    create: XOR<usersCreateWithoutParentsInput, usersUncheckedCreateWithoutParentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutParentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutParentsInput, usersUncheckedUpdateWithoutParentsInput>
  }

  export type usersUpdateWithoutParentsInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type zonesUpsertWithoutParentsInput = {
    update: XOR<zonesUpdateWithoutParentsInput, zonesUncheckedUpdateWithoutParentsInput>
    create: XOR<zonesCreateWithoutParentsInput, zonesUncheckedCreateWithoutParentsInput>
    where?: zonesWhereInput
  }

  export type zonesUpdateToOneWithWhereWithoutParentsInput = {
    where?: zonesWhereInput
    data: XOR<zonesUpdateWithoutParentsInput, zonesUncheckedUpdateWithoutParentsInput>
  }

  export type zonesUpdateWithoutParentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUpdateManyWithoutZonesNestedInput
    teachers?: teachersUpdateManyWithoutZonesNestedInput
    government?: governmentUpdateOneRequiredWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    government_id?: IntFieldUpdateOperationsInput | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUncheckedUpdateManyWithoutZonesNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type social_mediaCreateWithoutSitesInput = {
    url: string
    active?: boolean | null
    users: usersCreateNestedOneWithoutSocial_mediaInput
  }

  export type social_mediaUncheckedCreateWithoutSitesInput = {
    id?: number
    teacher_user_id: number
    url: string
    active?: boolean | null
  }

  export type social_mediaCreateOrConnectWithoutSitesInput = {
    where: social_mediaWhereUniqueInput
    create: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput>
  }

  export type social_mediaCreateManySitesInputEnvelope = {
    data: social_mediaCreateManySitesInput | social_mediaCreateManySitesInput[]
    skipDuplicates?: boolean
  }

  export type social_mediaUpsertWithWhereUniqueWithoutSitesInput = {
    where: social_mediaWhereUniqueInput
    update: XOR<social_mediaUpdateWithoutSitesInput, social_mediaUncheckedUpdateWithoutSitesInput>
    create: XOR<social_mediaCreateWithoutSitesInput, social_mediaUncheckedCreateWithoutSitesInput>
  }

  export type social_mediaUpdateWithWhereUniqueWithoutSitesInput = {
    where: social_mediaWhereUniqueInput
    data: XOR<social_mediaUpdateWithoutSitesInput, social_mediaUncheckedUpdateWithoutSitesInput>
  }

  export type social_mediaUpdateManyWithWhereWithoutSitesInput = {
    where: social_mediaScalarWhereInput
    data: XOR<social_mediaUpdateManyMutationInput, social_mediaUncheckedUpdateManyWithoutSitesInput>
  }

  export type sitesCreateWithoutSocial_mediaInput = {
    title: string
    active?: boolean | null
  }

  export type sitesUncheckedCreateWithoutSocial_mediaInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type sitesCreateOrConnectWithoutSocial_mediaInput = {
    where: sitesWhereUniqueInput
    create: XOR<sitesCreateWithoutSocial_mediaInput, sitesUncheckedCreateWithoutSocial_mediaInput>
  }

  export type usersCreateWithoutSocial_mediaInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSocial_mediaInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSocial_mediaInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSocial_mediaInput, usersUncheckedCreateWithoutSocial_mediaInput>
  }

  export type sitesUpsertWithoutSocial_mediaInput = {
    update: XOR<sitesUpdateWithoutSocial_mediaInput, sitesUncheckedUpdateWithoutSocial_mediaInput>
    create: XOR<sitesCreateWithoutSocial_mediaInput, sitesUncheckedCreateWithoutSocial_mediaInput>
    where?: sitesWhereInput
  }

  export type sitesUpdateToOneWithWhereWithoutSocial_mediaInput = {
    where?: sitesWhereInput
    data: XOR<sitesUpdateWithoutSocial_mediaInput, sitesUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type sitesUpdateWithoutSocial_mediaInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type sitesUncheckedUpdateWithoutSocial_mediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpsertWithoutSocial_mediaInput = {
    update: XOR<usersUpdateWithoutSocial_mediaInput, usersUncheckedUpdateWithoutSocial_mediaInput>
    create: XOR<usersCreateWithoutSocial_mediaInput, usersUncheckedCreateWithoutSocial_mediaInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSocial_mediaInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSocial_mediaInput, usersUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type usersUpdateWithoutSocial_mediaInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSocial_mediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type parent_childrenCreateWithoutStudentsInput = {
    parents: parentsCreateNestedOneWithoutParent_childrenInput
  }

  export type parent_childrenUncheckedCreateWithoutStudentsInput = {
    id?: number
    parent_user_id: number
  }

  export type parent_childrenCreateOrConnectWithoutStudentsInput = {
    where: parent_childrenWhereUniqueInput
    create: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput>
  }

  export type parent_childrenCreateManyStudentsInputEnvelope = {
    data: parent_childrenCreateManyStudentsInput | parent_childrenCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type governmentCreateWithoutStudentsInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutGovernmentInput
    teachers?: teachersCreateNestedManyWithoutGovernmentInput
    zones?: zonesCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUncheckedCreateWithoutStudentsInput = {
    id?: number
    title: string
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutGovernmentInput
    teachers?: teachersUncheckedCreateNestedManyWithoutGovernmentInput
    zones?: zonesUncheckedCreateNestedManyWithoutGovernmentInput
  }

  export type governmentCreateOrConnectWithoutStudentsInput = {
    where: governmentWhereUniqueInput
    create: XOR<governmentCreateWithoutStudentsInput, governmentUncheckedCreateWithoutStudentsInput>
  }

  export type levelsCreateWithoutStudentsInput = {
    title: string
    active?: boolean | null
  }

  export type levelsUncheckedCreateWithoutStudentsInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type levelsCreateOrConnectWithoutStudentsInput = {
    where: levelsWhereUniqueInput
    create: XOR<levelsCreateWithoutStudentsInput, levelsUncheckedCreateWithoutStudentsInput>
  }

  export type usersCreateWithoutStudentsInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutStudentsInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutStudentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
  }

  export type zonesCreateWithoutStudentsInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutZonesInput
    teachers?: teachersCreateNestedManyWithoutZonesInput
    government: governmentCreateNestedOneWithoutZonesInput
  }

  export type zonesUncheckedCreateWithoutStudentsInput = {
    id?: number
    title: string
    government_id: number
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutZonesInput
    teachers?: teachersUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesCreateOrConnectWithoutStudentsInput = {
    where: zonesWhereUniqueInput
    create: XOR<zonesCreateWithoutStudentsInput, zonesUncheckedCreateWithoutStudentsInput>
  }

  export type parent_childrenUpsertWithWhereUniqueWithoutStudentsInput = {
    where: parent_childrenWhereUniqueInput
    update: XOR<parent_childrenUpdateWithoutStudentsInput, parent_childrenUncheckedUpdateWithoutStudentsInput>
    create: XOR<parent_childrenCreateWithoutStudentsInput, parent_childrenUncheckedCreateWithoutStudentsInput>
  }

  export type parent_childrenUpdateWithWhereUniqueWithoutStudentsInput = {
    where: parent_childrenWhereUniqueInput
    data: XOR<parent_childrenUpdateWithoutStudentsInput, parent_childrenUncheckedUpdateWithoutStudentsInput>
  }

  export type parent_childrenUpdateManyWithWhereWithoutStudentsInput = {
    where: parent_childrenScalarWhereInput
    data: XOR<parent_childrenUpdateManyMutationInput, parent_childrenUncheckedUpdateManyWithoutStudentsInput>
  }

  export type governmentUpsertWithoutStudentsInput = {
    update: XOR<governmentUpdateWithoutStudentsInput, governmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<governmentCreateWithoutStudentsInput, governmentUncheckedCreateWithoutStudentsInput>
    where?: governmentWhereInput
  }

  export type governmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: governmentWhereInput
    data: XOR<governmentUpdateWithoutStudentsInput, governmentUncheckedUpdateWithoutStudentsInput>
  }

  export type governmentUpdateWithoutStudentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUncheckedUpdateManyWithoutGovernmentNestedInput
  }

  export type levelsUpsertWithoutStudentsInput = {
    update: XOR<levelsUpdateWithoutStudentsInput, levelsUncheckedUpdateWithoutStudentsInput>
    create: XOR<levelsCreateWithoutStudentsInput, levelsUncheckedCreateWithoutStudentsInput>
    where?: levelsWhereInput
  }

  export type levelsUpdateToOneWithWhereWithoutStudentsInput = {
    where?: levelsWhereInput
    data: XOR<levelsUpdateWithoutStudentsInput, levelsUncheckedUpdateWithoutStudentsInput>
  }

  export type levelsUpdateWithoutStudentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type levelsUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpsertWithoutStudentsInput = {
    update: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type usersUpdateWithoutStudentsInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type zonesUpsertWithoutStudentsInput = {
    update: XOR<zonesUpdateWithoutStudentsInput, zonesUncheckedUpdateWithoutStudentsInput>
    create: XOR<zonesCreateWithoutStudentsInput, zonesUncheckedCreateWithoutStudentsInput>
    where?: zonesWhereInput
  }

  export type zonesUpdateToOneWithWhereWithoutStudentsInput = {
    where?: zonesWhereInput
    data: XOR<zonesUpdateWithoutStudentsInput, zonesUncheckedUpdateWithoutStudentsInput>
  }

  export type zonesUpdateWithoutStudentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutZonesNestedInput
    teachers?: teachersUpdateManyWithoutZonesNestedInput
    government?: governmentUpdateOneRequiredWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    government_id?: IntFieldUpdateOperationsInput | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutZonesNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type teachersCreateWithoutSubjectsInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government?: governmentCreateNestedOneWithoutTeachersInput
    users: usersCreateNestedOneWithoutTeachersInput
    zones?: zonesCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutSubjectsInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    zone_id?: number | null
  }

  export type teachersCreateOrConnectWithoutSubjectsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput>
  }

  export type teachersCreateManySubjectsInputEnvelope = {
    data: teachersCreateManySubjectsInput | teachersCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type teachersUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: teachersWhereUniqueInput
    update: XOR<teachersUpdateWithoutSubjectsInput, teachersUncheckedUpdateWithoutSubjectsInput>
    create: XOR<teachersCreateWithoutSubjectsInput, teachersUncheckedCreateWithoutSubjectsInput>
  }

  export type teachersUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: teachersWhereUniqueInput
    data: XOR<teachersUpdateWithoutSubjectsInput, teachersUncheckedUpdateWithoutSubjectsInput>
  }

  export type teachersUpdateManyWithWhereWithoutSubjectsInput = {
    where: teachersScalarWhereInput
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type governmentCreateWithoutTeachersInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutGovernmentInput
    students?: studentsCreateNestedManyWithoutGovernmentInput
    zones?: zonesCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUncheckedCreateWithoutTeachersInput = {
    id?: number
    title: string
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutGovernmentInput
    students?: studentsUncheckedCreateNestedManyWithoutGovernmentInput
    zones?: zonesUncheckedCreateNestedManyWithoutGovernmentInput
  }

  export type governmentCreateOrConnectWithoutTeachersInput = {
    where: governmentWhereUniqueInput
    create: XOR<governmentCreateWithoutTeachersInput, governmentUncheckedCreateWithoutTeachersInput>
  }

  export type subjectsCreateWithoutTeachersInput = {
    title: string
    active?: boolean | null
  }

  export type subjectsUncheckedCreateWithoutTeachersInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type subjectsCreateOrConnectWithoutTeachersInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutTeachersInput, subjectsUncheckedCreateWithoutTeachersInput>
  }

  export type usersCreateWithoutTeachersInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTeachersInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTeachersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
  }

  export type zonesCreateWithoutTeachersInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutZonesInput
    students?: studentsCreateNestedManyWithoutZonesInput
    government: governmentCreateNestedOneWithoutZonesInput
  }

  export type zonesUncheckedCreateWithoutTeachersInput = {
    id?: number
    title: string
    government_id: number
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutZonesInput
    students?: studentsUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesCreateOrConnectWithoutTeachersInput = {
    where: zonesWhereUniqueInput
    create: XOR<zonesCreateWithoutTeachersInput, zonesUncheckedCreateWithoutTeachersInput>
  }

  export type governmentUpsertWithoutTeachersInput = {
    update: XOR<governmentUpdateWithoutTeachersInput, governmentUncheckedUpdateWithoutTeachersInput>
    create: XOR<governmentCreateWithoutTeachersInput, governmentUncheckedCreateWithoutTeachersInput>
    where?: governmentWhereInput
  }

  export type governmentUpdateToOneWithWhereWithoutTeachersInput = {
    where?: governmentWhereInput
    data: XOR<governmentUpdateWithoutTeachersInput, governmentUncheckedUpdateWithoutTeachersInput>
  }

  export type governmentUpdateWithoutTeachersInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutGovernmentNestedInput
    students?: studentsUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutGovernmentNestedInput
    students?: studentsUncheckedUpdateManyWithoutGovernmentNestedInput
    zones?: zonesUncheckedUpdateManyWithoutGovernmentNestedInput
  }

  export type subjectsUpsertWithoutTeachersInput = {
    update: XOR<subjectsUpdateWithoutTeachersInput, subjectsUncheckedUpdateWithoutTeachersInput>
    create: XOR<subjectsCreateWithoutTeachersInput, subjectsUncheckedCreateWithoutTeachersInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutTeachersInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutTeachersInput, subjectsUncheckedUpdateWithoutTeachersInput>
  }

  export type subjectsUpdateWithoutTeachersInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type subjectsUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpsertWithoutTeachersInput = {
    update: XOR<usersUpdateWithoutTeachersInput, usersUncheckedUpdateWithoutTeachersInput>
    create: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTeachersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTeachersInput, usersUncheckedUpdateWithoutTeachersInput>
  }

  export type usersUpdateWithoutTeachersInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type zonesUpsertWithoutTeachersInput = {
    update: XOR<zonesUpdateWithoutTeachersInput, zonesUncheckedUpdateWithoutTeachersInput>
    create: XOR<zonesCreateWithoutTeachersInput, zonesUncheckedCreateWithoutTeachersInput>
    where?: zonesWhereInput
  }

  export type zonesUpdateToOneWithWhereWithoutTeachersInput = {
    where?: zonesWhereInput
    data: XOR<zonesUpdateWithoutTeachersInput, zonesUncheckedUpdateWithoutTeachersInput>
  }

  export type zonesUpdateWithoutTeachersInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutZonesNestedInput
    students?: studentsUpdateManyWithoutZonesNestedInput
    government?: governmentUpdateOneRequiredWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    government_id?: IntFieldUpdateOperationsInput | number
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutZonesNestedInput
    students?: studentsUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type usersCreateWithoutTeaches_atInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTeaches_atInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTeaches_atInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeaches_atInput, usersUncheckedCreateWithoutTeaches_atInput>
  }

  export type usersUpsertWithoutTeaches_atInput = {
    update: XOR<usersUpdateWithoutTeaches_atInput, usersUncheckedUpdateWithoutTeaches_atInput>
    create: XOR<usersCreateWithoutTeaches_atInput, usersUncheckedCreateWithoutTeaches_atInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTeaches_atInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTeaches_atInput, usersUncheckedUpdateWithoutTeaches_atInput>
  }

  export type usersUpdateWithoutTeaches_atInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeaches_atInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type parentsCreateWithoutZonesInput = {
    parent_children?: parent_childrenCreateNestedManyWithoutParentsInput
    government?: governmentCreateNestedOneWithoutParentsInput
    users: usersCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutZonesInput = {
    user_id: number
    government_id?: number | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutZonesInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput>
  }

  export type parentsCreateManyZonesInputEnvelope = {
    data: parentsCreateManyZonesInput | parentsCreateManyZonesInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutZonesInput = {
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenCreateNestedManyWithoutStudentsInput
    government?: governmentCreateNestedOneWithoutStudentsInput
    levels?: levelsCreateNestedOneWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutZonesInput = {
    user_id: number
    level_id?: number | null
    government_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
    parent_children?: parent_childrenUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutZonesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput>
  }

  export type studentsCreateManyZonesInputEnvelope = {
    data: studentsCreateManyZonesInput | studentsCreateManyZonesInput[]
    skipDuplicates?: boolean
  }

  export type teachersCreateWithoutZonesInput = {
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government?: governmentCreateNestedOneWithoutTeachersInput
    subjects?: subjectsCreateNestedOneWithoutTeachersInput
    users: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutZonesInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    subject_id?: number | null
  }

  export type teachersCreateOrConnectWithoutZonesInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput>
  }

  export type teachersCreateManyZonesInputEnvelope = {
    data: teachersCreateManyZonesInput | teachersCreateManyZonesInput[]
    skipDuplicates?: boolean
  }

  export type governmentCreateWithoutZonesInput = {
    title: string
    active?: boolean | null
    parents?: parentsCreateNestedManyWithoutGovernmentInput
    students?: studentsCreateNestedManyWithoutGovernmentInput
    teachers?: teachersCreateNestedManyWithoutGovernmentInput
  }

  export type governmentUncheckedCreateWithoutZonesInput = {
    id?: number
    title: string
    active?: boolean | null
    parents?: parentsUncheckedCreateNestedManyWithoutGovernmentInput
    students?: studentsUncheckedCreateNestedManyWithoutGovernmentInput
    teachers?: teachersUncheckedCreateNestedManyWithoutGovernmentInput
  }

  export type governmentCreateOrConnectWithoutZonesInput = {
    where: governmentWhereUniqueInput
    create: XOR<governmentCreateWithoutZonesInput, governmentUncheckedCreateWithoutZonesInput>
  }

  export type parentsUpsertWithWhereUniqueWithoutZonesInput = {
    where: parentsWhereUniqueInput
    update: XOR<parentsUpdateWithoutZonesInput, parentsUncheckedUpdateWithoutZonesInput>
    create: XOR<parentsCreateWithoutZonesInput, parentsUncheckedCreateWithoutZonesInput>
  }

  export type parentsUpdateWithWhereUniqueWithoutZonesInput = {
    where: parentsWhereUniqueInput
    data: XOR<parentsUpdateWithoutZonesInput, parentsUncheckedUpdateWithoutZonesInput>
  }

  export type parentsUpdateManyWithWhereWithoutZonesInput = {
    where: parentsScalarWhereInput
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyWithoutZonesInput>
  }

  export type studentsUpsertWithWhereUniqueWithoutZonesInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutZonesInput, studentsUncheckedUpdateWithoutZonesInput>
    create: XOR<studentsCreateWithoutZonesInput, studentsUncheckedCreateWithoutZonesInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutZonesInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutZonesInput, studentsUncheckedUpdateWithoutZonesInput>
  }

  export type studentsUpdateManyWithWhereWithoutZonesInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutZonesInput>
  }

  export type teachersUpsertWithWhereUniqueWithoutZonesInput = {
    where: teachersWhereUniqueInput
    update: XOR<teachersUpdateWithoutZonesInput, teachersUncheckedUpdateWithoutZonesInput>
    create: XOR<teachersCreateWithoutZonesInput, teachersUncheckedCreateWithoutZonesInput>
  }

  export type teachersUpdateWithWhereUniqueWithoutZonesInput = {
    where: teachersWhereUniqueInput
    data: XOR<teachersUpdateWithoutZonesInput, teachersUncheckedUpdateWithoutZonesInput>
  }

  export type teachersUpdateManyWithWhereWithoutZonesInput = {
    where: teachersScalarWhereInput
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyWithoutZonesInput>
  }

  export type governmentUpsertWithoutZonesInput = {
    update: XOR<governmentUpdateWithoutZonesInput, governmentUncheckedUpdateWithoutZonesInput>
    create: XOR<governmentCreateWithoutZonesInput, governmentUncheckedCreateWithoutZonesInput>
    where?: governmentWhereInput
  }

  export type governmentUpdateToOneWithWhereWithoutZonesInput = {
    where?: governmentWhereInput
    data: XOR<governmentUpdateWithoutZonesInput, governmentUncheckedUpdateWithoutZonesInput>
  }

  export type governmentUpdateWithoutZonesInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutGovernmentNestedInput
    students?: studentsUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUpdateManyWithoutGovernmentNestedInput
  }

  export type governmentUncheckedUpdateWithoutZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutGovernmentNestedInput
    students?: studentsUncheckedUpdateManyWithoutGovernmentNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutGovernmentNestedInput
  }

  export type usersCreateWithoutEmail_verification_tokensInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutEmail_verification_tokensInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutEmail_verification_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEmail_verification_tokensInput, usersUncheckedCreateWithoutEmail_verification_tokensInput>
  }

  export type usersUpsertWithoutEmail_verification_tokensInput = {
    update: XOR<usersUpdateWithoutEmail_verification_tokensInput, usersUncheckedUpdateWithoutEmail_verification_tokensInput>
    create: XOR<usersCreateWithoutEmail_verification_tokensInput, usersUncheckedCreateWithoutEmail_verification_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutEmail_verification_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutEmail_verification_tokensInput, usersUncheckedUpdateWithoutEmail_verification_tokensInput>
  }

  export type usersUpdateWithoutEmail_verification_tokensInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutEmail_verification_tokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutPassword_reset_tokensInput = {
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensCreateNestedOneWithoutUsersInput
    lecturers?: lecturersCreateNestedOneWithoutUsersInput
    parents?: parentsCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedManyWithoutUsersInput
    social_media?: social_mediaCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    teachers?: teachersCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPassword_reset_tokensInput = {
    id?: number
    mongo_id?: string | null
    name: string
    email?: string | null
    password?: string | null
    phone?: string | null
    gender?: $Enums.gender_enum | null
    is_email_verified?: boolean | null
    email_verified_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    secondary_phone?: string | null
    role?: $Enums.role_enum | null
    profile_pic_url?: string | null
    password_changed_at?: Date | string | null
    confirmed?: boolean | null
    hasPromoCode?: boolean | null
    hasUsedPromoCode?: boolean | null
    assistants?: assistantsUncheckedCreateNestedManyWithoutUsersInput
    auth_identities?: auth_identitiesUncheckedCreateNestedManyWithoutUsersInput
    email_verification_tokens?: email_verification_tokensUncheckedCreateNestedOneWithoutUsersInput
    lecturers?: lecturersUncheckedCreateNestedOneWithoutUsersInput
    parents?: parentsUncheckedCreateNestedOneWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedManyWithoutUsersInput
    social_media?: social_mediaUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedOneWithoutUsersInput
    teaches_at?: teaches_atUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedOneWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPassword_reset_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPassword_reset_tokensInput, usersUncheckedCreateWithoutPassword_reset_tokensInput>
  }

  export type usersUpsertWithoutPassword_reset_tokensInput = {
    update: XOR<usersUpdateWithoutPassword_reset_tokensInput, usersUncheckedUpdateWithoutPassword_reset_tokensInput>
    create: XOR<usersCreateWithoutPassword_reset_tokensInput, usersUncheckedCreateWithoutPassword_reset_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPassword_reset_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPassword_reset_tokensInput, usersUncheckedUpdateWithoutPassword_reset_tokensInput>
  }

  export type usersUpdateWithoutPassword_reset_tokensInput = {
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUpdateOneWithoutUsersNestedInput
    parents?: parentsUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    teachers?: teachersUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPassword_reset_tokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    mongo_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumgender_enumFieldUpdateOperationsInput | $Enums.gender_enum | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    secondary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumrole_enumFieldUpdateOperationsInput | $Enums.role_enum | null
    profile_pic_url?: NullableStringFieldUpdateOperationsInput | string | null
    password_changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasUsedPromoCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    assistants?: assistantsUncheckedUpdateManyWithoutUsersNestedInput
    auth_identities?: auth_identitiesUncheckedUpdateManyWithoutUsersNestedInput
    email_verification_tokens?: email_verification_tokensUncheckedUpdateOneWithoutUsersNestedInput
    lecturers?: lecturersUncheckedUpdateOneWithoutUsersNestedInput
    parents?: parentsUncheckedUpdateOneWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateManyWithoutUsersNestedInput
    social_media?: social_mediaUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateOneWithoutUsersNestedInput
    teaches_at?: teaches_atUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateOneWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type assistantsCreateManyUsersInput = {
    id?: number
    lecturer_user_id: number
  }

  export type auth_identitiesCreateManyUsersInput = {
    id?: number
    provider: $Enums.auth_provider_enum
    provider_user_id: string
    provider_email?: string | null
  }

  export type refresh_tokensCreateManyUsersInput = {
    id?: number
    token_hash: string
    revoked?: boolean | null
    created_at?: Date | string | null
    expires_at: Date | string
  }

  export type social_mediaCreateManyUsersInput = {
    id?: number
    site_id?: number | null
    url: string
    active?: boolean | null
  }

  export type teaches_atCreateManyUsersInput = {
    id?: number
    location_name?: string | null
    location_type?: $Enums.location_type_enum | null
    active?: boolean | null
  }

  export type user_rolesCreateManyUsersInput = {
    id?: number
    portal: $Enums.portal_enum
    role: $Enums.role_enum
  }

  export type assistantsUpdateWithoutUsersInput = {
    lecturers?: lecturersUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type assistantsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    lecturer_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type assistantsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    lecturer_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_identitiesUpdateWithoutUsersInput = {
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_identitiesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_identitiesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: Enumauth_provider_enumFieldUpdateOperationsInput | $Enums.auth_provider_enum
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refresh_tokensUpdateWithoutUsersInput = {
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token_hash?: StringFieldUpdateOperationsInput | string
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_mediaUpdateWithoutUsersInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sites?: sitesUpdateOneWithoutSocial_mediaNestedInput
  }

  export type social_mediaUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type social_mediaUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_id?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teaches_atUpdateWithoutUsersInput = {
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teaches_atUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teaches_atUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableEnumlocation_type_enumFieldUpdateOperationsInput | $Enums.location_type_enum | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_rolesUpdateWithoutUsersInput = {
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type user_rolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    portal?: Enumportal_enumFieldUpdateOperationsInput | $Enums.portal_enum
    role?: Enumrole_enumFieldUpdateOperationsInput | $Enums.role_enum
  }

  export type parentsCreateManyGovernmentInput = {
    user_id: number
    zone_id?: number | null
  }

  export type studentsCreateManyGovernmentInput = {
    user_id: number
    level_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
  }

  export type teachersCreateManyGovernmentInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    zone_id?: number | null
    subject_id?: number | null
  }

  export type zonesCreateManyGovernmentInput = {
    id?: number
    title: string
    active?: boolean | null
  }

  export type parentsUpdateWithoutGovernmentInput = {
    parent_children?: parent_childrenUpdateManyWithoutParentsNestedInput
    users?: usersUpdateOneRequiredWithoutParentsNestedInput
    zones?: zonesUpdateOneWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateManyWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentsUpdateWithoutGovernmentInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUpdateManyWithoutStudentsNestedInput
    levels?: levelsUpdateOneWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    zones?: zonesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teachersUpdateWithoutGovernmentInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subjects?: subjectsUpdateOneWithoutTeachersNestedInput
    users?: usersUpdateOneRequiredWithoutTeachersNestedInput
    zones?: zonesUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teachersUncheckedUpdateManyWithoutGovernmentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zonesUpdateWithoutGovernmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUpdateManyWithoutZonesNestedInput
    students?: studentsUpdateManyWithoutZonesNestedInput
    teachers?: teachersUpdateManyWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateWithoutGovernmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parents?: parentsUncheckedUpdateManyWithoutZonesNestedInput
    students?: studentsUncheckedUpdateManyWithoutZonesNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateManyWithoutGovernmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type assistantsCreateManyLecturersInput = {
    id?: number
    user_id: number
  }

  export type assistantsUpdateWithoutLecturersInput = {
    users?: usersUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type assistantsUncheckedUpdateWithoutLecturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type assistantsUncheckedUpdateManyWithoutLecturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type studentsCreateManyLevelsInput = {
    user_id: number
    government_id?: number | null
    zone_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
  }

  export type studentsUpdateWithoutLevelsInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUpdateManyWithoutStudentsNestedInput
    government?: governmentUpdateOneWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    zones?: zonesUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutLevelsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutLevelsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parent_childrenCreateManyParentsInput = {
    id?: number
    student_user_id: number
  }

  export type parent_childrenUpdateWithoutParentsInput = {
    students?: studentsUpdateOneRequiredWithoutParent_childrenNestedInput
  }

  export type parent_childrenUncheckedUpdateWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type parent_childrenUncheckedUpdateManyWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type social_mediaCreateManySitesInput = {
    id?: number
    teacher_user_id: number
    url: string
    active?: boolean | null
  }

  export type social_mediaUpdateWithoutSitesInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutSocial_mediaNestedInput
  }

  export type social_mediaUncheckedUpdateWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_user_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type social_mediaUncheckedUpdateManyWithoutSitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_user_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type parent_childrenCreateManyStudentsInput = {
    id?: number
    parent_user_id: number
  }

  export type parent_childrenUpdateWithoutStudentsInput = {
    parents?: parentsUpdateOneRequiredWithoutParent_childrenNestedInput
  }

  export type parent_childrenUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type parent_childrenUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type teachersCreateManySubjectsInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    zone_id?: number | null
  }

  export type teachersUpdateWithoutSubjectsInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government?: governmentUpdateOneWithoutTeachersNestedInput
    users?: usersUpdateOneRequiredWithoutTeachersNestedInput
    zones?: zonesUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutSubjectsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teachersUncheckedUpdateManyWithoutSubjectsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parentsCreateManyZonesInput = {
    user_id: number
    government_id?: number | null
  }

  export type studentsCreateManyZonesInput = {
    user_id: number
    level_id?: number | null
    government_id?: number | null
    parent_phone_number?: string | null
    sequenced_id?: number | null
    faction?: string | null
  }

  export type teachersCreateManyZonesInput = {
    user_id: number
    serial?: string | null
    is_primary?: boolean | null
    is_preparatory?: boolean | null
    is_secondary?: boolean | null
    government_id?: number | null
    subject_id?: number | null
  }

  export type parentsUpdateWithoutZonesInput = {
    parent_children?: parent_childrenUpdateManyWithoutParentsNestedInput
    government?: governmentUpdateOneWithoutParentsNestedInput
    users?: usersUpdateOneRequiredWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateManyWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentsUpdateWithoutZonesInput = {
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUpdateManyWithoutStudentsNestedInput
    government?: governmentUpdateOneWithoutStudentsNestedInput
    levels?: levelsUpdateOneWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
    parent_children?: parent_childrenUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    level_id?: NullableIntFieldUpdateOperationsInput | number | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    parent_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    sequenced_id?: NullableIntFieldUpdateOperationsInput | number | null
    faction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teachersUpdateWithoutZonesInput = {
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government?: governmentUpdateOneWithoutTeachersNestedInput
    subjects?: subjectsUpdateOneWithoutTeachersNestedInput
    users?: usersUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teachersUncheckedUpdateManyWithoutZonesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_preparatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_secondary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    government_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}